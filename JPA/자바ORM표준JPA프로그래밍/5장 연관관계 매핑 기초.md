# 5장 연관관계 매핑 기초

- 객체 관계 매핑(ORM) 에서 가장 어려운 부분이 객체 연관관계와 테이블 연관관계를 매핑하는 일이다.
- 방향(Direction): [단방향, 양방향] 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다.
- 다중성(Multiplicity): [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)]
- 연관관계의 주인(owner): 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.

------------------

## 단방향 연관관계

- 테이블은 항상 양방향 관계이기 때문에 외래 키를 통해서 조인할 수 있다. (A JOIN B 가 가능하면 B JOIN A 도 가능)
- 객체에서만 참조를 통해 접근하기 때문에 단방향이 있다. (A -> B : A.b)
- 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.( A -> B, B -> A : A.b , B.a)

### 객체 관계 매핑

- 객체의 참조 대상과, 테이블의 외래 키를 매핑하는 것이 연관관계 매핑.
- @ManyToOne: 다대일(N:1) 관계라는 매핑 정보. 필수로 사용해야 함.
- @JoinColumn(name = ""): 외래 키를 매핑할 때 사용. 이 어노테이션은 생략 가능.

--------------------

## 연관관계 사용

### 저장

```java
member1.setTeam(team1);
em.persist(member1);
```
- 회원 엔티티는 팀 엔티티를 참조하고 저장했다.
- JPA는 참조한 팀의 식별자(Team.id)를 외래 키로 사용해서 적절한 등록 쿼리를 생성한다.
```roomsql
INSERT INTO MEMBER (MEMBER_ID, NAME, TEAM_ID) VALUES ('member1','회원1','team1');
```

### 조회

- 연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지.
- 객체 그래프 탐색(객체 연관관계를 사용한 조회)
- 객체지향 쿼리 사용(JPQL)

### 수정

- 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동.
- 참조하는 대상만 변경하면 나머지는 JPA가 자동으로 처리.

### 연관관계 제거

- 연관관계를 null로 업데이트 한다.

### 연관된 엔티티 삭제

- 연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다.
그렇지 않으면 외래 키 제약조건으로 인해 데이터베이스에서 오류가 발생한다.

------------------

## 양방향 연관관계

- 회원과 팀은 다대일 관계. (회원은 많고 팀은 하나)
- 반대로 팀과 회원은 일대다 관계. (팀은 하나고 회원은 많다)
- JPA는 List를 포함해서 Collection, Set, Map 같은 다양한 컬렉션을 지원한다.
- @OneToMany(mappedBy = "team")

-----------------

## 연관관계의 주인

- 객체에는 양방향 연관관계라는 것이 없고, 단방향 연관관계 2개를 어플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다.
- 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리한다.
- 엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로 이 참조로 외래 키를 관리하면 된다.
- 그러나 엔티티를 양방향으로 매핑하면 두 곳에서 서로를 참조하기에 객체의 참조는 둘인데 외래 키는 하나라서 차이가 발생한다.
- 이런 차이로 인해 JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 하는데 이것을 연관관계의 주인(Owner) 이라 한다.

### 양방향 매핑의 규칙: 연관관계의 주인

- 두 연관관계 중 하나를 연관관계의 주인으로 정해야 한다.
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리할 수 있다.
- 주인이 아닌 쪽은 읽기만 할 수 있다.
- 주인은 mappedBy 속성을 사용하지 않는다.
- 주인이 아니면 mappedBy 속성을 사용해서 연관관계의 주인을 지정해야 한다.
- 연관관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것이다.

### 연관관계의 주인은 외래 키가 있는 곳

- 연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다.
- 데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키를 가진다. 따라서 @ManyToOne에는 mappedBy 속성이 없다.

----------------

## 양방향 연관관계의 주의점

- 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것.
- 연관관계의 주인만이 외래 키의 값을 변경할 수 있다.

### 순수한 객체까지 고려한 양방향 연관관계

- 객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전하다.
- 객체까지 고려해서 주인이 아닌 곳에도 값을 입력하는 것이 좋다.

### 연관관계 편의 메소드

- 양방향 연관관계는 결국 양쪽 다 신경 써야 한다.
- 다음처럼 매번 호출을 다르게 하다보면 실수로 둘 중 하나만 호출해서 양방향이 깨질 수 있다.
```java
member.setTeam(team);
team.getMembers().add(member);
```

- 주인 쪽에서 코드를 변경하자.
```java
public void setTeam(Team team){
    this.team = team;
    team.getMembers().add(this);
}
```
- 이렇게 한 번에 양방향 관계를 설정하는 메소드를 연관관계 편의 메소드라 한다.

### 연관관계 편의 메소드 작성 시 주의사항
```java
member1.setTeam(teamA);
member1.setTeam(teamB);
Member findMember = teamA.getMember(); //member1 이 여전히 조회
```
- 연관관계 편의 메소드 작성때 새로운 연관관계를 맺는 코드일 경우 기존의 연관관계를 삭제해주어야 함.
```java
public void setTeam(Team team){
    if(this.team != null){
        this.team.getMembers().remove(this);
    }
    this.team = team;
    team.getMembers().add(this);
}
```
- 관계가 제거되지 않아도 데이터베이스 외래 키를 변경하는 데는 문제가 없다 왜냐하면 주인이 아니기 때문이다.
- 이후 새로운 영속성 컨텍스트에서 조회할 경우 원하는 대로 나오지만, 변경 직후의 버그가 있기 때문에 관계를 제거하는 것이 안전하다.


