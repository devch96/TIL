# 4장 엔티티 매핑

- JPA를 사용하는 데 가장 중요한 일은 엔티티와 테이블을 정확히 매핑하는 것이다.
- 객체와 테이블 매핑: @Entity, @Table
- 기본 키 매핑: @Id
- 필드와 컬럼 매핑: @Column
- 연관관계 매핑: @ManyToOne, @JoinColumn

-----------

## @Entity

- JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 어노테이션을 필수로 붙여야한다.
- @Entity가 붙은 클래스는 JPA가 관리하는 것으로, 엔티티라 부른다.

<br>

- @Entity 속성
  - name: JPA에서 사용할 엔티티 이름을 지정한다. 다른 패키지에 이름이 같은 엔티티 클래스가 있다면 이름을 지정해서
  충돌하지 않도록 해야한다. 설정하지 않으면 클래스 이름을 그대로 사용한다.
  
<br>
  
- @Entity 적용 시 주의사항
  - 기본 생성자는 필수다(파라미터가 없는 public 또는 protected 생성자)
  - final 클래스, enum, interface, inner 클래스에는 사용할 수 없다.
  - 저장할 필드에 final을 사용하면 안된다.

<br>

- JPA가 엔티티 객체를 생성할 때 기본 생성자를 사용하므로 기본 생성자가 있어야 한다.
- 자바는 생성자가 하나도 없으면 기본 생성자를 만들지만, 생성자를 하나 이상 만들면 자동으로 만들어 주지 않으므로 기본 생성자를 직접 만들어야 한다.

--------------

## @Table

- @Table은 엔티티와 매핑할 테이블을 지정한다.

<br>

- @Table 속성
  - name: 매핑할 테이블 이름. 없으면 엔티티 이름을 사용한다.
  - catalog: catalog 기능이 있는 데이터베이스에서 catalog를 매핑한다.
  - schema: schema 기능이 있는 데이터베이스에서 schema를 매핑한다.

----------------

## 다양한 매핑 사용

- 자바의 enum을 사용하려면 @Enumerated 어노테이션으로 매핑해야 한다.
- 자바의 날짜 타입은 @Temporal을 사용해서 매핑한다.
- 길이 제한이 없는 필드는 데이터베이스의 VARCHAR 타입이 아닌 CLOB 타입으로 저장해야 하기에 @Lob을 사용해서 매핑한다.

------------------

## 데이터베이스 스키마 자동 생성

- JPA는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원한다.
- 클래스의 매핑정보와 데이터베이스 방언을 사용해서 데이터베이스 스키마를 생성한다.
- 스키마 자동 생성 기능이 만든 DDL은 운영 환경에서 사용할 만큼 완벽하지는 않으므로 개발 환경에서 사용하거나
매핑을 어떻게 해야 하는지 참고하는 정도로만 사용하는 것이 좋다.

---------------------

## DDL 생성 기능

- @Column 매핑정보의 nullable 속성 값을 false 로 지정하면 DDL에 not null 제약조건을 추가할 수 있다.
- length 속성 값을 사용하면 문자의 크기를 지정할 수 있다.
- @Table의 uniqueConstraints 속성을 하면 유니크 제약조건이 추가된다.
- 이러한 기능들은 단지 DDL을 자동으로 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.
- 직접 DDL을 만든다면 사용할 이유가 없지만, 개발자가 엔티티만 보고도 쉽게 다양한 제약조건을 파악할 수 있는 장점이 있다.

-------------------

## 기본 키 매핑

- JPA가 제공하는 데이터베이스 기본 키 생성 전략은 다음과 같다.
- 직접 할당: 기본 키를 어플리케이션에서 직접 할당한다.
- 자동 생성: 대리 키 사용 방식
  - IDENTITY: 기본 키 생성을 데이터베이스에 위임한다.
  - SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.
  - TABLE: 키 생성 테이블을 사용한다.
- 자동 생성 전략을 사용하려면 @Id에 @GeneratedValue를 추가하고 원하는 키 생성 전략을 선택하면 된다.

### 기본 키 직접 할당 전략

- @Id 적용 가능 자바 타입
  - 자바 기본형
  - 자바 래퍼(Wrapper)형
  - String
  - java.util.Date
  - java.sql.Date
  - java.math.BigDecimal
  - java.math.BigInteger

### IDENTITY 전략

- 기본 키 생성을 데이터베이스에 위임하는 전략.
- 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용된다.
- @GeneratedValue의 strategy 속성 값을 GenerationType.IDENTITY 로 지정하면 된다.
- 엔티티가 영속 상태가 되려면 식별자가 반드시 필요한데 IDENTITY 식별자 생성 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로
em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다. 따라서 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.

### SEQUENCE 전략

- 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트다.
- 주로 오라클, PostgreSQL, DB2, H@ 데이터베이스에서 사용한다.
- @SequenceGenerator를 사용해서 시퀀스 생성기를 등록하고, @GeneratedValue의 generator 속성으로 시퀀스 생성기 이름을 등록한다.
- SEQUENCE 전략은 em.persist()를 호출할 때 데이터베이스 시퀀스를 사용해서 식별자를 조회한다.
- 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장 후 플러시가 일어나면 데이터베이스에 반영한다.
- IDENTITY 전략은 먼저 엔티티를 데이터베이스에 저장한 후에 식별자를 조회해서 엔티티의 식별자에 할당한다.

### TABLE 전략

- 키 생성 전용 테이블을 하나 만들고, 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스를 흉내내는 전략이다.
- 모든 데이터베이스에 적용할 수 있다.
- 시퀀스 대신에 테이블을 사용한다는 것만 제외하면 SEQUENCE 전략과 내부 동작방식이 같다.

### AUTO 전략

- 선택한 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택한다.
- 예를 들어 오라클을 선택하면 SEQUENCE, MySQL을 선택하면 IDENTITY를 사용한다.
- 키 생성 전략이 아직 확정되지 않은 개발 초기 단계나 프로토타입 개발 시 편리하게 사용할 수 있다.

### 권장하는 식별자 선택 전략

- 데이터베이스 기본 키는 다음 3가지 조건을 모두 만족해야 한다.
  - null값은 허용하지 않는다.
  - 유일해야 한다.
  - 변해선 안 된다.
- 테이블의 기본 키를 선택하는 전략은 크게 2가지가 있다.
  - 자연 키(natural key)
    - 비즈니스에 의미가 있는 키
    - 예: 주민등록번호, 이메일, 전화번호 ...
  - 대리 키(surrogate key)
    - 비즈니스와 관련 없는 임의로 만들어진 키.
- 자연 키보다는 대리 키를 권장한다.

-------------------

## 필드와 컬럼 매핑: 레퍼런스

### @Column

- @Column은 객체 필드를 테이블 컬럼에 매핑한다.
- 속성 중 name, nullable이 주로 사용되고 나머지는 잘 사용되지 않는 편이다.
- 속성
  - name: 필드와 매핑할 테이블의 컬럼 이름(기본값 : 객체의 필드 이름)
  - insertable: 엔티티 저장 시 이 필드도 같이 저장한다. (기본값 : true)
  - updatable: 엔티티 수정 시 이 필드도 같이 수정한다. (기본값 : true)
  - table: 하나의 엔티티를 두 개 이상의 테이블에 매핑할 때 사용한다. (기본값 : 현재 클래스가 매핑된 테이블)
  - nullable(DDL): null 값의 허용 여부를 설정한다. (기본값 : true)
  - unique(DDL): 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용한다.
  - length(DDL): 문자 길이 제약조건, String 타입에만 사용한다. (기본값 : 255)
  - precision, scale(DDL): BigDecimal 타입에서 사용한다. percision은 소수점을 포함한 전체 자리수, scale은 소수의 자리수.
- 자바 기본 타입에 @Column을 사용하지 않으면 자동으로 not null이 된다.
- 자바 기본 타입에 @Column을 사용하면 null이 허용되기에 @Column을 사용할 경우 nullable=false 로 지정하는 것이 안전하다.

### @Enumerated

- 자바의 enum 타입을 매핑할 때 사용한다.
- 속성
  - value(기본값 : EnumType.ORDINAL)
    - EnumType.ORDINAL: enum의 순서를 데이터베이스에 저장.
    - EnumType.STRING: enum 이름을 데이터베이스에 저장.
- enum의 순서를 저장하는 ORDINAL은 enum 클래스가 변경될 경우 데이터베이스에 이전에 저장된 데이터들의 변경이 없기 때문에 위험.
- STRING 사용을 권장한다.

### @Temporal

- 날짜 타입을 매핑할 때 사용한다.
- 속성
  - value(TemporalType은 필수로 지정해야 한다)
    - TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑.
    - TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑.
    - TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑.
- @Temporal을 생략하면 자바의 Date와 가장 유사한 timestamp로 정의.

### @Lob

- 데이터베이스 BLOB, CLOB 타입과 매핑한다.
- 필드 타입이 문자면 CLOB으로 매핑, 나머지는 BLOB으로 매핑.

### @Transient

- 이 필드는 매핑하지 않는다.
- 데이터베이스에 저장하지 않고 조회하지도 않는다. 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.

### @Access

- JPA가 엔티티데이터에 접근하는 방식을 지정한다.
- AccessType.FIELD: 필드 접근. 필드 접근 권한이 private이어도 접근할 수 있다.
- AccessType.PROPERTY: 프로퍼티 접근. 접근자(Getter)를 사용한다.
- 설정하지 않을 경우 @Id의 위치에 따라 달라진다.
- 필드에 @Id가 있을 경우 필드 접근.
- @Id가 getId() 와 같이 접귽바에 있을 경우 프로퍼티 접근 방식이 적용된다.