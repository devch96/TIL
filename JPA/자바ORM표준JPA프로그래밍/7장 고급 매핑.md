# 7장 고급 매핑

---------------

## 상속 관계 매핑

- 관계형 데이터베이스에는 객체지향 언어에서 다루는 상속이라는 개념 대신 슈퍼타입 서브타입 관계라는 모델링 기법이 객체의 상속 개념과
유사하다.
- ORM에서 이야기하는 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것이다.
- 슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 때는 3가지 방법을 선택할 수 있다.
  - 각각의 테이블로 변환: 각각을 모두 테이블로 만들고 조회할 때 조인을 사용한다. JPA에서는 조인 전략이라 한다.
  - 통합 테이블로 변환: 테이블을 하나만 사용해서 통합한다. JPA에서는 단일 테이블 전략이라 한다.
  - 서브타입 테이블로 변환: 서브 타입마다 하나의 테이블을 만든다. JPA에서는 구현 클래스마다 테이블 전략이라 한다.

### 조인 전략(Joined Strategy)

- 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략.
- 조회할 때 조인을 자주 사용.
- 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없기 때문에 타입을 구분하는 컬럼을 추가해야 한다.
- @Inheritance(strategy = InheritanceType.JOINED): 상속 매핑은 부모 클래스에 @Inheritance를 사용해야 한다.
- @DiscriminatorColumn(name = ""): 부모 클래스에 구분 컬럼을 지정한다. 기본값이 DTYPE이다.
- @DiscriminatorValue(""): 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정한다.
- 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하는데, 
만약 자식 테이블의 기본 키 컬럼명을 변경하고 싶으면 @PrimaryKeyJoinColumn을 사용하면 된다.

- 장점
  - 테이블이 정규화 된다.
  - 외래 키 참조 무결성 제약조건을 활용할 수 있다.
  - 저장공간을 효율적으로 사용한다.
- 단점
  - 조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있다.
  - 조회 쿼리가 복잡하다.
  - 데이터를 등록할 INSERT SQL을 두 번 실행한다.
- 특징
  - JPA 표준 명세는 구분 컬럼을 사용하도록 하지만 하이버네이트를 포함한 몇몇 구현체는 구분 컬럼(@DiscriminatorColumn) 없이도 동작한다.
- 관련 어노테이션
  - @DiscriminatorColumn
  - @DiscriminatorValue
  - @PrimaryKeyJoinColumn

### 단일 테이블 전략(Single-Table Strategy)

- 테이블을 하나만 사용하고, 구분 컬럼(DTYPE)으로 어떤 자식 데이터가 저장되었는지 구분.
- 조회할 때 조인을 사용하지 않으므로 일반적으로 가장 빠르다.
- 주의점은 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다는 점이다.
- @Inheritance(strategy = InheritanceType.SINGLE_TABLE)

- 장점
  - 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.
  - 조회 쿼리가 단순하다.
- 단점
  - 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다.
  - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 그러므로 상황에 따라서는 조회 성능이 오히려 느려질 수 있다.
- 특징
  - 구분 컬럼을 꼭 사용해야 한다. 따라서 @DiscriminatorColumn을 꼭 설정해야 한다.
  - @DiscriminatorValue를 지정하지 않으면 기본으로 엔티티 이름을 사용한다.

### 구현 클래스마다 테이블 전략(Table-per-Concrete-Class Strategy)

- 자식 엔티티마다 테이블을 만든다. 자식 테이블에 각각에 필요한 컬럼이 모두 있다.
- 일반적으로 추천하지 않는 전략.
- @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)

- 장점
  - 서브 타입을 구분해서 처리할 때 효과적이다.
  - not null 제약조건을 사용할 수 있다.
- 단점
  - 여러 자식 테이블을 함께 조회할 때 성능이 느리다.
  - 자식 테이블을 통합해서 쿼리하기 어렵다.
- 특징
  - 구분 컬럼을 사용하지 않는다.

---------------------------

## @MappedSuperclass

- 부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶으면
@MappedSuperclass를 사용하면 된다.
- 부모로부터 물려받은 매핑 정보를 재정의 하려면 @AttributeOverrides 나 @AttributeOverride,
연관관계를 재정의하려면 @AssociationOverrides 나 @AssociationOverride를 사용한다.

- 특징
  - 테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑 정보를 상속하기 위해 사용한다.
  - @MappedSuperclass로 지정한 클래스는 엔티티가 아니므로 em.find()나 JPQL에서 사용할 수 없다.
  - 이 클래스를 직접 생성해서 사용할 일은 거의 없으므로 추상 클래스로 만드는 것을 권장한다.

------------------------------

## 복합 키와 식별 관계 매핑

### 식별 관계 vs 비식별 관계

- 외래 키가 기본 키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분한다.

#### 식별 관계

- 식별 관계는 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계.

#### 비식별 관계

- 비식별 관계는 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계.
- 외래 키에 null을 허용하는지에 따라 필수적 비식별 관계와 선택적 비식별 관계로 나눈다.
  - 필수적 비식별 관계(Mandatory): 외래 키에 null을 허용하지 않는다. 연관관계를 필수적으로 맺어야 한다.
  - 선택적 비식별 관계(Optional): 외래 키에 null을 허용한다. 연관관계를 맺을지 말지 선택할 수 있다.

### 복합 키: 비식별 관계 매핑

- 복합 키를 사용하려면 별도의 식별자 클래스를 만들어야 한다.
- @IdClass와 @EmbeddedId 2가지 방법을 제공한다.
- @IdClass
  - 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다.
  - Serialiable 인터페이스를 구현해야 한다.
  - equals, hashCode를 구현해야 한다.
  - 기본 생성자가 있어야 한다.
  - 식별자 클래스는 public 이어야 한다.
- @EmbeddedId
  - 부모 엔티티에서 식별자 클래스를 직접 사용하고 @EmbeddedId 어노테이션을 적어준다.
  - Serializable 인터페이스를 구현해야 한다.
  - equals, hashCode를 구현해야 한다.
  - 기본 생성자가 있어야 한다.
  - 식별자 클래스는 public이어야 한다.
- @IdClass vs @EmbeddedId
  - @EmbeddedId가 @IdClass 보다 더 객체지향적이고 중복도 없어서 좋아보이긴 하지만 특정 상황에서 JPQL이 족므 더 길어질 수 있다.


### 복합 키: 식별 관계 매핑

- 식별 관계에서 자식 테이블은 부모 테이블의 기본 키를 포함해서 복합 키를 구성해야 하므로
@IdClass 나 @EmbeddedId를 사용해서 식별자를 매핑해야 한다.
- @IdClass
  - 부모 필드를 @Id로 기본 키로 매핑하면서 @ManyToOne과 @JoinColumn으로 외래 키를 같이 매핑한다.
- @EmbeddedId
  - @MapsId로 매핑한다.

### 일대일 식별 관계

- 일대일 식별 관계는 자식 테이블의 기본 키 값으로 부모 테이블의 기본 키 값만 사용한다.
- 부모 테이블의 기본 키가 복합 키가 아니면 자식 테이블의 기본 키는 복합 키로 구성하지 않아도 된다.
- @MapsId를 사용한다.

### 식별, 비식별 관계의 장단점

- 식별 관계 보다는 비식별 관계를 선호.
- 식별 관계는 부모 테이블의 기본 키를 자식 테이블로 전파하면서 자식 테이블의 기본 키 컬럼이 점점 늘어남.
- 조인할 때 SQL이 복잡해지고 기본 키 인덱스가 불필요하게 커질 수 있다.
- 식별 관계는 2개 이상의 컬럼을 합해서 복합 기본 키를 만들어야 하는 경우가 많음.
- 식별 관계는 기본 키로 비즈니스 의미가 있는 자연 키 컬럼을 조합하는 경우가 많음.
- 비식별 관계는 기본 키로 비즈니스와 전혀 관계 없는 대리 키를 주로 사용.
- 식별 관계는 상위 테이블들의 기본 키 컬럼을 서브 테이블들이 가지고 있으므로 특정 상황에 조인 없이 하위 테이블만으로 검색을 완료할 수 있음.
- 선택적 비식별 관계보다는 필수적 비식별 관계를 사용하는 것이 좋음.(null 허용이라 외부 조인을 사용해야 하는데 not null 이기 때문에 내부 조인만 사용해도 됨.)

---------------------------

## 조인 테이블

- 데이터베이스 테이블의 연관관계를 설정하는 방법은 조인 컬럼 사용(외래 키), 조인 테이블 사용(테이블 사용) 2가지.
- 조인 컬럼 사용
  - 테이블 간의 관계는 주로 조인 컬럼이라 부르는 외래 키 컬럼을 사용해서 관리.
  - 관계를 맺기 전에는 외래 키에 null을 허용해야 하는데 이러한 관계를 선택적 비식별 관계라 함.
  - 선택적 비식별 관계는 외래 키에 null을 허용하므로 외부 조인을 해야함.
- 조인 테이블 사용
  - 별도의 테이블을 사용해서 연관관계를 관리.
  - 연관관계를 관리하는 외래키들로만 이루어져있는 테이블로 관계를 실질적으로 맺고 있는 테이블에는 외래 키 컬럼이 없음.
  - 테이블을 하나 추가해야 하기에 관리해야 하는 테이블이 늘어나고 조인하기 위해서 추가로 조인해야 한다는 단점이 있음.
- 조인 테이블에 컬럼을 추가하면 @JoinTable 전략을 사용할 수 없다. 대신에 새로운 엔티티를 만들어서 조인 테이블과 매핑해야 한다.


### 일대일 조인 테이블

- 부모 엔티티에 @JoinColumn 대신 @JoinTable 사용.
- 조인 테이블의 외래 키 컬럼 각각에 총 2개의 유니크 제약조건을 걸어야 한다.
- 속성
  - name: 매핑할 조인 테이블 이름
  - joinColumns: 현재 엔티티를 참조하는 외래 키
  - inverseJoinColumns: 반대방향 엔티티를 참조하는 외래 키

### 일대다 조인 테이블

- 조인 테이블 중 다(N) 과 관련된 컬럼에 유니크 제약조건을 걸어야 한다.

### 다대다 조인 테이블

- 조인 테이블의 두 컬럼을 합해서 하나의 복합 유니크 제약조건을 걸어야 한다.

--------------------

## 엔티티 하나에 여러 테이블 매핑

- @Table을 사용해 매핑.
- @SecondaryTable을 사용해 다른 테이블과 매핑.
- 속성
  - @SecondaryTable.name: 매핑할 다른 테이블 이름.
  - @SecondaryTable.pkJoinColumns: 매핑할 다른 테이블의 기본 키 컬럼 속성
- 다른 테이블에 매칭하고 싶은 필드는 @Column(table = "")를 사용하면 됨.
- @SecondaryTable을 사용해서 두 테이블을 하나의 엔티티에 매핑하는 방법보다 테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것을 권장.
- 항상 두 테이블을 조회하므로 최적화가 어려움.
