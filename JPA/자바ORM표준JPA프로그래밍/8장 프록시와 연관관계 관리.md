# 8장 프록시와 연관관계 관리

----------------

## 프록시

- 엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아님.
- 그러므로 연관된 엔티티들이 항상 조회되는 것은 비효율적.
- JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공.(지연 로딩: Lazy Loading)
- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데
이것을 프록시 객체라 한다.

### 프록시 기초

- JPA는 식별자를 통해 엔티티 하나를 조회할 때 em.find()를 사용한다.
- find() 메소드는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회한다.
- 하지만 em.getReference() 메소드를 사용하면 데이터베이스를 조회하지 않고 실체 엔티티 객체도 생성하지 않는다.
- 대신에 데이터베이스 접근을 위임한 프록시 객체를 반환한다.

#### 프록시의 특징

- 프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같다.
- 프록시 객체는 실제 객체에 대한 참조(target)를 보관한다.
- 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
- 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
- 프록시 객체를 초기화 한다고 실제 엔티티로 변하는 것이 아닌 실제 엔티티에 접근할 수 있는 것이다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 하기에 준영속 상태의 프록시를 초기화하면 에러가 발생한다.

#### 프록시 객체의 초기화

- 프록시 객체는 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라 한다.

### 프록시와 식별자

- 프록시로 엔티티를 조회할 때 식별자(PK) 값을 파라미터로 전달하는데 프록시 객체는 이 값을 보관한다.
- 프록시 객체는 식별자 값을 가지고 있으므로 getId()를 호출하면 프록시 객체는 초기화하지 않는다.
- 단 엔티티 접근 방식이 프로퍼티(@Access(AccessType.PROPERTY))일 경우만 초기화 하지 않는다.
- 엔티티 접근 방식이 필드(@Access(AccessType.FIELD))이면 getId가 id만 조회하는 것인지 다른 필드까지 활용하는 것인지 알지 못하므로 초기화한다.
- 프록시는 연관관계를 설정할 때 유용하게 사용할 수 있다.
```java
Member member = em.find(Member.class, "member1");
Team team = em.getReference(Team.class, "team1"); //SQL 실행하지 않음.
member.setTeam(team);
```
- 연관관계를 설정할 때는 엔티티 접근 방식이 필드여도 프록시를 초기화하지 않는다.

### 프록시 확인

- JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 알 수 있다.
- 클래스명을 직접 출력하면 클래스 명 뒤에 ..javassist.. 라고 되어있으면 프록시, 아니면 진짜 엔티티이다.

--------------------------

## 즉시 로딩과 지연 로딩

- 프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용한다.

### 즉시 로딩(EAGER LOADING)

- 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
- @ManyToOne(fetch = FetchType.EAGER)
- 대부분의 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.
- @JoinColumn(nullable = false) 로 설정할 경우 내부 조인을 사용해서 최적화할 수 있다.
- @ManyToOne(optional = false) 로 설정해도 내부 조인을 사용한다.



### 지연 로딩(LAZY LOADING)

- 연관된 엔티티를 실제 사용할 때 조회한다.
- @ManyToOne(fetch = FetchType.LAZY)
- 연관된 엔티티에 프록시 객체를 넣어 반환.
- 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룸.

### 즉시 로딩, 지연 로딩 정리

- 어플리케이션 로직에서 연관된 엔티티를 같이 사용한다면 즉시 로딩이 효율적, 반대면 지연 로딩이 효율적. 상황에 따라 다름.
- 지연 로딩: 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
- 즉시 로딩: 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.

---------------------

## 지연 로딩 활용

### 프록시와 컬렉션 래퍼

- 하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을
하이버네이트가 제공하는 내장 컬렉션으로 변경하는데 이것을 컬렉션 래퍼라 한다.
- 엔티티를 지연 로딩하면 프록시 객체를 사용하지만 컬렉션은 컬렉션 래퍼가 지연 로딩을 처리해준다.
- 컬렉션 래퍼는 컬렉션에서 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화한다.

### JPA 기본 페치 전략

- @ManyToOne, @OneToOne: 즉시 로딩
- @OneToMany, @ManyToMany: 지연 로딩
- 모든 연관관계에 지연 로딩을 사용하고, 어플리케이션의 개발이 어느 정도 완료단계에 왔을 때 실제 사용하는 상황을 보고
즉시 로딩을 사용하도록 최적화하면 된다.

### 컬렉션에 FetchType.EAGER 사용 시 주의점

- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다.
- 너무 많은 데이터를 반환할 수 있고, 결과적으로 어플리케이션 성능이 저하될 수 있다.
- JPA는 일대다 관계를 즉시 로딩할 떄 항상 외부 조인을 사용한다.

----------------------------

## 영속성 전이: CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이(transitive persistence)기능을 사용하면 된다.
- 영속성 전이를 사용하면 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다.
- JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.

### 영속성 전이: 저장

- @OneToMany(cascade = CascadeType.PERSIST)
- 영속성 전이는 연관관계를 매핑하는 것과 관련 없이 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공할 뿐이다.

### 영속성 전이: 삭제

- CascadeType.REMOVE

### CASCADE의 종류

- ALL: 모두 적용
- PERSIST: 영속
- MERGE: 병합
- REMOVE: 삭제
- REFRESH
- DETACH
- cascade = {CadcadeType.PERSIST, CascadeType.REMOVE} 와 같이 여러 속성을 같이 사용할 수 있다.
- PERSIST와 REMOVE는 플러시를 호출할 때 전이가 발생한다.

------------------------

## 고아 객체

- JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공.
- 고아 객체(ORPHAN) 제거.
- 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제.
- @OneToMany(orphanRemoval = true)
- 부모 엔티티가 여럿일 경우 하나의 부모에서만 참조를 제거 한다고 고아 객체가 되지 않는다.
- 따라서 orphanRemoval은 @OneToOne, @OneToMany에만 사용할 수 있다.

------------------------

## 영속성 전이 + 고아 객체, 생명주기

- 일반적으로 엔티티는 em.persist()와 em.remove()를 통해 생명주기를 스스로 관리한다.
- CascadeType.ALL 과 orphanRemoval = true 를 동시에 사용하면 부모 엔티티를 통해 자식의 생명주기를 관리할 수 있다.
- 자식을 저장하려면 부모에 등록(cascade)
- 자식을 삭제하려면 부모에서 제거(orphanRemoval)

-----------------------

## 정리

- JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 지원하는데 이때 프록시 기술을 사용한다.
- 객체를 조회할 때 연관된 객체를 같이 로딩하는 방법을 즉시 로딩이라 한다.
- 객체를 조회할 때 연관된 객체가 사용될 때 연관된 객체를 조회하는 것을 지연 로딩이라 한다.
- 객체를 저장하거나 삭제할 때 연관된 객체도 함께 저장하거나 삭제할 수 있는데 이것을 영속성 전이라 한다.
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 제거 기능을 사용하면 된다.

