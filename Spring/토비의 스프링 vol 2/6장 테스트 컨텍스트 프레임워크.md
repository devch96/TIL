# 테스트 컨텍스트 프레임워크

- 스프링의 POJO와 DI를 이용한 프로그래밍 모델이 가져온 가장 큰 혜택 중 하나는 테스트
  - POJO 프로그래밍 모델은 단위 테스트를 손쉽게 작성할 수 있는 환경 제공
  - IoC와 DI로 인해, 서버에 배치하지 않고도 스프링 컨테이너만으로 DB까지 참여하는 통합 테스트가 가능

-----

## 테스트 컨텍스트 프레임워크

- 스프링은 테스트에 사용되는 애플리케이션 컨텍스트를 생성하고 관리하고 테스트에 적용해주는 기능을 가진 테스트 프레임워크를 제공함
  - 테스트 컨텍스트 프레임워크라고 함
  - 서버와 거의 동일한 구성으로 동작하는 통합 테스트를 손쉽게 만들 수 있음

### 테스트 프레임워크와 컨텍스트 테스트

- 자바에서 많이 사용되는 테스트 프레임워크는 JUnit
- 스프링 컨텍스트 테스트는 이것을 지원함

#### 테스트용 애플리케이션 컨텍스트 캐싱과 설정파일

- JUnit은 테스트 메서드를 실행할 때마다 매번 테스트 클래스의 새로운 오브젝트를 만듬
  - 모든 테스트는 서로 영향을 주지 않으며 독립적으로 실행됨
- 테스트가 독립적이라고해서 매번 스프링 컨텍스트(컨테이너)를 새로 만드는 건 비효율적
- 그래서 스프링은 테스트가 사용하는 컨텍스트를 캐싱해서 여러 테스트에서 하나의 컨텍스트를 공유할 수 있는 방법을 제공함
  - 동일한 컨텍스트 구성을 갖는 테스트끼리는 같은 컨텍스트를 공유함
- 테스트용 컨텍스트의 공유는 테스트 클래스 사이에서도 가능함
- @ContextConfiguration을 통해 지정한 설정파일이 동일하다면 테스트용 컨텍스트를 공유함
  - @ContextConfiguration에 설정 파일 이름을 생략하면 현재 클래스 이름에 -context.xml이 붙은 파일이 디폴트 설정파일 이름으로 사용됨
    - 일반적으로 좋은 방법이 아님

#### 컨텍스트 설정의 상속과 컨텍스트 로더

- 컨텍스트 파일 정보는 상속됨
  - 서브클래스의 컨텍스트 파일 정보는 슈퍼클래스에서 정의된 것까지 포함함
- 슈퍼클래스의 컨텍스트 파일 설정을 무시하고 새롭게 정의하고 싶다면 @ContextConfiguration의 inheritLocations를 false로 바꾸면 됨

------------

## 트랜잭션 지원 테스트

### 테스트의 트랜잭션 지원 필요성

- DB가 사용되는 테스트에서는 단순히 컨텍스트에 구성된 빈의 메서드를 호출하는 것으로는 충분하지 않음
  - 트랜잭션을 조작하거나 지원하는 기능이 필요한 경우가 있기 때문

#### DAO 단독 테스트

- 스프링의 데이터 액세스 기술로 만든 DAO는 기본적으로 트랜잭션 동기화를 필요로 함
  - 트랜잭션을 시작해주는 AOP가 있는 서비스 계층을 통해 접근하지 않으면 DAO가 실행이 안되는 문제가 발생함
  - JDBC는 괜찮음
  - JPA나 하이버네이트 등으로 만든 DAO는 트랜잭션이 시작되지 않은 채로 엔티티 매니저나 세션을 사용하면 예외가 발생함

#### 롤백 테스트

- DB가 참여하는 테스트의 가장 큰 어려움은 테스트용 DB를 어떻게 구축하고 관리하는가에 있음
- 테스트에서 단지 조회만 한다면 초기 데이터만 구비하면 되겠지만 내용을 수정하는 경우에는 문제가 복잡해짐
  - 테스트마다 DB를 초기화하는건 매우 부담스러움
- 테스트에서 진행되는 모든 DB 작업을 하나의 트랜잭션으로 묶어서 진행하고, 테스트를 마칠 때 트랜잭션을 모두 롤백시킴
  - 롤백 테스트

### 트랜잭션 지원 테스트 작성 방법

#### 트랜잭션 매니저

- 트랜잭션 매니저를 이용해 스프링 트랜잭션이 만들어지므로 트랜잭션 매니저를 이용하면 제어도 할수있음
- 트랜잭션 매니저를 테스트 클래스에서 DI 받음
  - PlatformTransactionManager transactionManager;
- 트랜잭션 매니저를 이용해 트랜잭션 템플릿을 만들고, execute() 메서드를 실행해 같은 트랜잭션 안에서 동작해야 하는 코드를 콜백에 담아 전달함

```java
@Test
void txTest() {
    new TransactionTemplate(transactionManager).execute(
            new TransactionCallback<Object>() {
                public Object doInTransaction(TransactionStatus status) {
                    status.setRollbackOnly();
                    dao.deleteAll();
                    dao.add(new Member(10,"123"));
                    assertThat(dao.count(), is(1));
                    return null;
                }
            }
    )
}
```

#### @Transactional 테스트

- 트랜젝션 매니저를 DI 받아서 트랜잭션 템플릿과 함께 사용하는 방법은 테스트의 요구조건을 만족하긴 하지만 테스트 코드가 지저분해진다는 단점이 있음
- 테스트 오브젝트에 AOP를 적용하는 것은 불가능하지만 스프링의 테스트 컨텍스트 프레임워크는 마치 AOP를 적용한 것과 유사한 방식으로 트랜잭션 기능을 테스트 메서드에 적용할 수 있게 해줌
  - @Transactional 애노테이션
- 강제롤백 옵션이 설정된 트랜잭션임

#### ORM 롤백 트랜잭션 테스트의 주의사항

- ORM은 기본적으로 모든 작업 결과를 바로 DB에 반영하지 않음
  - 가능한 오랫동안 메모리에 변경사항을 저장하고 있다가 꼭 필요한 시점에서 DB에 반영
- 기본적으로 ORM은 자동플러시 모드로 동작
  - 자동플러시 모드에서는 트랜잭션이 커밋되거나, 캐시에 저장해둔 정보가 반영되는 SELECT 쿼리를 실행해야 하거나, 코드에서 flush() 메서드를 실행해서 강제로
  플러시하도록 만들 때만 트랜잭션 내의 캐시에 저장해뒀던 ORM 작업 결과를 SQL로 만들어서 DB에서 실행시킴
- ORM에서는 테스트에서 의도적으로라도 한 번은 flush()를 실행하는 것이 좋음
- 