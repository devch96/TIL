# AOP와 LTW

------------

## 애스펙트 AOP

### 프록시 기반 AOP

#### 프록시 기반 AOP 개발 스타일의 종류와 특징

- AOP는 모듈화된 부가기능(어드바이스)과 적용 대상(포인트컷)의 조합을 통해 여러 오브젝트에 산재해서 나타나는 공통적인 기능을
손쉽게 개발하고 관리할 수 있는 기술

#### 자동 프록시 생성기와 프록시 빈

- 스프링 AOP를 사용한다면 어떤 개발 방식을 적용하든 모두 프록시 방식의 AOP
- Client와 Target이라는 두 개의 클래스가 있고, Client는 Target을 DI 받아 사용하는 관계라고 가정했을 때 프록시를 이용해서
Client와 Target의 코드에는 전혀 영향을 주지 않은 채로 Client가 Target을 이용하는 과정에서 부가기능을 제공하도록 만들려면 Client가 Target을
직접 알고 있으면 안됨

```java
public class Client {
    @Autowired
    Target target;
}
```

- DI를 적용하는 데 기술적인 문제는 없으나 Client가 이미 자신이 사용할 오브젝트의 클래스를 알고 있기 때문에 DI를 위반한다
  - DI의 원리와 목적이 무시됨
  - Client가 사용할 오브젝트를 DI 컨테이너와 설정을 통해 바꿀 수 없기 때문
  - DI 원리에 의존하고 있는 데코레이터 패턴이 적용된 프록시 방식이 적용되지 못함
- Client가 Target이라는 구체 클래스를 직접 의존하는 대신 Target이 구현하고 있는 인터페이스를 이용해 의존하도록 만들어야 함

```java
public class Client {
    @Autowired
    Interface intf;
}

public class Target implements Interface{
    ...
}

public class Proxy implements Interface {
    private Interface next;
    public void setNext(Interface next) {
        this.next = next;
    }
}
```

- DI 설정을 조작해서 Client -> Proxy -> Target 순서로 의존관계를 맺게 하면 Proxy가 Client와 Target의 호출 과정에 끼어들어서 부가기능을 제공할 수 있게 됨
- Proxy를 빈으로 등록하면 @Autowired를 통한 타입 자동와이어링을 사용할 수 없음
  - Interface를 구현한 두 개의 빈이 만들어지기 때문에 자동 빈 선택이 불가능해짐
- 위와 같이 수동으로 프록시를 빈으로 직접 등록한다면 빈 이름을 지정하거나 @Qualifier를 사용해 빈 선정조건을 더 부여해주어야 함
- 스프링은 자동 프록시 생성기를 이용해 컨테이너 초기화 중 만들어진 빈을 바꿔치기해 프록시 빈을 자동으로 등록해줌
- 자동 프록시 생성기는 프록시 빈을 별도로 추가하고 DI 설정만 바꿔주는 것이 아닌 프록시를 적용할 대상 자체를 아예 자신이 포장해서 마치 그 빈처럼 동작하게함
- 자동 프록시 생성기가 만들어주는 프록시는 새로운 빈으로 추가되는 것이 아닌 AOP 대상 타깃 빈을 대체함

#### 프록시의 종류

- 스프링에서는 클래스를 직접 참조하면서 강한 의존관계를 맺는 경우에도 프록시를 적용할 수 있음
- 타깃 클래스 자체를 인터페이스처럼 사용함
- 클라이언트가 타깃 클래스에 의존하는 것은 변하지 않으나, 타깃 클래스를 상속한 서브클래스를 만들어 이를 프록시로 사용함
  - 서브클래스도 자신이 상속한 클래스와 같은 타입이니 클라이언트에 DI가 가능하다는 원리를 이용
  - 인터페이스를 이용하는 방법에 비해 부자연스러움
- 두 가지 제약이 있음
  - final 클래스와 final 메서드에는 적용이 안됨
    - final 클래스는 상속이 안되고 final 메서드는 오버라이딩이 안되기 때문
  - 타깃 클래스의 생성자가 두 번 호출됨
- 스프링은 인터페이스를 통한 객체지향적인 합성 기법과 이에 바탕을 둔 DI를 사용하도록 권장하나 클래스 방식의 프록시를 지원해주는 이유는
이넡페이스를 만들지 않고 개발한 레거시 코드나 외부에서 개발한 인터페이스 없는 라이브러리의 클래스 등에도 원한다면 AOP를 적용할 수 있게 해주려는 것 뿐

### @AspectJ AOP

- 에스펙트는 객체지향 언어의 클래스와 비슷한 개념이라고 생각
  - 에스펙트는 그 자체로 애플리케이션의 도메인 로직을 담은 핵심 기능은 아니지만, 많은 오브젝트에 걸쳐서 필요한 부가기능을 추상화해놓은 것
- 애스펙트는 하나 이상의 포인트컷과 어드바이스로 구성됨
  - 스프링의 어드바이저는 하나의 포인트컷과 하나의 어드바이스로 정의된 가장 단순한 형태의 애스펙트
- @AspectJ는 애스펙트를 자바 클래스와 메서드, 애노테이션을 이용해 정의하는 방법을 가리키는 말

#### @Aspect 클래스와 구성요소

- 애스펙트는 자바 클래스에 @Aspect라는 애노테이션을 붙여서 만듬
  - 인터페이스 구현이나 클래스 상속을 강제하는 것이 없기 때문에 얼마든지 자유롭게 클래스를 정의할 수 있음
- @Aspect 클래스는 @Configuration 과 마찬가지로 자바 코드로 만든 메타정보로 활용됨
  - 어드바이스를 담당하는 메서드는 실행 가능하기 때문에 오브젝트를 만들어 단위 테스트 등에 활용할 수 있음
- 포인트컷: @Pointcut
  - @Pointcut 안에 포인트컷 표현식을 넣어서 정의함
  - 메서드의 내부에 코드를 작성할 필요는 없음
    - 메서드의 선언부를 메타정보로 이용해서 포인트컷의 이름과 파라미터를 정의하는 용도로만 사용
  - 여러 개의 포인트컷을 선언할 수 있음
- 어드바이스: @Before, @AfterRunning, @AfterThrowing, @After, @Around
  - 애노테이션이 붙은 메서드를 이용해 정의
  - 어드바이스 로직은 메서드 내의 자바 코드로 작성
  - 어드바이스의 애노테이션에는 이에 적용할 포인트컷을 명시해야 함
  - 포인트컷에 이름을 부여해서 따로 정의하는 대신 어드바이스 메서드 애너테이션에 포인트컷 표현식을 넣어서 적용하는 방ㄴ법도 있음
    - 이름이 없으니 다른 어드바이스에서 참조될 수 없음

#### 어드바이스 메서드와 애노테이션

- 클라이언트의 호출은 프록시 메서드를 거쳐서 타깃 메서드가 호출되고 타깃 메서드가 끝나면 다시 프록시 메서드로 돌아왔다가 최종적으로 클라이언트로 돌아감
- 어드바이스가 프록시의 메서드 전체를 구현하게 할 수도 있지만 일부분에만 참여하도록 만들 수 있음
- @Around
  - 프록시를 통해서 타깃 오브젝트의 메서드가 호출되는 전 과정을 모두 담을 수 있는 어드바이스
  - 가장 강력한 기능을 가진 어드바이스
- @Before
  - 타깃 오브젝트의 메서드가 실행되기 전에 사용되는 어드바이스
  - 타깃 오브젝트 메서드를 호출하는 방식을 제어할 수 없음
  - 리턴 값에 별 관심이 없을 때 사용
  - JoinPoint 타입의 파라미터를 사용할 수 있음
    - ProceedingJoinPoint의 슈퍼 인터페이스로 조인 포인트의 메서드 실행 지점에 대한 정보를 가져올 수는 있지만
    타깃 오브젝트의 메서드를 실행하는 proceed() 메서드는 없음
- @AfterReturning
  - 타깃 오브젝트의 메서드가 실행을 마친 뒤에 실행되는 어드바이스
  - 리턴 값 자체를 바꿀 수는 없지만 리턴 값이 레퍼런스 타입이라면 참조하는 오브젝트를 조작할 수 있음
  - 리턴 값을 참조할 때는 애노테이션의 returning 엘리먼트를 이용해 리턴 값을 담을 파라미터 이름을 지정해야 함
- @AfterThrowing
  - 타깃 오브젝트의 메서드를 호출했을 때 예외가 발생하면 실행되는 어드바이스
  - throwing 엘리먼트를 이용해 예외를 전달받을 메서드 파라미터 이름을 지정할 수 있음
    - 지정한 파라미터의 타입이 발생한 예외와 일치할 경우에만 어드바이스가 호출됨
- @After
  - 메서드 실행이 정상 종료됐을 때와 예외가 발생했을 때 모두 실행되는 어드바이스
  - finally를 사용했을 때와 비슷한 용도
  - 리턴 값이나 예외를 직접 전달받을 수 없음

---------

## AspectJ와 @Configurable

### AspectJ AOP

- 스프링 APO에서는 DI의 도움을 받아 프록시 오브젝트를 추가함으로써 애스펙트를 적용하나 AspectJ는 타깃 오브젝트 자체의 코드를
바꿈으로써 애스펙트를 적용함
  - 프록시를 사용하지 않음
  - 클래스 바이트 코드를 변경하는 작업이 필요
  - 프록시 방식으로는 어드바이스를 적용할 수 없은 조인 포인트와 포인트컷 지시자를 지원하기 위해서

### 빈이 아닌 오브젝트에 DI 적용하기

- 스프링이 직접 제공하는 AspectJ APO 적용 기능 한 가지
- DI 적용을 받으려면 스프링의 IoC 대상 즉 빈이 돼어야 함
- 도메인 오브젝트는 빈을 참조하지 않기 때문에 DI를 받을 필요가 없음
- 하지만 도메인 오브젝트가 다른 빈을 사용하고 싶다면 빈으로 등록하고 스코프를 프로토타입으로 선언해야할까?
- 자동 DI 작업을 수행해주는 AOP 어드바이스를 적용해주는 것
