# 데이터 액세스 기술

- 스프링은ㅇ 주요 자바 데이터 액세스 기술을 모두 지원함
  - JDBC, iBatis, JPA, JDO ...

-------------

## 공통 개념

### DAO 패턴

- 데이터 액세스 계층은 DAO 패턴이라 불리는 방식으로 분리하는 것이 원칙
  - 비즈니스 로직이 없거나 단순하면 DAO와 서비스 계층을 통합할 수 있으나 의미 있는 비즈니스 로직을 가진 다면
  DAO 패턴으로 분리해야 함
- DAO 패턴은 DTO 또는 도메인 오브젝트만을 사용하는 인터페이스를 통해 데이터 액세스 기술을 외부에 노출하지 않도록 만드는 것
- DAO를 이용하는 서비스 계층의 코드를 기술이나 환경에 종속되지 않는 순수한 POJO로 개발할 수 있음

#### DAO 인터페이스와 DI

- DAO는 인터페이스를 이용해 접근하고 DI 되도록 만들어야 함
  - 구체적인 데이터 액세스 기술과 관련된 어떤 API나 정보도 노출하지 않음
- DAO 인터페이스는 서비스 계층 코드에서 의미 있는 메서드만 인터페이스로 공개해야 함
  - DAO 클래스에 DI를 위해 넣은 setDataSource() 같은 수정자 메서드를 인터페이스에 추가하면 안됨
- 특정 데이터 액세스 기술에서만 의미 있는 DAO 메서드 이름은 피해야 함
  - JPA로 DAO를 만든다고 해서 persist(), merge() 라고 이름을 정하는건 바람직하지 못함
  - add(), update() 같은 이름 선택

#### 예외처리

- 데이터 액세스 중에 발생하는 예외는 대부분 복구할 수 없음
  - DAO 밖으로 던져질 때는 런타임 예외여야 함
- DAO 메서드 선언부에 throws SQLException과 같은 내부 기술을 드러내는 예외를 직접 노출해선 안됨
- throws Exception과 같은 무책임한 선언도 하면 안됨

### DataSource

- JDBC를 통해 DB를 사용하려면 Connection 타입의 DB 연결 오브젝트가 필요
- Connection은 모든 데이터 액세스 기술에서 사용되는 필수 리소스
  - 각 요청마다 Connection을 새로 만들고 종료시킴
- 애플리케이션 서버와 DB 사이의 실제 커넥션을 매번 새롭게 만드는 건 비효율적이고 성능을 떨어트림
  - 보통 미리 정해진 개수만큼의 DB 커넥션을 풀(pool)에 준비해두고 요청이 오면 풀에서 꺼내 할당해주고 다시 돌려받아서 풀에 넣는 식의
  풀링 기법을 이용함

#### 학습 테스트와 통합 테스트를 위한 DataSource

- SimpleDriverDataSource
  - 가장 단순한 DataSource 구현 클래스
  - getConnection()을 호출할 때마다 매번 DB 커넥션을 새로 만들고 따로 풀을 관리하지 않음
  - 실전에서는 사용하면 안됨
- SingleConnectionDataSource
  - 하나의 물리적인 DB 커넥션만 만들어두고 이를 계쏙 사용하는 DataSource
  - 순차적으로 진행되는 통합 테스트에서는 사용 가능하지만 두 개 이상의 스레드가 동작하는 경우에는
  하나의 커넥션을 공유하게 되므로 위험
  - 매번 커넥션을 생성하지 않기 때문에 SimpleDriverDataSource에 비해 빠르게 동작함

#### 오픈소스 또는 사용 DB 커넥션 풀

- 아파치 Commons DBCP
  - 가장 유명한 오픈소스 DB 커넥션 풀 라이브러리
- c3p0 JDBC/DataSource Resource Pool

#### JDNI/WAS DB 풀

- DB 풀 라이브러리를 사용해 애플리케이션 레벨의 전용 풀을 만드는 대신 서버가 제공하는 DB 풀을 사용해야 하는 경우에는 JNDI를 통해 서버의 DataSource에 접근해야 함

-------------

## JDBC

- 자바의 데이터 액세스 기술의 기본이 되는 로우레벨의 API
- JDBC는 표준 인터페이스를 제공하고 각 DB 벤더와 개발팀에서 이 인터페이스를 구현한 드라이버를 제공하는 방식으로 사용됨
  - SQL의 호환성만 유지된다면 JDBC로 개발한 코드는 DB가 변경돼도 그대로 재사용할 수 있다는 장점이 있음
- 스프링 JDBC는 JDBC 개발의 장점과 단순성을 그대로 유지하면서 기존 JDBC API 사용 방법의 단점을 템플릿/콜백 패턴을 이용해 극복할 수 있게 해주고 가장 간결한 형태의
API의 사용법을 제공하며 JDBC API에서는 지원되지 않는 편리한 기능을 제공함
  - 스프링 JDBC API의 사용 방법과 동작 원리를 익혀야 한다는 부담이 있음

### 스프링 JDBC 기술과 동작원리

#### 스프링의 JDBC 접근 방법

- SimpleJdbcTemplate
  - 방대한 템플릿 메서드와 내장된 콜백을 제공
  - JDBC의 모둔 기능을 최댛나 활용할 수 있는 유연성을 갖춤
- SImpleJdbcInsert, SimpleJdbcCall
  - DB가 제공해주는 메타정보를 활용해 최소한의 코드만으로 단순한 JDBC 코드를 작성하게 해줌

#### 스프링 JDBC가 해주는 작업

- Connection 열기와 닫기
  - 코드에서 직접 열고 닫는 작업을 할 필요가 없음
  - 열고 닫는 시점은 스프링 트랜잭션 기능과 맞물려서 결정됨
    - 트랜잭션 경계를 어떻게 선언해뒀고 어떤 순서로 호출하느냐에 따라서 매번 Connection을 열고 닫는 위치가 달라질 수 있음
- Statement 준비와 닫기
  - SQL 정보가 담긴 Statement, PreparedStatement를 생성하고 준비 작업을 해줌
  - 파라미터 바인딩에 사용할 정보가 담긴 맵이나 오브젝트를 준비하는건 개발자의 책임
- Statement 실행
- ResultSet 루프
  - ResultSet 각 로우의 내용을 어떻게 오브젝트에 담을 것인지는 루프 안에서 실행되는 콜백으로 만들어 템플릿에 제공해주면 됨
- 예외처리와 반환
  - 체크 예외인 SQLException을 런타임 예외인 DataAccessException 타입으로 변환해줌
  - DB별 에러 코드를 참고해서 일관된 의미를 가진 DataAccessException 계층구조 내의 예외로 반환해줌
- 트랜잭션 처리

### SimpleJdbcTemplate

- SimpleJdbcTemplate이 제공하는 기능은 실행, 조회, 배치 세 가지 작업
  - 실행은 INSERT, UPDATE와 같이 DB 데이터 변경
  - 조회는 SELECT
  - 배치는 하나 이상의 실행 작업을 한 번에 수행해줘야 할 때

#### SimpleJdbcTemplate 생성

```java
SimpleJdbcTemplate template = new SimpleJdbcTemplate(dataSource);
```

- DataSource는 보통 빈으로 등록해두므로 SimpleJdbcTemplate이 필요한 DAO에서 DataSource 빈을 DI 받아 SimpleJdbcTemplate을 생성해두고 사용하면 됨
  - 멀티스레드 환경에서도 안전하게 공유할 수 있기 때문에 DAO의 인스턴스 변수에 저장해두고 사용 가능
  - 또는 SimpleJdbcTemplate 자체를 빈(싱글톤)으로 등록하고 모든 DAO가 공유해도 됨

#### SQL 파라미터

- SimpleJdbcTemplate에 작업을 요청할 때는 문자열로 된 SQL을 제공해줘야 함
  - 매번 달라지는 값이 있는 경우에는 "?" 와 같은 치환자를 넣어두고 파라미터 바인딩 방법을 사용
  - INSERT INTO MEMBER(ID, NAME, POINT) VALUES (?, ?, ?)
    - 순서 중요
  - 이름 치환자 기능도 있음
  - INSERT INTO MEMBER(ID, NAME, POINT) VALUES (:id, :name, :point)
    - 순서 영향 없음
- Map도 있음
  - map 오브젝트는 이름 치환자를 가진 SQL과 함께 SimpleJdbcTemplate에 전달돼 바인딩 파라미터로 사용 가능
  - 코드를 이용해 맵에 정보를 직접 넣어야 한다면 스프링 JDBC의 MapSourceParameterSource를 이용하는 것이 편함
- BeanPropertySqlParameterSource
  - 맵 대신 도메인 오브젝트나 DTO를 사용하게 해줌
  - 오브젝트의 프로퍼티 일므과 SQL의 이름 치환자를 매핑해서 파라미터의 값을 넣어주는 방식
  

#### SQL 실행 메서드

- INSERT, UPDATE, DELETE와 같은 SQL을 실행할 때는 SimpleJdbcTemplate의 update() 메서드를 사용함
- varargs
  - 위치 치환자(?) 를 사용하는 경우 바인딩할 파라미터를 순서대로 전달하면 됨
- Map
  - 이름 치환자를 사용할 경우 파라미터를 map으로 전달할 수 있음
- SqlParameterSource
  - 도메인 오브젝트나 DTO를 이름 치환자에 직접 바인딩

#### SQL 조회 메서드

- int queryForInt(String sql, [SQL 파라미터])
  - 하나의 int 타입 값을 조회할 때 사용
  - 파라미터가 없으면 생략할 수 있음
- long queryForLong(String sql, [SQL 파라미터])
  - 하나의 long 타입 값 조회할 때 사용
- T queryForObject(String sql, Class T requiredType, [SQL 파라미터])
  - 쿼리를 실행해서 하나의 값을 가져올 때 사용
  - 결과 타입을 직접 지정할 수 있음
  - 하나의 컬럼을 가진 하나의 로우
- T queryForObject(String sql, RowMapper rm, [SQL 파라미터])
  - 하나의 로우가 돌아오는 경우에 사용
  - 단일 컬럼이 아니라 다중 컬럼을 가진 쿼리에 사용할 수 있음
    - 도메인 오브젝트나 DTO
  - 테이블의 컬럼 이름과 매핑될 오브젝트의 프로퍼티 이름이 일치하다면 RowMapper를 직접 구현하는 대신 BeanPropertyRowMapper를 사용하는 것이 편리함
- T List query(String sql, RowMapper rm, [SQL 파라미터])
  - 여러 개의 칼럼을 가진 로우를 도메인 오브젝트나 DTO에 매핑
- Map queryForMap(String sql, [SQL 파라미터])
  - 단일 로우
  - 맵에 로우의 내용을 저장해서 돌려줌
- List Map queryForList(String sql, [SQL 파라미터])
  - 다중 로우 맵

#### SQL 배치 메서드

- update()로 실행하는 SQL들을 배치 모드로 실행하게 해줌
- int[] batchUpdate(String sql, Map[] batchValues)
  - 이름 치환자를 가진 SQL과 파라미터 정보가 담긴 맵의 배열을 이용
  - 배열의 개수 만큼 SQL을 실행해줌
  - 리턴 값은 각 SQL을 실행했을 때 영향받은 로우의 개수
- int[] batchUpdate(String sql, SqlParameterSource[] batchArgs)
  - 맵 대신 SqlParameterSource 타입 오브젝트의 배열
- int[] batchUpdate(String sql, List Object[] batchArgs)
  - 위치 치환자를 사용할 때 varargs로 전달했던 SQL 파라미터를 Object 배열에 넣고 리스트로 만들어 전달
  - 리스트의 크기만큼 SQL이 반복 실행됨

### SimpleJdbcInsert

- 