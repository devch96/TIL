# 보안: 권한과 감사

- 인증을 처리하면 권한을 처리해야 함
- 역할 기반 접근 제어 전략을 활용

--------

## 스프링 클라우드 게이트웨이와 OAuth2를 통한 권한과 역할

- 사용자가 키클록으로 성공적으로 인증하면 에지 서비스는 키클록에서 인증 이벤트에 대한 정보가 포함된 ID 토큰을 받고 사용자 브라우저와
인증 세션을 시작함
- 동시에 키클록은 OAuth2에 따라 에지 서비스가 사용자를 대신해 다른 애플리케이션에 액세스하도록 권한을 부여하는 액세스 토큰도 발행함

### 스프링 클라우드 게이트웨이에서 다른 서비스로의 토큰 전달

- ID 토큰: 인증이 성공적으로 이루어졌음을 나타내며 인증된 사용자에 대한 정보를 가지고 있음
- 액세스 토큰: OAuth2 리소스 서버가 제공하는 보호된 데이터를 OAuth2 클라이언트가 사용자를 대신해 액세스할 수 있는 권한을 의미
- 액세스 토큰을 통해 에지 서비스는 카탈로그 서비스 및 주문 서비스에 대한 권한을 사용자를 대신해 받음
  - 두 애플리케이션 모두 사용자 인증이 필요하도록 변경하면 에지 서비스는 두 서비스에 대한 모든 요청의 Authorization HTTP 헤더에 액세스 토큰을 가지고
  있어야 함
- 키클록에서 받은 액세스 토큰을 저장한 다음 인증이 필요한 다른 서비스의 엔드포인트 요청에 그대로 포함시킴
- 토큰 릴레이 패턴이라고 하며 스프링 클라우드 게이트웨이에서 내장 필터로 지원하므로 직접 구현할 필요가 없음
  - 필터가 활성화되면 다른 서비스로 전송되는 모든 요청에 액세스 토큰이 자동으로 포함됨

#### 스프링 클라우드 게이트웨이에서 토큰 릴레이 패턴 채택

```yaml
spring:
  cloud:
    gateway:
      default-filters:
        - name: SaveSession
        - name: TokenRelay
```

- 필터가 활성화되면 모든 요청에 대해 Authorization 헤더에 올바른 액세스 토큰을 담아 전달함
  - Bearer ~
- 기본 설정상 스프링 보안은 인증된 사용자의 액세스 토큰을 메모리에 저장하는데 여러 인스턴스로 실행되는 경우 메모리에 상태를 갖는것이 문제가 됨

#### 레디스에 액세스 토큰 저장

- 스프링 보안은 액세스 토큰을 OAuth2AuthorizedClient 객체에 저장하는데 이 객체는 ServerOAuth2AuthorizedClientRepository 빈을 통해 액세스할 수 있음

```java
@Bean
ServerOAuth2AuthorizedClientRepository authorizedClientRepository() {
    return new WebSessionServerOAuth2AuthorizedClientRepository();
}
```

### 토큰 사용자 지정 및 사용자 역할 전파

- ID 토큰과 액세스 토큰 모두 사용자에 대한 여러 가지 정보를 가질 수 있으며 JWT에서 클레임 형식으로 지정됨
  - JSON 형식의 키-값 쌍
- 오픈ID 커넥트는 사용자에 대한 정보를 전달하기 위한 몇 가지 표준적인 클레임을 정의
  - given_name, family_name, preferred_username, email 등

#### 키클록에서 사용자 역할에 대한 액세스 설정

- 키클록은 roles 클레임에 포함된 사용자의 역할에 대해 애플리케이션이 액세스할 수 있도록 범위가 설정되어 있음
  - 기본 설정상 역할 목록에 대한 표현은 객체로 정의해야 하기 때문에 사용이 불편함
- 키클록 설정 페이지에서 변경할 수 있음

#### 스프링 보안에서 사용자 역할에 대한 액세스 설정

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          keycloak:
            client-id: edge-service
            client-secret: polar-keycloak-secret
            scope: openid, role
```

#### ID 토큰에서 사용자 역할 추출

```java
@GetMapping("/user")
public Mono<User> getUser(@AuthenticationPrincipal OidcUser oidcUser) {
    var user = new User(
        oidcUser.getPreferredUsername(),
        oidcUser.getGivenName(),
        oidcUser.getFamilyName(),
        oidcUser.getClaimAsStringList("roles")
    );
    return Mono.just(user);
}
```

---------

## 스프링 보안 및 OAuth2를 통한 API 보호(명령형)

### 스프링 부트 OAuth2 리소스 서버 보호

- OAuth2를 활용해 스프링 부트 애플리케이션을 보호하기 위한 첫 번째 단계는 의존성을 추가하는 것

```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
}
```

#### 스프링 보안과 키클록의 통합 설정

- 스프링 보안은 엔드포인트를 보호하기 위해 JWT와 불투명 토큰이라는 두 가지 유형의 액세스 토큰을 사용함
  - 키클록은 액세스 토큰을 통해 에지 서비스가 사용자를 대신해 다른 서비스에 액세스할 수 있게 해줌
  - 액세스 토큰이 JWT인 경우 인증된 사용자에 대한 정보는 클레임을 가지고 있고 카탈로그 서비스 및 주문 서비스에 쉽게 전달해줄 수 있음
  - 불투명 토큰을 사용하면 토큰과 관련된 정보를 위해 매번 키클록에 연결해야 함
- 수신한 요청의 Authorization 헤더에 액세스 토큰이 포함돼 있으면 스프링 보안은 키클록이 제공하는 공개 키를 사용해 토큰의 서명을 자동으로 확인하고
JwtDecoder 객체를 사용해 클레임을 찾아냄
  - 내부적으로 오토와이어링됨

```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt: # OAuth2는 액세스 토큰에 대한 데이터 형식을 강제로 규정하지 않기 때문에 명시해야 함
          issuer-uri: http://localhost:8080/realms/PolarBookshop # 특정 영역에 대한 모든 관련 OAuth2 엔드포인트에 대한 정보를 제공하는 URL
```

#### JWT 인증에 대한 보안 정책 정의

- 에지 서비스는 사용자 인증 흐름을 시작하고 웹 세션을 활용해 ID 토큰 및 액세스 토큰과 같은 데이터를 저장함
  - 스프링 세션을 사용해 레디스가 웹 세션 데이터를 저장하고 애플리케이션이 상태를 갖지 않게 함
- 카탈로그 서비스는 요청을 인증하기 위해 액세스 토큰만 있으면 됨
  - 엔드포인트에 대한 HTTP 요청은 토큰을 항상 가지고 있기 때문에 요청 사이에 데이터를 저자할 필요가 없음
    - 무상태 인증 또는 토큰 기반 인증이라 부름

```java
@EnableWebSecurity
public class SecurityConfig {
	@Bean
	SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		return http.authorizeHttpRequests(authorize -> authorize
				.mvcMatchers(HttpMethod.GET, "/", "/books/**")
				.permitAll()
				.anyRequest().authenticated()
			)
			.oauth2ResourceServer(
				OAuth2ResourceServerConfigurer::jwt
			)
			.sessionManagement(sessionManagement ->
				sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
			.csrf(AbstractHttpConfigurer::disable)
			.build();
	}
}
```

### 스프링 보안 및 JWT를 통한 역할 기반 접근 제어

- 스프링 보안은 사용자에게 부여된 권한을 모델링하기 위해 인증된 사용자에게 GrantedAuthority 객체 목록을 연결함
- 부여된 권한은 세부화된 승인, 역할 심지어 범위를 나타내기 위해 사용할 수 있고 인증 전략에 따라 출처가 다를 수 있음
- 권한 정보는 Authentication 객체를 통해 얻고 이 객체는 SecurityContext에 저장됨
- 스프링 보안은 액세스 토큰의 scopes 클레임에서 범위 목록을 추출해 사용자에게 부여된 권한으로 사용함
  - GrantedAuthority 객체는 SCOPE_ 접두사와 범위 값으로 명명됨

#### 액세스 토큰에서 사용자 역할 추출

- 스프링 보안은 JWT에서 정보를 추출할 때 사용자 지정 전략을 사용하는 경우 사용할 수 있도록 JwtAuthenticationConverter 클래스를 제공함

```java
@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    var jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    jwtGrantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");
    jwtGrantedAuthoritiesConverter.setAuthoritiesClaimName("roles");
    
    var jwtAuthenticationConverter = new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);
    return jwtAuthenticationConverter;
}
```

#### 사용자 역할에 따른 권한 부여 정책 정의

- 스프링 보안은 권한 정책을 정의하기 위해 표현식 기반 DSL을 제공함
  - hasAuthority("ROLE_employee")
  - hasRole("employee")
    - 내부적으로 스프링 보안이 ROLE_ 접두사를 붙임

```java
@Bean
SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    return http.authorizeHttpRequests(authorize -> authorize
            .mvcMatchers(HttpMethod.GET, "/", "/books/**")
            .permitAll()
            .anyRequest().hasRole("employee")
        )
        .oauth2ResourceServer(
            OAuth2ResourceServerConfigurer::jwt
        )
        .sessionManagement(sessionManagement ->
            sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .csrf(AbstractHttpConfigurer::disable)
        .build();
}
```

### 스프링 보안 및 테스트컨테이너를 이용한 OAuth2 테스트

```groovy
ext {
  set('testKeycloakVersion', "2.3.0")
}

dependencies {
  testImplementation 'org.springframework.security:spring-security-test'
  testImplementation 'org.testcontainers:junit-jupiter'
  testImplementation "com.github.dasniko: testcontainer-keycloak:${testKeycloakVersion}"
}
```

#### 보호된 REST 컨트롤러 테스트를 위한 @WebMvcText 및 스프링 보안

- OAuth2 액세스 토큰 유효성 검사의 일환으로 스프링 보안은 키클록이 제공하는 공개 키를 사용해 JWT 서명을 확인함
- 스프링 보안은 내부적으로 JwtDecoder 빈을 설정하고 해당 키를 사용해 JWT를 해독하고 확인함
- 웹 슬라이스 테스트의 맥락에서 모의 JwtDecoder 빈을 제공해 스프링 보안과 키클록의 상호작용을 생략할 수 있음
  - 통합 테스트를 작성할 때는 생략하지 않고 확인해야함

```java
@WebMvcTest(BookController.class)
@Import(SecurityConfig.class)
class BookControllerMvcTests {
	@Autowired
	private MockMvc mockMvc;

	@MockBean
	private BookService bookService;

	@MockBean
	private JwtDecoder jwtDecoder;

	@Test
	void whenDeleteBookWithEmployeeRoleThenShouldReturn204() throws Exception {
		var isbn = "7373731394";
		mockMvc.perform(MockMvcRequestBuilders.delete("/books/" + isbn)
				.with(SecurityMockMvcRequestPostProcessors.jwt()
					.authorities(new SimpleGrantedAuthority("ROLE_employee"))))
			.andExpect(MockMvcResultMatchers.status().isNoContent());
	}

	@Test
	void whenDeleteBookWithCustomerRoleThenShouldReturn403() throws Exception {
		var isbn = "7373731394";
		mockMvc.perform(MockMvcRequestBuilders.delete("/books/" + isbn)
			.with(SecurityMockMvcRequestPostProcessors.jwt()
				.authorities(new SimpleGrantedAuthority("ROLE_customer"))))
			.andExpect(MockMvcResultMatchers.status().isForbidden());
	}

	@Test
	void whenDeleteBookNotAuthenticatedThenShouldReturn401() throws Exception {
		var isbn = "7373731394";
		mockMvc.perform(MockMvcRequestBuilders.delete("/books/" + isbn))
			.andExpect(MockMvcResultMatchers.status().isUnauthorized());
	}
}
```

#### @SpringBootTest, 스프링 보안 및 테스트컨테이너를 이용한 통합 테스트

```java
@SpringBootTest(
	webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
)
@ActiveProfiles("integration")
@Testcontainers
class CloudnativeApplicationTests {
	@Autowired
	private WebTestClient webTestClient;

	private static KeycloakToken bjornTokens;
	private static KeycloakToken isabelleTokens;
	@Container
	private static final KeycloakContainer keycloakContainer =
		new KeycloakContainer("quay.io/keycloak/keycloak:19.0")
			.withRealmImportFile("test-realm-config.json");

	@DynamicPropertySource
	static void dynamicProperties(DynamicPropertyRegistry registry) {
		registry.add("spring.security.oauth2.resourceserver.jwt.issuer-uri",
			() -> keycloakContainer.getAuthServerUrl() + "realms/PolarBookshop");
	}

	@BeforeAll
	static void generateAccessTokens() {
		WebClient webClient = WebClient.builder()
			.baseUrl(keycloakContainer.getAuthServerUrl()
			+ "realms/PolarBookshop/protocol/openid-connect/token")
			.defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_FORM_URLENCODED_VALUE).build();

		isabelleTokens = authenticateWith("isabelle", "password", webClient);
		bjornTokens = authenticateWith("bjorn", "password", webClient);
	}

	private static KeycloakToken authenticateWith(String username, String password, WebClient webClient) {
		return webClient.post()
			.body(
				BodyInserters.fromFormData("grant_type", "password")
					.with("client_id", "polar-test")
					.with("username", username)
					.with("password", password)
			).retrieve()
			.bodyToMono(KeycloakToken.class)
			.block();
	}

	private record KeycloakToken(String accessToken) {
		@JsonCreator
		private KeycloakToken(@JsonProperty("access_token") final String accessToken) {
			this.accessToken = accessToken;
		}
	}
	@Test
	void whenPostRequestThenBookCreated() {
		var expectedBook = Book.of("1231231231", "Title", "Author", 9.90, "aaaa");
		webTestClient.post()
			.uri("/books")
			.headers(headers -> headers.setBearerAuth(isabelleTokens.accessToken()))
			.bodyValue(expectedBook)
			.exchange()
			.expectStatus().isCreated()
			.expectBody(Book.class).value(actualBook -> {
				assertThat(actualBook).isNotNull();
				assertThat(actualBook.isbn())
					.isEqualTo(expectedBook.isbn());
			});
	}

	@Test
	void whenPostRequestUnauthorizedThen403() {
		var expectedBook = Book.of("1231231231", "Title", "Author", 9.90, "aaaa");
		webTestClient.post().uri("/books")
			.headers(headers -> headers.setBearerAuth(bjornTokens.accessToken()))
			.bodyValue(expectedBook)
			.exchange()
			.expectStatus().isForbidden();
	}

	@Test
	void whenPostRequestUnauthenticatedThen401() {
		var expectedBook = Book.of("1231231231", "Title", "Author", 9.90, "aaaa");
		webTestClient.post().uri("/books")
			.bodyValue(expectedBook)
			.exchange()
			.expectStatus().isUnauthorized();
	}
}
```

---------

## 스프링 보안과 OAuth2를 이용한 API 보호(반응형)

### 스프링 부트 OAuth2 리소스 서버 보호

```java
@EnableWebFluxSecurity
public class SecurityConfig {
	@Bean
	SecurityWebFilterChain filterChain(ServerHttpSecurity http) {
		return http
			.authorizeExchange(exchange -> exchange
				.anyExchange().authenticated())
			.oauth2ResourceServer(
				ServerHttpSecurity.OAuth2ResourceServerSpec::jwt)
			.requestCache(
				requestCacheSpec -> requestCacheSpec.requestCache(NoOpServerRequestCache.getInstance()))
			.csrf(ServerHttpSecurity.CsrfSpec::disable)
			.build();
	}
}
```

### 스프링 보안 및 테스트컨테이너로 OAuth2 테스트

#### 보호된 REST 컨트롤러 테스트를 위한 @WebFluxTest 및 스프링 보안

```java
@WebFluxTest(controllers = OrderController.class)
@Import(SecurityConfig.class)
class OrderControllerWebFluxTests {

	@Autowired
	private WebTestClient webClient;

	@MockBean
	private OrderService orderService;
	@MockBean
	ReactiveJwtDecoder reactiveJwtDecoder;
	@Test
	void whenBookNotAvailableThenRejectOrder() {
		var orderRequest = new OrderRequest("1234567890", 3);
		var expectedOrder = OrderService.buildRejectedOrder(
			orderRequest.isbn(), orderRequest.quantity());
		given(orderService.submitOrder(
			orderRequest.isbn(), orderRequest.quantity())
		).willReturn(Mono.just(expectedOrder));

		webClient
			.mutateWith(SecurityMockServerConfigurers.mockJwt().authorities(new SimpleGrantedAuthority("ROLE_customer")))
			.post()
			.uri("/orders/")
			.bodyValue(orderRequest)
			.exchange()
			.expectStatus().is2xxSuccessful()
			.expectBody(Order.class).value(actualOrder -> {
				assertThat(actualOrder).isNotNull();
				assertThat(actualOrder.status()).isEqualTo(OrderStatus.REJECTED);
			});
	}
}
```

--------

## 스프링 보안 및 스프링 데이터로 데이터 보호 및 감사

- @PreAuthorize와 같은 애너테이션을 사용하면 비즈니스 메서드에서 직접 사용자 인증 또는 권한을 확인할 수 있는 메서드 보안 기능을 활성화할 수 있음
- 데이터 계층에서는 어떤 사용자가 어떤 데이터를 언제 생성하고 마지막으로 누가 변경했는지, 사용자가 자신의 주문 데이터에만 접근할 수 있도록 하려면 어떻게 해야 하는 지
작업이 필요함

### 스프링 보안 및 스프링 데이터 JDBC를 사용한 데이터 감사

#### JDBC 데이터 엔티티를 만들거나 업데이트한 사용자를 캡처할 감사자(auditor) 정의

```java
@Configuration
@EnableJdbcAuditing
public class DataConfig {
	@Bean
	AuditorAware<String> auditorAware() { // 감사 목적으로 현재 인증된 사용자를 반환
		return () -> Optional
			.ofNullable(SecurityContextHolder.getContext())
			.map(SecurityContext::getAuthentication)
			.filter(Authentication::isAuthenticated)
			.map(Authentication::getName);
	}
}
```

#### JDBC 데이터 엔티티를 생성하거나 변경한 사용자에 대한 감사 메타데이터 추가

```java
public record Book(
	@Id
	Long id,

	@NotBlank(message = "The book ISBN must be defined.")
	@Pattern(
		regexp = "^([0-9]{10}|[0-9]{13})$",
		message = "The ISBN format must be valid."
	)
	String isbn,
	@NotBlank(message = "The book title must be defined.")
	String title,
	@NotBlank(message = "The book author must be defined.")
	String author,
	@NotNull(message = "The book price must be definec.")
	@Positive(
		message = "The book price must be freater than zero."
	)
	Double price,
	String publisher,
	@CreatedDate
	Instant createdDate,

	@LastModifiedDate
	Instant lastModifiedDate,
	@Version
	int version,
	
	@CreatedBy
	String createdBy,
	@LastModifiedBy
	String lastModifiedBy
) {
	public static Book of(String isbn, String title, String author, Double price, String publisher) {
		return new Book(null, isbn, title, author, price, publisher, null,null,0, null, null);
	}
}

public Book editBookDetails(String isbn, Book book) {
  return bookRepository.findByIsbn(isbn)
          .map(existingBook -> {
            var bookToUpdate = new Book(
                    existingBook.id(),
                    existingBook.isbn(),
                    book.title(),
                    book.author(),
                    book.price(),
                    book.publisher(),
                    existingBook.createdDate(),
                    existingBook.lastModifiedDate(),
                    existingBook.version(),
                    existingBook.createdBy(),
                    existingBook.lastModifiedBy());
            return bookRepository.save(bookToUpdate);
          }).orElseGet(() -> addBookToCatalog(book));
}
```

#### 스키마에 새 감사 메타데이터를 추가하기 위한 플라이웨이 마이그레이션 작성

- 데이터베이스 스키마 역시 변경해야 함
- 데이터베이스에 버전 관리 기능을 추가하기 위한 플라이웨이

```sql
ALTER TABLE book
    ADD COLUMN created_by varchar(255);
ALTER TABLE book
    ADD COLUMN last_modified_by varchar(255);
```

### 스프링 데이터와 @WithMockUser를 통한 데이터 감사 테스트

- 데이터 계층에서 보안을 테스트할 때 어떤 인증 전략이 채택되었는지에 대해서는 관심이 없음
  - 요청이 인증된 상태에서 처리되었는지 여부가 관심
- 인증된 콘텍스트에서 테스트 케이스를 실행하기 위해 @WithMockUser를 사용할 수 있음

```java
@Test
void whenCreatedBookNotAuthenticatedThenNoAuditMetadata() {
    var bookToCreate = Book.of("1232343456", "Title", "Author", 12.90, "Polarsophia");
    var createdBook = bookRepository.save(bookToCreate);

    assertThat(createdBook.createdBy()).isNull();
    assertThat(createdBook.lastModifiedBy()).isNull();
}

@Test
@WithMockUser("john")
void whenCreatedBookAuthenticatedThenAuditMetadata() {
    var bookToCreate = Book.of("1232343457", "Title", "Author", 12.90, "Polarsophia");
    var createdBook = bookRepository.save(bookToCreate);

    assertThat(createdBook.createdBy()).isEqualTo("john");
    assertThat(createdBook.lastModifiedBy()).isEqualTo("john");
}
```

---------

