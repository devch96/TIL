# 스프링 부트 컨테이너화

-----------------

## 도커에서 컨테이너 이미지로 작업하기

- 토커 엔진은 클라이언트/서버 구조를 가지고 있음
  - 도커 CLI는 도커 서버와의 상호작용을 위해 사용하는 클라이언트
  - 도커 서버는 도커 데몬을 통해 도커의 모든 리소스(이미지,컨테이너,네트워크)를 관리

### 컨테이너 이미지 이해

- 컨테이너 이미지는 여러 개의 명령을 순서대로 실행한 결과물로, 각 명령의 실행한 결과로 레이어가 만들어짐
- 각 이미지는 여러 개의 레이어로 이루어져 있으며, 각 층은 해당 명령어를 실행한 결과 생성된 변경 사항을 나타냄
- 이미지는 베이스 이미지를 기반으로 만들거나 아예 처음부터 만들 수 있음
  - 베이스 이미지를 기반으로 새로운 이미지를 생성하는 것이 일반적인 방법
- 우분투 이미지부터 시작해 변경 사항 적용
  - 우분투를 베이스 이미지로 사용
  - 자바 런타임 환경을 설치
  - java --version 명령을 실행
- 컨테이너 이미지의 모든 레이어는 읽기 전용
  - 적용되면 더 이상 수정할 수 없음
  - 무언가를 변경해야 하면 기존 레이어 위에 새로 적용해야 함
  - 상위 레이어에 적용된 변경사항은 하위 레이어에 영향을 미치지 않음
    - 카피 온 라이트 접근법
- 이미지가 컨테이너로 실행되면 컨테이너 레이어라고 부르는 마지막 한 레이어가 기존의 모든 레이어 위에 자동으로 적용됨
  - 유일하게 쓰기가 가능한 레이어
  - 컨테이너 실행 중 생성되는 데이터를 저장하기 위해 사용됨
  - 쓰기는 가능하지만 휘발성이 있음(컨테이너를 삭제하면 실행 도중 그 층에 저장된 모든 것이 사라짐)

### 도커파일을 통한 이미지 생성

- OCI 형식에 따라 도커파일이라고 부르는 특정 파일에 명령어를 순서대로 나여해 컨테이너 이미지를 정의할 수 있음
  - 레시피 역할을 하는 스크립트
  - 원하는 이미지를 빌드하기 위해 필요한 모든 단계를 정의

```dockerfile
FROM ubuntu:22.04 // 새 이미지에 대한 베이스 이미지로 우분투 22.04 지정

RUN apt-get update && apt-get install -y default-jre // JRE 설치

ENTRYPOINT ["java", "--version"] // 실행 컨테이너의 엔트리 포인트 정의
```

- 도커는 기본 설정으로 도커 허브를 연결해 이미지를 찾고 다운함
- java --version 명령은 컨테이너 실행을 위한 진입점(엔트리 포인트)
  - 진입점을 지정하지 않으면 컨테이너가 실행되지 않음
- 가상 머신과 달리 컨테이너는 운영체제를 실행하기 위한 것이 아닌 작업을 실행하기 위한 것
- 컨테이너 이미지를 만들기 위해 도커파일에서 사용하는 일반적인 명령어
  - FROM
    - 후속 명령어의 대상이 될 베이스 이미지를 지정
    - 도커파일에서 가장 처음에 와야 하는 명령
    - FROM ubuntu:22.04
  - LABEL
    - 키-값 형식에 따라 이미지에 메타데이터를 추가
    - 여러 번 정의 가능
    - LABEL version="1.2.1"
  - ARG
    - 사용자가 빌드 시에 전달할 수 있는 변수를 정의
    - 여러 번 정의 가능
    - ARG JAR_FILE
  - RUN
    - 기존 레이어 위에서 인자로 전달된 명령어를 실행해 새로운 레이어를 생성
    - 여러 번 정의 가능
    - RUN apt-get update && apt-get install -y default-jre
  - COPY
    - 호스트 파일 시스템의 파일 또는 디렉터리를 컨테이너 내부의 파일 또는 디렉터리로 복사함
    - COPY app-0.0.1-SNAPSHOT.jar app.jar
  - USER
    - 모든 후속 명령어 및 컨테이너 실행을 위한 사용자를 정의
    - USER sheldon
  - ENTRYPOINT
    - 이미지가 컨테이너로 실행될 때 실행할 프로그램을 정의
    - 여러개의 명령이 있으면 마지막 명령만 고려
    - ENTRYPOINT ["/bin/bash"]
  - CMD
    - 실행 중인 컨테이너에 대한 기본 설정을 지정
    - ENTRYPOINT 명령이 정의되어 있으면 그 명령의 인수로 전달되고 그렇지 않으면 실행 파일도 가능
    - 마지막 명령만 고려
    - CMD ["sleep","10"]
- 도커파일에 컨테이너 이미지를 만들기 위한 명세를 다 마치면 docker build 명령을 실행해 도커파일 내의 모든 명령을 하나씩 수행하면서
각 명령에 대해 새로운 레이어를 생성할 수 있음
- 계층화된 접근법으로 인해 이미지 빌드는 성능이 좋음
  - 각 이미지 레이어는 이전 이미지 레이어의 증분
  - 도커는 모든 이미지 레이어를 캐싱
  - 한 레이어를 변경하고 이미지를 다시 빌드하면 해당 레이어와 그 이후의 레이어만 다시 생성됨
  - 레지스트리에 저장된 이미지의 새 버전을 컨테이너로 실행하면 새로운 레이어만 다운하기에 런타임 성능이 향상
- 변경 가능성에 따라 레이어의 순서를 정해 이미지 빌드 프로세스를 최적화하는 것이 바람직함
  - 자주 변경될 가능성이 많을수록 도커파일의 뒤에 오도록 해야 함
- 컨테이너 이미지는 docker run 명령으로 실행
  - 컨테이너를 시작하고 도커파일에서 진입점으로 지정된 프로세스를 실행함

### 깃허브 컨테이너 저장소로 이미지 저장

- 컨테이너 저장소와 이미지의 관계는 메이븐 저장소와 자바 라이브러리의 관계
- 깃헙 PAT(Personal Access Token) 발급

```shell
docker login ghcr.io
Username: username
Password: PAT

docker tag my-java-image:1.0.0 ghcr.io/username/my-java-image:1.0.0

docker push ghcr.io/username/my-java-image:1.0.0
```

--------

## 스프링 부트 애플리케이션을 컨테이너 이미지로 패키지

### 스프링 부트의 컨테이너화를 위한 준비

- 스프링 부트 애플리케이션을 컨테이너 이미지로 패키징한다는 것은 고립된 콘텍스트에서 계산 리소스와 네트워크를 가지고 애플리케이션을
실행한다는 것을 의미
  - 어떻게 네트워크를 통해 애플리케이션에 도달할 수 있을까
  - 어떻게 다른 컨테이너와 연결해 상호작용할 수 있을까

#### 포트 전달을 사용한 애플리케이션 서비스 노출

- 기본 설저상 컨테이너는 도커 호스트 내부의 격리된 네트워크로 연결함
  - 로컬 네트워크에서 컨테이너로 연결하려면 포트 매핑을 명시적으로 설정해야 함
  - docker run -p 8080:8080 (외부 포트:컨테이너 포트)

#### 서비스 발견을 위한 도커 내장 DNS 서버의 사용

- 카탈로그 서비스 애플리케이션은 jdbc:postgresql:/localhost:5432 URL을 통해 컨테이너로 실행 중인 PostgreSQL 데이터베이스 서버에 액세스 할 수 있었음
  - 포트 포워딩 덕분
- 카탈로그 서비스를 컨테이너로 실행한다면 localhost는 더 이상 자신의 로컬 컴퓨터가 아닌 컨테이너 내부를 나타내기 떄문에 연결 불가
- 도커는 동일한 네트워크의 컨테이너가 호스트 이름이나 IP 주소가 아닌 컨테이너 이름을 사용해 서로를 찾을 수 있도록 해주는 DNS 서버를 내장함
  - jdbc:postgresql://polar-postgres:5432

```shell
docker network create catalog-network
docker network false 
docker run -d --name polar-postgres --net catalog-network \
-e POSTGRES_USER=user -e POSTGRES_PASSWORD=password -e POSTGRES_DB=polardb_catalog \
-p 5432:5432 \
postgres:14.4
```

### 도커파일로 스프링 부트 컨테이너화

- 스프링 부트를 사용하면 런타임 환경을 제외하고 애플리케이션이 실행하기 위해 필요한 모든 것을 독립 실행 가능한 JAR로 패키징할 수 있음
- JAR 아티팩트외에도 컨테이너 이미지에 필요한 것은 운영체제와 JRE

```dockerfile
FROM eclipse-temurin:17 // JRE가 이미 설치되어 있는 이클립스 테무린 배포판 우분투 베이스 이미지
WORKDIR workspace // 작업 폴더를 workspace로 변경

ARG JAR_FILE=build/libs/*.jar // JAR 파일의 위치를 지정하는 빌드 인수
COPY ${JAR_FILE} catalog-service.jar // JAR 파일을 로컬 머신에서 이미지 안으로 복사
ENTRYPOINT ["java", "-jar", "catalog-service.jar"] // 애플리케이션을 실행하기 위한 컨테이너 엔트리 포인트
```

### 프로덕션을 위한 컨테이너 이미지 빌드

#### 성능

- 컨테이너 이미지를 만들 때 빌드할 때와 런타임 성능을 고려해야 함
- 변경되지 않은 레이어를 캐싱하고 재사용함
- 앞 에서는 카탈로그 서비스 독립 실행형 JAR 파일을 이미지의 레이어로 복사했기에 애플리케이션에서 무언가를 변경할 때마다 전체 레이어를 다시 작성해야 함
  - 우버 JAR을 컨테이너 이미지에 넣는 것은 효율적이지 않음
- JAR 아티팩트는 애플리케이션에서 사용되는 모든 의존성, 클래스 및 자원을 포함하고 있는 압축 아카이브
  - 폴더의 계층 구조로 구성됨
- 스프링 부트 2.4 이후 계층화된 JAR 모드가 기본 설정
  - 컨테이너 이미지와 유사하게 여러 레이어로 만들어짐
- 기본적으로 스프링 부트 애플리케이션은 계층으로 이루어진 JAR 아티팩트로 패키징되는데 가장 낮은 계층부터 시작됨
  - 의존성 계층: 프로젝트에 추가된 모든 주요 의존성
  - 스프링 부트 로더 계층: 스프링 부트 로더 컴포넌트가 사용하는 클래스
  - 스냅숏 의존성 계층: 모든 스냅숏 의존성
  - 애플리케이션 계층: 애플리케이션 클래스 및 리소스
- 계층화된 JAR 모드를 사용하기 위해서는 JAR 파일을 이미지로 복사하고 네 개의 게층으로 확장하기 위한 준비 작업을 해야 함
- 예시로는 두 단계로 진행
  - 첫 번째 단계는 JAR 파일에서 계층을 추출
  - 두 번째 단계는 각 JAR 계층을 별도의 이미지 레이어로 배치
  - 첫 번째 단계의 결과는 폐기 처분, 두 번째 단계에서 최종 컨테이너 이미지가 생성됨

```dockerfile
FROM eclipse-temurin:17 AS builder // 첫 단계를 위한 OpenJDK 베이스 이미지
WORKDIR workspace
ARG JAR_FILE=build/libs/*.jar // 프로젝트 내에서 애플리케이션 JAR 파일의 위치를 지정
COPY ${JAR_FILE} catalog-service.jar // 로컬 머신에서 이미지의 workspace 폴더로 복사
RUN java -Djarmod=layertools -jar catalog-service.jar extract  // 계층 JAR 모드를 적용해 아카이프에서 계층을 추출


FROM eclips-temurin:17
WORKDIR workspace
COPY --from=builder workspace/dependencies/ ./ // 첫 번째 단계에서 추출한 JAR 계층을 두 번째 단계로 복사
COPY --from=builder workspace/spring-boot-loader/ ./
COPY --from=builder workspace/snapshot-dependencies/ ./
COPY --from=builder workspace/application/ ./
ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"] // 우버 JAR 대신 계층으로 애플리케이션을 시작
```

#### 보안

- 기본적으로 루트 사용자로 실행되므로 잠재적으로 도커 호스트에 루트 액세스를 허용한다는 점을 유념
- 최소 권한의 원칙을 따를 것
  - 필요 이상의 권한을 갖지 않는 사용자를 만들어 사용자가 도커파일에 정의된 진입점 프로세스를 실행하도록

```dockerfile
FROM eclipse-temurin:17 AS builder
WORKDIR workspace
ARG JAR_FILE=build/libs/*.jar
COPY ${JAR_FILE} catalog-service.jar
RUN java -Djarmod=layertools -jar catalog-service.jar extract


FROM eclips-temurin:17
RUN useradd spring // spring 이름의 유저 생성
USER spring // spring 유저로 설정
WORKDIR workspace
COPY --from=builder workspace/dependencies/ ./
COPY --from=builder workspace/spring-boot-loader/ ./
COPY --from=builder workspace/snapshot-dependencies/ ./
COPY --from=builder workspace/application/ ./
ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"]
```

- 암호나 키와 같은 시크릿을 컨테이너 이미지에 저장해서는 안 됨
  - 상위 계층에서 지워진다고 해도 원래 계층에 그대로 남아 쉽게 액세스할 수 있기 때문

#### 도커파일 대 빌드팩

- 도커파일은 관리 및 유지 보수에 추가적인 노력이 필요함
  - 개발자가 성능, 보안 문제를 다루고 싶지 않을 수 있음
- 클라우드 네이티브 빌드팩은 일관성, 보안, 성능 및 거버넌스에 중점을 둔 다른 접근법을 제공

### 클라우드 네이티브 빌드팩을 이용한 스프링 부트 컨테이너화

- 스프링 부트 2.3 이후 그래들 및 메이븐용 스프링 부트 플러그인에 통합되어 전용 빌드팩 CLI인 pack을 설치할 필요가 없음
- 클라우드 네이티브 빌드팩이 제공하는 기능
  - 애플리케이션 유형을 자동으로 감지해 도커파일 없이 패키지 생성
  - 다양한 언어와 플랫폼 지원
  - 캐시와 레이어를 통해 높은 성능 보유
  - 재현 가능한 빌드를 보장
  - 보안 측면에서 모범 사례 사용
  - 프로덕션 환경에 적합한 이미지 생성
  - 그랄VM을 사용해 네이티브 이미지의 빌드를 지원
- 컨테이너 생성 프로세스는 애플리케이션을 컨테이너하는 방법에 대한 모든 정보를 가지고 있는 빌더 이미지에 의해 조저오딤
  - 애플리케이션의 특정 측면을 전담하는 빌드팩에 의해 제공됨
- 패키토 빌더 컴포넌트는 일련의 기본 빌드팩 시퀀스를 사용해 실제 빌드 작업을 수행
  - 고도로 모듈화되어 있고, 필요에 따라 변경 가능
  - 시퀀스에 새로운 빌드팩을 추가하거나 기존 빌드팩을 교체 다른 빌더 이미지 사용

```groovy
bootBuildImage {
  imageName = "${project.name}"
  environment = ["BP_JVM_VERSION" : "17.*"]
}
```

- 빌드팩이 이미지를 생성하기 위해 수행하는 모든 단계를 확인할 수 있음
- JRE를 추가하고 스프링 부트에서 만든 계층화된 JAR을 사용하는 단계도 포함
- 스프링 부트 2.4 이후로는 스프링 부트 플러그인 설정을 통해 이미지를 컨테이너 저장소로 직접 저장할 수 있음
  - 특정 컨테이너 저장소로 인증하기 위한 설정을 build.gradle 파일에 추가해야 함

```groovy
bootBuildImage {
    imageName = "${project.name}"
    environment = ["BP_JVM_VERSION" : "17.*"]
    
    docker {
        publishRegistry {
            username = project.findProperty("registryUsername")
            password = project.findProperty("registryToken")
            url = project.findProperty("registryUrl")
        }
    }
}
```

- bootBuildImage에 --imageName 인수를 사용하면 컨테이너 저장소가 요구하는 대로 완전한 형식의 이미지 이름을 정의, --publishImage 인수를 사용하면
컨테이너 저장소에 이미지를 직접 푸시한다

```shell
./gradlew bootBuildImage \
--imageName ghcr.io/devch96<username>/catalog-service \
--publishImage
-PregistryUrl="ghcr.io" \
-PregistryUsername=devch96<username> \
-PregistryToken=<PAT>
```

----------

## 도커 컴포즈를 통한 스프링 부트 컨테이너의 관리

- 클라우드 네이티브 빌드팩을 사용하면 도커파일을 직접 작성하지 않고도 스프링 부트 애플리케이션을 효율적으로 컨테이너화 할 수 있음
- 컨테이너를 여러 개 실행하면 도커 CLI가 약간 번거로움
- 도커 컴포즈는 도커 CLI보다 더 나은 경험을 제공
- 명령행 대신 YAML 파일을 통해 실행할 컨테이너와 그 특성을 기술함
- 도커 컴포즈를 사용하면 시스템을 구성하는 모든 애플리케이션과 서비스를 한 곳에서 정의하고 라이프 사이클을 함께 관리할 수 있음

### 도커 컴포즈를 통한 컨테이너 라이프사이클 관리

- docker-compose.yaml 파일의 루트 섹션은 version과 services
  - version은 사용할 구문 지정
  - services는 실행할 모든 컨테이너에 대한 사양을 지정
  - volumne 과 network가 선택사항
  - network 없으면 도커 컴포즈가 자동으로 하나를 만들고 파일의 모든 컨테이너를 그 네트워크에 연결(내장 DNS 사용 가능)
- 모든 배포 관련 스크립트를 별도의 코드베이스에, 별도의 저장소를 통해 모아놓는 것이 좋음

```yaml
version: "3.8" # 도커 컴포즈 구문 버전
services: # 실행할 모든 컨테이너 나열

  catalog-service: # catalog-service 컨테이너 기술 섹션
    depends_on:
      - polar-postgres # polar-postgres 시작 이후에 시작해야 함
    image: "catalog-service" # 컨테이너를 실행하는데 사용할 이미지
    container_name: "catalog-service"
    ports: # 포트 매핑
      - 9001:9001
    environment: # 환경 변수 나열
      - BPL_JVM_THREAD_COUNT=50 # 메모리 계산을 위한 스레드의 수를 설정하는 패키토 빌드팩 환경변수
      - SPRING_DATASOURCE_URL=jdbc:postgresql://polar-postgres:5432/polardb_catalog
      - SPRING_PROFILE_ACTIVE=testdata

  polar-postgres:
    image: "postgres:14.4"
    container_name: "polar-postgres"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=polardb_catalog
```

### 스프링 부트 컨테이너 디버깅

- IDE에서 스프링 부트 애플리케이션을 표준 자바로 실행할 때 디버그 모드로 실행하도록 지정할 수 있음
  - 로컬 자바 프로세스에 디버거를 부착함
- 컨테이너 내에서 실행하면 프로세스가 로컬 컴퓨터에서 실행되지 않기 때문에 IDE가 못함
- 컨테이너 내부의 JVM에게 특정 포트를 통해 디버거 연결을 듣도록 지시
  - BPL_DEBUG_ENABLED
  - BPL_DEBUG_PORT

```yaml
ports:
  - 9001:9001
  - 8001:8001
environment:
  - BPL_JVM_THREAD_COUNT=50
  - BPL_DEBUG_ENABLED=true
  - BPL_DEBUG_PORT=8001
```

-----------

## 배포 파이프라인: 패키지 및 등록

### 커밋 단계에서 릴리스 후보 빌드

- 정적 코드 분석, 컴파일, 단위 테스트, 통합 테스트를 하면 애플리케이션을 실행 가능한 아티팩트로 패키징하고 저장소에 등록해야 함
- 아티팩트는 단 한 번만 생성한다는 것이 지속적 전달의 핵심 아이디어
- 등록된 릴리스 후보는 배포 파이프라인의 다음 단계, 수락 단계에서도 사용

### 깃허브 액션을 통한 컨테이너 이미지 등록

```yaml
name: Commit Stage
on: push

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: devch96/catalog-service
  VERSION: latest

jobs:
  build:
    name: Build and Test
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout source code
        uses: actions/checkout@v3
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: 17
          cache: gradle
      - name: Code vulnerability scanning
        uses: anchore/scan-action@v3
        id: scan
        with:
          path: "${{ github.workspace }}"
          fail-build: false
          severity-cutoff: high
          acs-report-enable: true
      - name: Upload vulnerability report
        uses: github/codeql-action/upload-sarif@v3
        if: success() || failure()
        with:
          sarif_file: ${{ steps.scan.outputs.sarif }}
      - name: Build, unit tests and integration tests
        run: |
          chmod +x gradlew
          ./gradlew build
  package:
    name: Package and Publish
    if: ${{ github.ref == 'refs/heads/main' }}
    needs: [ build ]
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      security-events: write
    steps:
      - name: Checkout source code
        uses: actions/checkout@v3
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: 17
          cache: gradle
      - name: Build container image
        run: |
          chmod +x gradlew
          ./gradlew bootBuildImage \
          --imageName ${{env.REGISTRY}}/${{env.IMAGE_NAME}}:${{env.VERSION}}
      - name: OCI image vulneraility scanning
        uses: anchore/scan-action@v3
        id: scan
        with:
          image:
            ${{env.REGISTRY}}/${{env.IMAGE_NAME}}:${{env.VERSION}}
          fail-build: false
          severity-cutoff: high
          acs-report-enable: true
      - name: Upload vulnerability report
        uses: github/codeql-action/upload-sarif@v2
        if: success() || failure()
        with:
          sarif_file: ${{step.scan.outputs.sarif}}
      - name: Log into container registry
        uses: docker/login-action@v2
        with:
          registry: ${{env.REGISTRY}}
          username: ${{github.actor}}
          password: ${{secrets.GITHUB_TOKEN}}
      - name: Publish conatiner image
        run: docker push
          ${{env.REGISTRY}}/${{env.IMAGE_NAME}}:${{env.VERSION}}
```