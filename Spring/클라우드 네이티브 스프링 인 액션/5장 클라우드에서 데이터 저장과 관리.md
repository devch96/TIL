# 클라우드에서 데이터 저장과 관리

- 상태(state)는 서비스를 종료하고 새로운 인스턴스를 만들 때 보존되어야 하는 모든 것
  
---------

## 클라우드 네이티브 시스템을 위한 데이터 베이스

- 클라우드 네이티브 애플리케이션은 클라우드 자체의 특성으로 인해 상태를 갖지 않도록 설계되고, 컴퓨팅 노드가 여러 다른 클러스터,
지리적 영역 및 클라우드에 걸쳐 흩어져 있게 만든 동적 인프라

### 클라우드에서의 데이터 서비스

- 데이터 서비스는 상태를 저장하고자 설계된 클라우드 네이티브 아키텍처의 구성 요소
- 전통적으로 저장과 관련한 사항은 운영 엔지니어 및 DB 관리자가 처리함
- 클라우드 및 데브옵스 관행에서는 개발자가 애플리케이션의 요구 사항에 가장 적합한 데이터 서비스를 선택
- 애플리케이션 서비스는 상태가 없으므로 컴퓨팅 및 네트워크 리소스를 사용하나 데이터 서비스는 상태를 유지하기 위해 스토리지가 필요

- 적합한 기술을 선택하기 위해 고려해야 할 몇 가지 속성

#### 확장성

- 클라우드 네이티브 애플리케이션은 동적으로 확장 또는 축소됨
- 데이터 서비스도 확장성을 통해 워크로드의 증가나 감소에 적응할 수 있어야 함

#### 복원력

- 애플리케이션과 마찬가지로 실패에 대해 복원력이 있어야 함
- 데이터의 복원력을 높이고 손실을 방지하기 위한 핵심 전략 중 하나는 복제

#### 성능

- 데이터가 복제되는 방식은 성능에 영향을 미칠 수 있음
- 스토리지를 사용하는 데이터 서비스와 비교해 스토리지가 어디에 있는지도 웅요

### PostgreSQL을 컨테이너로 실행

- 관계형 및 비관계형 데이터를 모두 지원

```shell
docker run -d --name polar-postgres \ 컨테이너 이름
-e POSTGRES_USER=user \ 관리자의 사용자 이름
-e POSTGRES_PASSWORD=password \ 관리자 패스워드
-e POSTGRES_DB=polardb_catalog \ 생성할 데이터베이스 이름
-p 5432:5432 \ 데이터베이스를 포트 번호 543로 노출
postgres:14.4 도커 허브에섣 다운로드할 컨테이너 이미지
```

- 컨테이너를 실행하는 도커 이미지를 사용자가 만들지 않고 도커 허브 컨테이너 저장소에서 가져오고, 환경 변수를 컨테이너의 인수로 전달함

-------

## 스프링 데이터에 대한 데이터 지속성 JDBC

- 스프링 데이터는 관게형과 비관계형 데이터베이스에 대한 전용 모둘을 포함함

- 데이터베이스 드라이버
  - 특정 데이터베이스와의 통합을 제공하는 구성 요소
  - JDBC 드라이버를 사용하거나 R2DBC 드라이버를 사용함
  - 비관계형 데이터베이스의 경우 자체 전용 솔루션을 가지고 있음
- 엔티티
  - 데이터베이스에 저장되는 도메인 객체
  - 각 인스턴스를 고유하게 식별하는 필드(기본 키)를 포함해야 하며 전용 애너테이션을 사용해 자바 객체와 데이터베이스 항목 간의 매핑을 설정할 수 있음
- 리포지터리
  - 데이터 저장 및 검색을 위한 추상화
  - 기본 구현을 확장한 모듈을 제공함

### JDBC로 데이터베이스에 연결

- 사용할 특정 데이터베이스에 대한 스프링 데이터 모듈과 필요하다면 데이터베이스 드라이버도 임포트해야 함

```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-stater-data-jdbc'
    runtimeOnly 'org.postgresql:postgresql'
}
```

- 스프링 데이터 JDBC
  - 스프링 데이터 및 JDBC를 사용해 관계형 데이터베이스에 대한 데이터 지속성을 위해 필요한 라이브러리 제공
- PostgreSQL
  - JDBC 드라이버 제공

```yaml
spring:
  datasource:
    username: user
    password: password
    url: jdbc:postgresql://localhost:5432/polardb_catalog
    hikari:
      connection-timeout: 2000
      maximum-pool-size: 5
```


### 스프링 데이터를 통한 지속성 엔티티 정의

- 비즈니스 도메인과 그 복잡성에 따라 도메인 엔티티와 지속성 엔티티를 분리하여 도메인 엔티티를 지속성 엔티티와는 완전히
독립적인 것으로 만들 수도 있음
  - 도메인 중심 설계, 육각형 설계 원칙

#### 도메인 클래스에 지속성 부과

- 스프링 데이터 JDBC는 불가변 엔티티를 사용할 것을 권장하기 때문에 자바 레코드로 엔티티를 모델링하는 것은 바람직한 방법
- 지속성 엔티티에는 객체의 식별자 역할을 하는 필드가 있어야 하며 이 필드가 데이터베이스의 기본 키로 변환됨
- 한 명의 사용자가 기존에 존재하는 객체를 업데이트할 때는 문제가 없으나 동일한 엔티티가 여러 사용자에 의해 동시에 업데이트 된다면
스프링 데이터 JDBC는 문제를 해결하기 위해 낙관적인 잠금을 지원함
  - 사용자는 데이터를 동시에 읽을 수 있음
  - 업데이트 작업을 시도할 때 애플리케이션이 업데이트를 위해 읽은 이후 변경사항이 있는지 확인
  - 변경사항이 있다면 업데이트는 수행되지 않고 예외를 발생함
  - 이 확인 작업은 0부터 카운트를 시작하고 업데이트할 때마다 자동으로 증가하는 숫자 필드를 기반으로 함
  - @Version 애너테이션으로 표시할 수 있음
- @Id 필드가 null 이고 @Version 필드가 0이면 Spring Data JDBC는 새로운 객체라고 가정함

```java
public record Book(
	@Id
	Long id, // 해당 필드를 엔티티에 대한 기본 키로 식별
	@NotBlank(message = "The book ISBN must be defined.")
	@Pattern(
		regexp = "^([0-9]{10}|[0-9]{13})$",
		message = "The ISBN format must be valid."
	)
	String isbn,
	@NotBlank(message = "The book title must be defined.")
	String title,
	@NotBlank(message = "The book author must be defined.")
	String author,
	@NotNull(message = "The book price must be definec.")
	@Positive(
		message = "The book price must be freater than zero."
	)
	Double price,
	
	@Version // 낙관적 잠금을 위해 사용되는 엔티티 버전 번호
	int version
) {
	public static Book of(String isbn, String title, String author, Double price) {
		return new Book(null, isbn, title, author, price, 0);// ID 가 null이고 버전이 0 이면 새로운 엔티티로 인식
	}
}
```

#### 데이터베이스 스키마 생성

- 스프링 데이터는 애플리케이션이 시작할 때 데이터 소스를 초기활 수 있는 기능을 제공함
- schema.sql 파일을 사용해 스키마를 만들고 data.sql 파일을 사용해 새로 만든 테이블에 데이터를 삽입하도록 기본 설정되어 있음


```sql
DROP TABLE IF EXISTS book;
CREATE TABLE book (
    id BIGSERIAL PRIMARY KEY NOT NULL,
    author varchar(255) NOT NULL,
    isbn varchar(255) UNIQUE NOT NULL,
    price float8 NOT NULL,
    title varchar(255) NOT NULL,
    version integer NOT NULL
)
```

```yaml
spring:
  sql:
    init:
      mode: always
```


### JDBC 감사 활성화와 설정

- 데이터를 유지할 때 각 행에 대한 생성 날짜와 마지막으로 수정된 날짜를 알면 유용
- 누가 생성, 언제, 마지막 업데이트 언제, 이런 것들을 데이터베이스 감사(database auditing)이라고 함
- 스프링 데이터 JDBC를 사용하면 설정 클래스에서 @EnableJdbcAuditing 애너테이션을 사용해 모든 지속성 엔티티에 대해 감사를 활성화할 수 있음

```java
@Configuration
@EnableJdbcAuditing
public class DataConfig {
}
```

- 스프링 데이터는 전용 필드를 통해 생성, 변경, 삭제가 일어날 때 마다 메타 데이터의 정보를 받아 엔티티의 일부로 데이터 베이스에 저장할 수 있도록 편리한
애너테이션을 제공함
  - @CreatedBy
    - 생성한 사용자를 나타내는 필드를 표시
    - 생성할 때 값이 저장되고 변경되지 않음
  - @CreatedDate
    - 언제 생성되었는지를 나타내는 필드를 표시
    - 값이 저장되고 변겨오디지 않음
  - @LastModifiedBy
    - 최근 수정한 사용자를 나타내는 필드를 표시
  - @LastModifiedDate
    - 최근 수정한 때를 나타내는 필드를 표시
- 새 객체를 만들 때 해당 필드를 null로 지정할 수 있음
  - 스프링 데이터가 내부적으로 값을 지정함

```java
	@CreatedDate
	Instant createdDate,

	@LastModifiedDate
	Instant lastModifiedDate,
	@Version
	int version
) {
	public static Book of(String isbn, String title, String author, Double price) {
		return new Book(null, isbn, title, author, price, null,null,0);
	}
}
```

### 스프링 데이터의 데이터 리포지터리

- 리포지터리 패턴은 데이터 소스와 독립적으로 데이터에 액세스하기 위한 추상화를 제공
- 비즈니스 로직을 구현하는 도메인 계층은 데이터에 접근할 수만 있다면 그 데이터가 어디서 왔는지는 알 필요가 없음
- 스프링 데이터 리포지터리는 사용 중인 특정 지속성 기술과는 독립적으로 데이터 저장소에서 데이터를 액세스할 수 있게 해줌

#### 데이터 리포지터리의 사용

- 인터페이스를 정의하기만 하면 됨

```java
public interface BookRepository 
        extends CrudRepository<Book, Long> { // 엔티티와 기본 키 유형을 지정하며 CRUD 연산을 제공하는 리포지터리를 확장
	Optional<Book> findByIsbn(String isbn); // 실행 시간에 스프링 데이터에 의해 구현이 제공되는 메서드
	boolean existsByIsbn(String isbn);
	
	@Modifying // 데이터베이스 상태를 수정할 연산임을 나타냄
	@Query("DELETE FROM Book WHERE isbn = :isbn") // 스프링 데이터가 메서드 구현에 사용할 쿼리를 사용
	void deleteByIsbn(String isbn);
}
```

- 애플리케이션이 시작할 때 스프링 데이터는 일반적인 모든 CRUD 작업과 인터페이스에서 선언한 메서드에 대한 구현을 제공함
- 사용자 지정 쿼리를 정의하는 데는 주로 두 가지 옵션이 있음
  - @Query: SQL과 유사한 문을 제공하고 메서드가 이를 실행
  - 구체적인 명명 규칙에 따라 쿼리 메서드를 정의할 수 있음

#### 트랜잭션 콘텍스트 정의

- 스프링 데이터는 리포지터리가 수행하는 모든 작업에 대해 트랜잭션 콘텍스트를 설정함
  - CurdRepository의 모든 메서드는 트랜잭션이 수행됨
- 사용자 정의 쿼리 메서드를 추가할 때는 트랜잭션으로 실행할 것을 명시적으로 지정해야만 트랜잭션으로 처리됨
- 스프링 프레임워크가 제공하는 선언적 트랜잭션 관리를 사용해 클래스 또는 메서드에 애너테이션으로 표시

----------

## 스프링 및 테스트컨테이너로 데이터 지속성 테스트하기

### PostgreSQL을 위한 테스트컨테이너 설정

- 테스트컨테이너는 테스트를 위한 자바 라이브러리로 JUnit을 지원하며 데이터베이스, 메시지 브로커, 웹 서버에 대한 일회용 경량 컨테이너를 제공함
- 프로덕션 환경에서 사용되는 실제 지원 서비스와 동일한 서비스를 테스트에서도 사용할 수 있기에 통합 테스트를 구현하기에 완벽

```groovy
ext {
    set('testcontainersVersion', '1.17.3')
}

dependencies {
    testImplementation 'org.testcontainers:postgresql'
}

dependencyManagement {
    imports {
        mavenBom "org.textcontainers:testcontainers-bom:${testcontainersVersion}"
    }
}
```

- 테스트를 실행할 때는 애플리케이션이 spring.datasource.url 속성을 통해 설정한 데이터베이스 대신 테스트컨테이너가 제공한
PostgresSQL 인스턴스를 사용해야 함
- 새로운 속성값 지정(프로필 지정)

```yaml
spring:
  datasource:
    url: jdbc:tc:postgresql:14.4:///
```

### @DataJdbcTest 및 테스트컨테이너를 통한 데이터 지속성 테스트

- @DataJdbcTest로 인해 스프링 부트는 모든 스프링 데이터 JDBC 엔티티 및 리포지터리를 애플리케이션 컨텍스트로 로드함
- JdbcAggregateTemplate를 자동으로 설정하는데 각 테스트 케이스에 대한 콘텍스트를 설정할 때 리포지터리 대신 사용할 수 있는 하위 레벨의 객체

```java
@DataJdbcTest // 스프링 데이터 JDBC 컴포넌트를 집중적으로 테스트하는 클래스임을 나타냄
@Import(DataConfig.class) // 데이터 설정을 임포트(감사를 활성화하기 위해 필요)
@AutoConfigureTestDatabase( // 테스트컨테이너를 이용해야 하기 때문에 내장 테스트 데이터베이스 사용을 비활성화
	replace = AutoConfigureTestDatabase.Replace.NONE
)
@ActiveProfiles("integration") // integration 프로필 활성화
public class BookRepositoryJdbcTests {
	@Autowired
	private BookRepository bookRepository;

	@Autowired
	private JdbcAggregateTemplate jdbcAggregateTemplate; // 데이터베이스와 상호작용하기 위한 하위 수준 객체

	@Test
	void findBookByIsbnWhenExisting() {
		var bookIsbn = "1234561237";
		var book = Book.of(bookIsbn, "Title", "Author", 12.90);
		jdbcAggregateTemplate.insert(book);
		Optional<Book> actualBook = bookRepository.findByIsbn(bookIsbn);

		assertThat(actualBook).isPresent();
		assertThat(actualBook.get().isbn()).isEqualTo(book.isbn());
	}
}

```

### @SpringBootTest 및 테스트컨테이너를 이용한 통합 테스트

- 테스트컨테이너 설정은 integration 프로파일이 활성화된 모든 자동 테스트에 적용됨

-----------

## 플라이웨이를 통한 프로덕션 환경에서의 데이터베이스 관리

- 자바 생태계에서 데이터베이스 변경 사항의 추적, 버전 관리 및 배포를 위해 가장 많이 사용되는 두 가지 도구는 플라이웨이와 리퀴베이스

### 플라이웨이 이해: 데이터베이스 버전 관리

- 플라이웨이는 데이터베이스에 대한 버전 관리를 제공하는 도구로 데이터베이스 상태 버전에 대한 단일 진실 원천을 제공하고 변경 사항을 점진적으로 추적함
- 데이터베이스 변경을 자동화하고 데이터베이스의 상태를 재생하거나 롤백할 수 있음
- 플라이웨이는 처음 실행할 때 데이터베이스에 자동으로 생성환 flyway_schema_history 테이블을 통해 이미 적용된 마이그레이션 정보를 
저장하고 추적 관리함
- 스프링 부트에 통합해서 사용하는 경우는 src/main/resources/db/migration 폴더에서 SQL 마이그레이션을 검색하고 src/main/java/db/migration에서
자바 마이그레이션을 검색함

```groovy
dependencies {
  implementation 'org.flywaydb:flyway-core'
}
```

### 플라이웨이를 이용한 데이터베이스 스키마 초기화

- 플라이웨이에서 SQL 마이그레이션 파일의 이름은 특정 명명 패턴을 준수해야 함
- 접두사
  - 버전 마이그레이션은 V를 사용
- 버전
  - 점이나 밑줄을 통해 여러 부분으로 구분되는 버전 번호
- 구분자
  - 두 개의 밑줄
- 설명
  - 밑줄로 구분되는 하나 이상의 단어
- 접미사
  - .sql
- 플라이웨이가 데이터베이스 스키마의 변경 사항을 관리하면 버전 관리의 모든 이점을 얻을 수 있음

### 플라이웨이를 이용한 데이터베이스 진화

- V2로 생성하면 V1은 이미 적용되었기 때문에 이후 변경 사항을 적용함
