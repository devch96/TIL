# 이벤트 중심 애플리케이션과 함수

- 이벤트 중심 아키텍처는 이벤트를 생성하고 소비함으로써 상호작용하는 분산 시스템을 일컫음
  - 상호작용은 비동기적이기 때문에 시간적 결합의 문제를 해결

-------

## 이벤트 중심 아키텍처

- 이벤트는 무언가 일어난 하나의 사건
  - 상태의 변화와 같이 시스템 내에서 일어난 일과 관련이 있으며 다른 많은 이벤트의 원인이 될 수 있음
- 이벤트가 발생하면 이벤트에 대해 관련 당사자에게 통지할 수 있음
- 이벤트 알림은 일반적으로 메시지를 통해 이뤄지는데 메시지는 이벤트를 데이터로 표현한 것
- 이벤트 중심 아키텍처에는 이벤트 생산자와 이벤트 소비자가 있음
  - 생산자는 이벤트를 감지하고 알림을 보내는 역할
  - 소비자는 특정 이벤트가 발생했을 때 알림을 받는 구성 요소
- 생산자와 소비자는 서로를 알지 못한 채 독립적으로 실행
  - 생산자는 이벤트 브로커가 운영하는 채널에 메시지를 발행함으로써 이벤트가 발생했음을 알림
  - 채널은 메시지를 수집하고 소비자에게 라우팅하는 역할을 수행
- 이벤트 처리 및 분배를 자체적으로 수행하는 브로커를 사용하면 생산자와 소비자는 둘 사이의 결합을 최소한으로 유지할 수 있음

### 이벤트 중심 모델 이해

- 발행자/구독자 모델
  - 구독을 기반
  - 생산자는 이벤트를 소비할 모든 구독자에게 보내어질 이벤트를 발행
  - 이벤트를 일단 받고 나면 재생할 수 없기 때문에 새로 가입한 소비자는 과거의 이벤트를 받지 못함
- 이벤트 스트리밍 모델
  - 이벤트는 로그에 기록됨
  - 생산자는 발생하는 순서대로 이벤트를 저장
  - 소비자는 가입하지 않더라도 이벤트 스트림의 어느 부분이라도 읽을 수 있음
  - 언제든지 가입할 수 있고 과거의 모든 이벤트를 받을 수 있음
- 이벤트 중심 아키텍처의 핵심은 이벤트를 처리하고 라우팅할 수 있는 플랫폼
  - 래빗MQ는 발행자/구독자 모델에서 흔히 사용됨
  - 아파치 카프카는 이벤트 스트림 처리를 위한 강력한 플랫폼

### 발행자/구독자 모델의 사용

- 주문이 접수되면
  - 주문 서비스는 주문을 생성하고 이 이벤트를 관심 있는 구독자에게 알려야 함
  - 배송 서비스는 주문을 발송하기 위해 몇 가지 논리를 실행해야 함
- 주문이 발송되면
  - 배송 서비스는 주문 발송 이벤트에 관심 있는 구독자에게 알려야 함
  - 주문 서비스는 데이터베이스의 주문 상태를 업데이트해야 함
- 이 디자인의 장점은 기존 시스템에 전혀 영향을 미치지 않고도 소프트웨어 시스템을 개선시켜 나가고 더 많은 애플리케이션을 추가할 수 있다는 점
  - 주문을 받을때마다 사용자에게 이메일을 보내는 메일 서비스를 추가할 수 있는데 주문 서비스는 이에 대해 모름
  - 이벤트 생성만 할 뿐 구독하는지는 관심이 없음

---------

## 메시지 브로커와 래빗MQ

- 메시징 시스템에는 메시지 브로커와 프로토콜이라는 두 가지 요소가 필요
- 고급 메시지 큐잉 프로토콜은 플랫폼 간의 호환성과 안정적인 메시지 전달을 보장
  - AMQP(Advanced Message Queuing Protocol)
- 스프링 프레임 워크 자체적으로 JMS(Java Message Service) API를 기존적으로 지원
- 스프링 AMQP 프로젝트는 AMQP에 대한 지원을 추가하고 래빗MQ와의 통합을 제공함

### 메시징 시스템의 AMQP 이해

- 래빗MQ와 같은 AMQP 기반 솔루션을 사용할 때 상호작용에 관여하는 행위자는 다음과 같음
  - 생산자(producer): 메시지를 보내는 개체(발행자)
  - 소비자(consumer): 메시지를 받는 개체(구독자)
  - 메시지 브로커: 생산자로부터 메시지를 받아 소비자에게 라우팅하는 미들웨어
- AMQP 메시징 모델은 익스체인지(exchange)와 큐(queue)를 기반으로 함
  - 생산자는 익스체인지에 메시지를 보냄
  - 래빗MQ는 주어진 라우팅 규칙에 따라 어떤 큐가 메시지 사본을 받을지 계산함
  - 소비자는 큐에서 메시지를 읽음
- AMQP 프로토콜에서 메시지는 속성과 페이로드로 이루어짐
- AMQP는 몇 가지 속성을 정의하지만 메시지를 올바르게 라우팅하는 데 필요한 정보를 전달하기 위해 사용자 정의 속성을 추가할 수 있음
- 페이로드는 이진형식이어야 하며 제약 조건이 없음(애플리케이션이 사용)

### 발행/구독 통신을 위한 래빗MQ 사용

- docker-compose.yaml

```yaml
polar-rabbitmq:
image: "rabbitmq:3.10-management"
container_name: "polar-rabbitmq"
ports:
  - 5672:5672
  - 15672:15672
volumes:
  - ./rabbitmq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf
```

- rabbitmq.conf

```text
default_user = user
default_pass = password
```

-----------------

## 스프링 클라우드 함수를 통한 함수

- 스프링 클라우드 함수는 자바 8에서 도입된 Supplier, Function, Consumer 라는 표준 인터페이스를 기반으로 한 함수를 통해 비즈니스 로직을 구현할 것을 권장
- 공급자(supplier): 출력만 있고 입력이 없는 함수
  - 생산자(producer), 발행자(publisher), 원천(source) 이라고도 함
- 함수(function): 입력과 출력을 모두 가지고 있음
  - 프로세서(processor)라고도 함
- 소비자(consumer): 입력만 있고 출력은 없는 함수
  - 구독자(subscriber) 또는 싱크(sink)라고도 함

### 스프링 클라우드 함수의 함수적 패러다임 사용

- 주문 발송을 위해 수행하는 두 가지 작업
  - pack 함수: 접수한 주문의 아이디를 입력으로 받아 주문 물품을 포장하고 주문의 아이디를 출력으로 반환하는데 이 주문은 레이블을 붙일 준비가 된 상태
  - label 함수: 포장된 주문의 아이디를 입력으로 받아 주문에 대해 레이블 처리를 하고 주문 아이디를 출력함으로써 발송을 완료함

#### 스프링 클라우드 함수 프로젝트 초기화

- build.gradle

```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    implementation 'org.springframework.cloud:spring-cloud-function-context'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 함수를 사용한 비즈니스 로직 구현

- 비즈니스 로직은 자바의 Function 인터페이스를 통해 표준적인 방식으로 구현할 수 있음
  - 스프링 필요 없음

```java
public class DispatchingFunctions {
	private static final Logger log = LoggerFactory.getLogger(DispatchingFunctions.class);

	public Function<OrderAcceptedMessage, Long> pack() {
		return orderAcceptedMessage -> { // OrderAcceptedMessage 객체를 입력으로 받음
			log.info("The order with id {} is packed.",
				orderAcceptedMessage.orderId());
			return orderAcceptedMessage.orderId(); // 주문의 식별자를 출력으로 반환
		};
	}
}
```

- 함수가 어떠한 다양한 방식으로 정의되더라도 표준 자바 인터페이스인 Function, Supplier, Consumer를 준수하는 한 스프링 클라우드 함수는
그 함수를 관리할 수 있음

```java
@Configuration
public class DispatchingFunctions {
	private static final Logger log = LoggerFactory.getLogger(DispatchingFunctions.class);

	@Bean
	public Function<OrderAcceptedMessage, Long> pack() {
		return orderAcceptedMessage -> {
			log.info("The order with id {} is packed.",
				orderAcceptedMessage.orderId());
			return orderAcceptedMessage.orderId();
		};
	}
}
```

- 빈으로 등록된 함수는 스프링 클라우드 함수 프레임워크에 의해 추가 기능을 갖게 됨

#### 명령형 및 리액티브 함수의 사용

- 스프링 클라우드 함수는 명령형 및 리액티브 코드를 모두 지원하므로 리액티브 API를 자유롭게 사용해 함수를 구현할 수 있음

```java
@Configuration
public class DispatchingFunctions {
	private static final Logger log = LoggerFactory.getLogger(DispatchingFunctions.class);
    
	@Bean
	public Function<Flux<Long>, Flux<OrderDispatchMessage>> label() {
		return orderFlux -> orderFlux.map(orderId -> {
			log.info("The order with id {} is labeled.", orderId);
			return new OrderDispatchMessage(orderId);
		});
	}
}
```

### 함수의 합성 및 통합: REST, 서버리스, 데이터 스트림

- 배송에 대한 요구 사항을 환기하면 주문의 배송은 먼저 pack(), 그 다음은 label()의 순서로 실행되는 두 단계로 구성됨
- 자바는 andThen()이나 compose()를 사용해 Function 객체를 순서대로 합성하는 기능을 제공함
  - 첫 번째 함수의 출력 유형이 두 번째 함수의 입력 유형과 같을 때만 사용할 수 있음
- 스프링 클라우드는 해결책을 제공하며 명령형 함수와 리액티브 함수 사이의 서로 다른 입출력 타입을 내부적으로 변환을 수행해 함수 합성을 원할하게 해줌

- application.yaml

```yaml
spring:
  cloud:
    function:
      definition: pack|label
```

- spring.cloud.function.definition 속성을 사용하면 스프링 클라우드 함수가 관리하고 통합할 함수를 선언하고 특정 데이터 흐름을 생성함
- 표준 자바 함수만 구현하면 스프링 클라우드 함수가 함수를 그 자체로 사용하거나, 합성해서 사용하도록 설정할 수 있음
- 함수를 정의한 다음에는 프레임워크가 사용자의 필요에 따라 다양한 방식으로 함수를 노출할 수 있음
  - definition에 정의된 함수를 자동으로 REST 엔드포인트로 노출할 수 있음
  - 애플리케이션을 패키징하고 FaaS 플랫폼으로 배포만 하면 서버리스 스프링 부트 애플리케이션

### @FunctionalSpringBootTest를 통한 통합 테스트

- 함수형 프로그래밍 패러다임을 사용하면 표준 자바로 비즈니스 로직을 구현하면서 JUnit으로 단위 테스트를 작성할 수 있음
  - 스프링 코드가 없으며 일반적 자바 코드만 존재
- 각 함수가 작동하는지 확인 후 스프링 클라우드 함수가 함수를 처리하고 설정한 대로 노출될 때 애플리케이션의 전반적인 작동을 확인하기 위해
통합테스트가 필요
- 스프링 클라우드 함수는 통합 테스트의 콘텍스트를 설정하는 데 사용할 수 있는 @FunctionalSpringBootTest 애너테이션을 제공
  - 함수를 직접 호출하지 않고 프레임워크로부터 해당 함수를 제공받음
  - 프레임워크가 관리하는 모든 함수는 함수 레지스트리 역할을 하는 FunctionCatalog 객체를 통해 사용할 수 있음

- build.gradle

```groovy
dependencies {
  testImplementation 'io.projectreactor:reactor-test'
}
```

```java
@FunctionalSpringBootTest
class DispatchingFunctionsIntegrationTests {
	@Autowired
	private FunctionCatalog catalog;

	@Test
	void packAndLabelOrder() {
		Function<OrderAcceptedMessage, Flux<OrderDispatchedMessage>>
			packAndLabel = catalog.lookup(Function.class, "pack|label");
		long orderId = 121;

		StepVerifier.create(packAndLabel.apply(new OrderAcceptedMessage(orderId)))
			.expectNextMatches(dispatchedOrder ->
				dispatchedOrder.equals(new OrderDispatchedMessage(orderId)))
			.verifyComplete();
	}
}
```

-------

## 스프링 클라우드 스트림을 통한 메시지 처리

- 스프링 클라우드 스트림은 확장 가능한 이벤트 기반 스트리밍 애플리케이션을 구축하기 위한 프레임워크
  - 스프링 통합, 스프링 부트, 스프링 클라우드 함수를 토대로 하고 있음
  - 스프링 통합은 메시지 브로커와 통신 계층을 제공
  - 스프링 부트는 미들웨어 통합을 위한 자동 설정 제공
  - 스프링 클라우드 함수는 이벤트를 생성하고 처리하며 소비함
- 스프링 클라우드 스트림 기능 중 가장 훌륭한 기능은 배송 서비스와 같은 프로젝트에서 의존성을 제거하고 함수를 외부 메시지 브로커에 자동으로
바인딩할 수 있는 기능
  - 애플리케이션의 코드 변경 없이 application.yaml 설정만 변경하면 됨

### 래빗MQ와의 통합 설정

- 스프링 클라우드 스트림은 몇 가지 필수적인 개념을 기반으로 함
  - 대상 바인더(destination binder): 래빗MQ나 카프카 같은 외부 메시지 시스템과의 통합을 제공하는 컴포넌트
  - 대상 바인딩(destination binding): 외부 메시지 시스템 개채(큐나 토픽)와 애플리케이션의 생산자/소비자를 연결해주는 요소
  - 메시지: 대상 바인더, 외부 메시지 시스템과 통신하기 위해 애플리케이션의 생산자와 소비자가 사용하는 데이터 구조
- 애플리케이션의 핵심인 비즈니스 로직은 외부 메시징 시스템을 알지 못함

#### 스프링과 래빗MQ의 통합

```java
dependencies {
    implementation 'org.springframework.cloud:spring-cloud-stream-binder-rabbit'
}
```

- 스프링 클라우드 스트림에 스프링 클라우드 함수, 스프링 부트 스타터가 포함되어 있기 때문에 제거할 수 있음

```yaml
spring:
  rabbitmq:
  host: localhost
  port: 5672
  username: user
  password: password
  connection-timeout: 5s
```

### 함수의 메시지 채널 바인딩

- 스프링 클라우드 스트림은 스프링 부트 애플리케이션에게 대상 바인더를 제공하는데, 대상 바인더는 외부 메시징 시스템을 통합함
- 대상 바인더는 애플리케이션의 생산자/소비자와 메시징 시스템의 개체 간의 통신 채널을 설정하는 데에도 중요한 역할을 수행함
- 통신 채널을 대상 바인딩이라고 하며 애플리케이션과 브로커를 이어줌
- 대상 바인딩은 입력 채널 또는 출력 채널이 될 수 있음

#### 대상 바인딩의 이해

- 스프링 클라우드 스트림에서 함수 프로그래밍 모델을 사용하면 입력 데이터를 받는 함수에 대해서는 입력 바인딩이, 출력 데이터를 반환하는 함수에 대해서는
출력 바인딩이 생성됨
  - 입력 바인딩: functionName + -in- + index
  - 출력 바인딩: functionName + -out- + index
- 카프카에서처럼 파티션을 사용하지 않는 한 이름의 index 부붙은 항상 0
- functionName은 spring.cloud.function.definition 속성 값으로 계산 됨
- 단일 함수의 경우 일대일로 매핑됨
  - dispatch라는 함수가 있을 경우 dispatch-in-0, dispatch-out-0
- 이 이름들은 스프링 클라우드 스트림에만 존재하고 래빗MQ는 전혀 모름

#### 대상 바인딩 설정

- 프로덕션 환경에서는 여러 가지 이유로 기본 설정에 따른 값이 아닌 다른 이름을 사용할 필요가 있을 수도 있음
  - 같은 이름의 익스체인지와 큐가 이미 존재할 경우
  - 내구성이나 라우팅 알고리즘과 같이 익스체인지와 큐에 대한 다양한 옵션을 제어해야 할 경우

```yaml
spring:
  cloud:
    stream:
      bindings:
        packlabel-in-0: # 입력 바인딩
          destination: order-accepted # 바인더를 연결할 대상의 브로커 내에서의 실제 이름(익스체인지)
          group: ${spring.application.name}
        packlabel-out-0: # 출력 바인딩
          destination: order-dispatched
```

- 익스체인지와 큐가 래빗MQ에 아직 존재하지 않으면 바인더에 의해 상성됨
- 표준 발행/구독 모델에서 모든 소비자는 자신이 구독한 큐로 전송된 메시지의 사본을 받는데, 메시지가 여러 애플리케이션에 의해 처리되어야 할 때 편리한 기능
  - 확장성과 복원력을 위해 애플리케이션 인스턴스를 여러 개 실행하는 클라우드 네이티브에서는 오히려 문제가 될 수 있음
  - 배송 서비스 인스턴스가 여러 개 있을 때 같은 주문에 대해 모든 인스턴스가 주문 배송을 처리하면 안됨
- 소비자 그룹은 같은 그룹에 속한 소비자는 구독을 공유하고 그 결과 메시지가 큐에 들어오면 그 큐를 구독하는 소비자 그룹 중 오직 하나의 소빚마ㅏㄴ
그 메시지를 처리함

#### 래빗MQ 익스체인지 및 큐

```shell
docker-compose up -d polar-rabbitmq
./gradlew bootRun
```

- 스프링 클라우드 스트림은 익스체인지를 packlabel-in-0 과 packlabel-out-0 바인딩에 각각 매핑
  - order-accepted, order-dispatched
- 익스체인지는 지속성을 가질 수 있는데 이 경우 관리 콘솔에서 D 아이콘으로 표시되고, 브로커를 재시작해도 익스체인지에 대한 메시지는 그대로 남아있음
- 배송 서비스에서 packlabel-in-0 바인딩과 소비자 그룹을 설정했고, 애플리케이션에서 유일한 입력 채널이기 때문에 큐가 하나 생성되어 있음
  - order-accepted.dispatcher-service
- order-accepted 익스체인지에 메시지를 발행하고 주문이 배송될 때마다 order-dispatched 큐에서 메시지를 읽는 소비자를 주문 서비스에 정의하면 흐름이 완성됨

### 테스트 바인더를 통한 통합 테스트

- 스프링 클라우드 함수와 스프링 클라우드 스트림의 전체 철학은 애플리케이션의 비즈니스 로직을 인프라와 미들웨어에 중립적이 되도록 하는 것
  - pack()과 label() 함수를 정의한 후 그래들에서 의존성을 업데이트하고 yaml 설정을 수정한 것이 전부
- 프레임워크에 관계없이 비즈니스 로직을 검증하기 위한 단위 테스트를 작성하는 것은 좋은 생각이나 스프링 클라우드 스트림의 맥락에서
애플리케이션의 작동을 확인하기 위해 통합 테스트를 추가하는 것 역시 가치가 있음

```groovy
dependencies {
  testImplementation("org.springframework.cloud:spring-cloud-stream") {
    artifact {
      name = "spring-cloud-stream"
      extension = "jar"
      type = "test-jar"
      classifier = "test-binder"
    }
  }
}
```

- 테스트는 세 단계로 이루어짐
  - 테스트 바인더에 대한 설정을 제공하는 TestChannelBinderConfiguration 클래스를 임포트
  - 입력 바인딩 packlabel-in-0 을 나타내는 InputDestination 빈을 주입
  - 출력 바인딩 packlabel-out-0 을 나타내는 OutputDestination 빈을 주입
- 데이터 흐름은 Message(org.springframework.messaging) 객체를 기반으로 함

```java
@SpringBootTest
@Import(TestChannelBinderConfiguration.class)
class FunctionsStreamIntegrationTests {
	@Autowired
	private InputDestination input;
	@Autowired
	private OutputDestination output;
	@Autowired
	private ObjectMapper objectMapper;

	@Test
	void whenOrderAcceptedThenDispatched() throws IOException {
		final long orderId = 121;
		Message<OrderAcceptedMessage> inputMessage = MessageBuilder
			.withPayload(new OrderAcceptedMessage(orderId)).build();
		Message<OrderDispatchedMessage> expectedOutputMessage = MessageBuilder
			.withPayload(new OrderDispatchedMessage(orderId)).build();

		this.input.send(inputMessage);
		assertThat(objectMapper.readValue(output.receive().getPayload(),
			OrderDispatchedMessage.class))
			.isEqualTo(expectedOutputMessage.getPayload());
	}
}
```

- 래빗MQ 같은 메시지 브로커는 이진 데이터를 처리하므로 모든 데이터는 자바의 byte[]에 매핑됨
- 바이트와 DTO간의 변환은 스프링 클라우드 스트림에서 내부적으로 알아서 처리해줌
- 출력 채널에서 수신된 메시지의 내용을 확인하려면 명시적으로 처리해야 함

### 실패에 대한 메시지 복원력

- 동기식 요청/응답 방식은 상호작용에 영향을 미치는 문제점이 몇 가지 있는데 이벤트 기반 아키텍처는 이에 대한 해결책을 제공함
  - 애플리케이션 간의 시간적 결합을 제거하면 통신은 비동기적으로 이루어지기 때문에 회로 차단기와 같은 패턴이 필요 없음
  - 생산자가 메시지를 보내는 동안 소비자가 일시적으로 사용할 수 없는 상태에 있다고 해도 문제가 되지 않음
  - 소비자가 다시 작동하면 메시지를 받기 때문
- 스프링 클라우드 스트림은 보다 복원력 높은 상호작용을 위해 오류 채널과 우아한 종료를 포함해 몇 가지 기본 설정값을 정의함
- 데드 레터 큐, 메시지 수신 확인 흐름, 실패시 메시지 재발행 등 메시지 처리에서 고려할 수 있는 다양한 측면을 설정함
- 래빗MQ 자체에도 안정성과 복원력을 향상하기 위한 기능이 있는데 각 메시지가 적어도 한 번 이상 전달되도록 보장하는 기능이 있음
  - 애플리케이션의 소비자가 동일한 메시지를 받을 수 있기 때문에 주의해야 함
  - 비즈니스 로직에서 중복을 식별하고 처리하는 방법을 알아야 함

--------

## 스프링 클라우드 스트림을 통한 메시지 생성 및 소비

### 이벤트 소비자 구현 및 멱등성 문제

- 배송 서비스 애플리케이션은 주문의 배송이 이뤄지면 메시지를 생성함
- 데이터베이스에서 이 주문의 상태를 업데이트하려면 주문 서비스는 이 사실을 통보받아야 함

```java
public record OrderDispatchedMessage(
	Long orderId
)
{}

@Configuration
public class OrderFunctions {

  private static final Logger log = LoggerFactory.getLogger(OrderFunctions.class);

  @Bean
  public Consumer<Flux<OrderDispatchedMessage>> dispatchOrder(OrderService orderService) {
    return flux ->
            orderService.consumeOrderDispatchedEvent(flux)
                    .doOnNext(order -> log.info("The order with id {} is dispatched", order.id()))
                    .subscribe();
  }
}

@Service
public class OrderService {
  private final BookClient bookClient;
  private final OrderRepository orderRepository;

  public OrderService(BookClient bookClient, OrderRepository orderRepository) {
    this.bookClient = bookClient;
    this.orderRepository = orderRepository;
  }
  
  public Flux<Order> consumeOrderDispatchedEvent(Flux<OrderDispatchedMessage> flux) {
    return flux.flatMap(message -> orderRepository.findById(message.orderId()))
            .map(this::buildDispatchedOrder)
            .flatMap(orderRepository::save);
  }

  private Order buildDispatchedOrder(Order existingOrder) {
    return new Order(
            existingOrder.id(),
            existingOrder.bookIsbn(),
            existingOrder.bookName(),
            existingOrder.bookPrice(),
            existingOrder.quantity(),
            OrderStatus.DISPATCHED,
            existingOrder.createdDate(),
            existingOrder.lastModifiedDate(),
            existingOrder.version()
    );
  }
}
```

### 이벤트 생성자 구현과 원자성 문제

- 공급자는 메시지의 발원지
  - 이벤트가 발생하면 메시지를 생성함
- 주문 서비스에서 주문을 접수할 때마다 공급자는 이해 당사자(이 경우 배송 서비스)에게 통보해야 함
- 함수나 소비자와는 달리 공급자는 명시적으로 활성화해야 사용할 수 있음
  - 호출해야 동작함
- 스프링 클라우드 스트림에는 공급자를 정의하고 다양한 시나리오를 다룰 수 있는 방법이 많음
  - 이벤트 소스는 메시지 브로커가 아니라 REST 엔드포인트

```java
public record OrderAcceptedMessage(
	Long orderId
) {}


@Service
public class OrderService {
  private static final Logger log = LoggerFactory.getLogger(OrderService.class);
  private final BookClient bookClient;
  private final OrderRepository orderRepository;
  private final StreamBridge streamBridge;

  public OrderService(BookClient bookClient, OrderRepository orderRepository, StreamBridge streamBridge) {
    this.bookClient = bookClient;
    this.orderRepository = orderRepository;
    this.streamBridge = streamBridge;
  }

  @Transactional
  public Mono<Order> submitOrder(String isbn, int quantity) {
    return bookClient.getBookByIsbn(isbn)
            .map(book -> buildAcceptedOrder(book, quantity))
            .defaultIfEmpty(
                    buildRejectedOrder(isbn, quantity))
            .flatMap(orderRepository::save)
            .doOnNext(this::publishOrderAcceptedEvent);
  }

  private void publishOrderAcceptedEvent(Order order) {
    if (!order.status().equals(OrderStatus.ACCEPTED)) {
      return;
    }

    var orderAcceptedMessage = new OrderAcceptedMessage(order.id());
    log.info("Sending order accepted event with id: {}", order.id());
    var result = streamBridge.send("acceptOrder-out-0", orderAcceptedMessage);
    log.info("Result of sending data for order with id {}: {}", order.id(), result);
  }
}
```