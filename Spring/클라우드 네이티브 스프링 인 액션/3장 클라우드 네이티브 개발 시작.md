# 클라우드 네이티브 개발 시작

## 클라우드 네이티브 프로젝트 부트스트래핑

- 애플리케이션을 부트스트랩할 때 몇가지 실용적인 지침이 15요소 방법론에 있다
  - 하나의 코드베이스, 하나의 애플리케이션
  - 의존성 관리

### 하나의 코드베이스, 하나의 애플리케이션

- 클라우드 네이티브 애플리케이션은 깃과 같은 형상 관리 시스템을 통해 단일한 코드베이스로 관리해야 함
- 각 코드베이스는 여러 환경에 배포할 수 있는 불가변 아티팩트(build)를 생성해야 함
- 환경에 종속적인 모든 설정은 애플리케이션 코드베이스의 외부에 있어야 함
- 어떠 코드가 두 개 이상의 애플리케이션에서 필요하다면 해당 코드는 독립적인 서비스나 의존성 라이브러리로 분리해야함
- 각 코드베이스는 하나의 애플리케이션ㅇ을 가져야하지만 코드 저장소에 대해서는 따로 언급이 없음
  - 편한대로

### 그래들과 메이븐의 의존성 관리

- 래퍼 스크립트를 사용하면 프로젝트의 모든 팀원들과 자동화된 도구가 동일한 버전의 그래들 또는 메이븐을 사용할 수 있음
- 스프링 이니셜라이저를 통해 프로젝트를 새로 만들 때 바로 사용 가능한 래퍼 스크립트가 포함되어 있기 때문에 별도로 다운할 필요 없음
  - ./gradlew
- 애플리케이션에 필요한 모든 의존성 라이브러리는 자동 생성된 build.gradle에 열거되어 있음

--------

## 임베디드 서버로 작업

- 전통적인 웹 애플리케이션은 WAR 또는 EAR 파일로 패키징한 후에 톰캣과 같은 웹 서버나 와일드플라이 같은 애플리케이션 서버에 배포함
- 서버에 대한 외부 의존성을 갖게 되면 애플리케이션 자체의 이식성과 발전을 제한하고 유지 보수 비용이 늘어남

### 실행 가능한 JAR 및 임베디드 서버

- 전통적으로는 애플리케이션 서버나 독립형 웹 서버가 사용됨
  - 프로덕션 환경에서 설정과 유지 비용이 높았기 때문에 효율성을 위해 여러 개의 애플리케이션을 패키징하여 배포
  - 서버 수준에서 무언가 변경해야 한다면 다른 팀과 조정되고 모든 애플리케이션에 적용되기 때문에 변경에 제한이 따름
  - 컴퓨터에서 사용할 수 있는 서버의 유형에 따라 달라질 수 있기 때문에 다양한 환경에 대한 이식성이 제한됨
- 스프링 부트는 서버 기능을 내장함으로써 외부 의존성을 제거하고 애플리케이션을 독립 실행형으로 만드는데 일조함
  - 톰캣 서버가 미리 설정되어 번들로 제공되지만 언더토나 제티 혹은 네티로 대체할 수 있음
- JVM 생태계에서 클라우드 네이티브 애플리케이션은 JAR 아티팩트로 패키징됨
- 스프링 부트는 JAR 및 WAR 유형의 패키지가 둘 다 가능함
- 클라우드 네이티브 애플리케이션의 경우 팻 JAR(fat-JAR) 혹은 우버 JAR(uber-JAR)이라고 부르는 독립적 JAR을 사용하는데 이 안에는 애플리케이션,
의존성 라이브러리 및 임베디드 서버가 모두 포함되어 있음

```shell
./gradlew bootJar
java -jar build/libs/catalog-service-0.0.1-SNAPSHOT.jar
```

### 요청당 스레드 모델 이해

- 클라이언트는 서버로 HTTP 요청을 보내고 서버는 계산을 수행한 후에 HTTP 응답을 클라이언트에게 보내줌
- 톰캣과 같은 서블릿 컨테이너에서 실행되는 웹 애플리케이션은 요청당 스레드라는 모델을 기반으로 요청을 처리함
  - 각 요청에 대해 애플리케이션은 해당 특정 요청을 처리하는데만 전념할 스레드를 할당하고 요청에 대한 응답이 클라이언트에 반환될 때까지 이 스레드는 오직
  그 목적으로만 사용되고 다른 목적으로는 사용하지 않음
  - 데이터베이스 읽기가 필요한 경우 데이터베이스에서 데이터를 받을 때까지 스레드는 다른 일을 하지 않고 기다리기만 함
- 톰캣은 스레드 풀을 초기화해서 가지고 있는데 모든 HTTP 요청은 이 스레드 풀을 통해 관리함
  - 톰캣의 스레드 수는 동시에 들어오는 요청을 지원할 수 있는 상한선
- DispatcherServlet은 요청 처리르 위한 진입점 역할을 수행함
  - 클라이언트가 특정 URL 패턴으로 새로운 HTTP 요청을 보내면 DispatcherServlet은 HandlerMapping에게 해당 엔드포인트를 담당하는
  컨트롤러를 요청하고 주어진 컨트롤러에게 요청을 실제 처리해줄 것을 요청함
  - 컨트롤러는 다른 서비스를 호출하여 요청을 처리한다음 DispatcherServlet에 응답을 반환하고 최종적으로 클라이언트에게 HTTP 응답이 보내짐

### 내장 톰캣 설정

- 톰캣은 모든 스프링 부트 웹 애플리케이션에 기본 설정으로 포함되어 있는 서버
- 프로덕션 환경의 경우 특정 요구 사항을 위해 톰캣의 작동을 사용자 지정 변경해야 할 수 있음
- application.properties 또는 application.yaml 파일을 통해 속성을 정의할 수 있음
  - .properteis 파일의 형식은 키-값 쌍
  - .yaml파일은 YAML 형식 사용

#### HTTP 포트

```yaml
server:
  port: 9001
```

#### 연결 타임아웃

- server.tomcat.connection-timeout 속성은 클라이언트에서 TCP 연결을 수락하고 실제로 HTTP 요청을 받기까지 톰캣이 최대한 기다리는 시간을 정의
  - 서비스 거부 공격 (denial-of-service attack, DoS)
- 기본 설정값은 20초인데 일반적인 클라우드 네이티브 애플리케이션으로는 너무 큰 값일 수 있음
- server.tomcat.keep-alive-timeout 속성을 통해 새로운 HTTP 요청을 기다리는 동안 연결을 유지하는 시간을 설정할 수 있음

```yaml
server:
    port: 9001
    tomcat:
    connection-timout: 2s
    keep-alive-timeout: 15s
```

#### 스레드 풀

- server.tomcat.threads.max 속성을 통해 최대 요청 처리 스레드 수를 설정할 수 있음
- server.tomcat.threads.min-spare 속성을 통해 풀에 항상 유지해야 하는 최소의 스레드 수를 정의할 수 있음
  - 톰캣이 시작할 때 이 속성에 정의한 갯수 만큼의 스레드가 풀에 생성됨
- 스레드 풀의 최대/최소에 대한 기본 설정값은 200/10

```yaml
server:
  port: 9001
  tomcat:
    connection-timeout: 2s
    keep-alive-timeout: 15s
    threads:
      max: 50
      min-spare: 5
```

---------

## 스프링 MVC를 이용한 RESTful 애플리케이션 구축

- 클라우드 네이티브 애플리케이션을 구축하면 시스템의 전반적인 기능을 위해 상호작용하는 여러 마이크로서비스로 구성된 분산 시스템을 개발할 가능성이 높음
  - 조직 내에 다른 팀이 개발한 서비스에 의해 사용될 수도 있고, 제 3자에게 그 기능을 제공할 수도 있음
  - 서비스 간 통신에 필수적인 요소가 API
- 15요소 방법론은 API 우선 패턴을 권장
  - 서비스 인터페이스를 먼저 결정하고 구현 작업은 나중에 수행하라는 것
- API는 애플리케이션과 그 애플리케이션 사용자 간의 공개적인 계약을 의미하며, 그것을 최우선으로 정의해야 함
- 클라우드에서는 모든 애플리케이션이 다른 애플리케이션의 지원 서비스가 될 수 있기에 API 우선 원칙을 채택하면 애플리케이션을 발전시켜 나가고
미래의 요구 사항에 맞춰 적응하기 쉬움

### REST API를 먼저, 비즈니스 로직은 그 다음

- 도서에 대한 CRUD 작업 수행

#### 도매인 개체 정의

```java
public record Book (String isbn, String title, String author, Double price){}
```

#### 사용 사례 구현

- 사용 사례는 @Service 클래스로 구현할 수 있음

```java
@Service // 스프링이 관리하는 서비스라는 것을 표시하는 스테레오타입 애너테이션
public class BookService {
	private final BookRepository bookRepository;

	public BookService(BookRepository bookRepository) {
		this.bookRepository = bookRepository;
	}

	public Iterable<Book> viewBookList() {
		return bookRepository.findAll();
	}

	public Book viewBookDetails(String isbn) {
		return bookRepository.findByIsbn(isbn) // 존재하지 않는 책을 보려고 할때 그에 해당하는 예외 발생
			.orElseThrow(() -> new BookNotFoundException(isbn));
	}

	public Book addBookToCatalog(Book book) {
		if (bookRepository.existsByIsbn(book.isbn())) { // 동일한 책을 여러 번 추가하려고 시도하면 해당하는 예외 발생
			throw new BookAlreadyExistsException(book.isbn());
		}
		return bookRepository.save(book);
	}

	public void removeBookFromCatalog(String isbn) {
		bookRepository.deleteByIsbn(isbn);
	}

	public Book editBookDetails(String isbn, Book book) {
		return bookRepository.findByIsbn(isbn)
			.map(existingBook -> {
				var bookToUpdate = new Book(
					existingBook.isbn(),
					book.title(),
					book.author(),
					book.price());
				return bookRepository.save(bookToUpdate);
			}).orElseGet(() -> addBookToCatalog(book)); // 카탈로그에 존재하지 않는 책을 수정하려고 하면 새로운 책 추가
	}
}
```

#### 데이터 액세스를 위한 리포지터리 추상화

```java
public interface BookRepository {
	Iterable<Book> findAll();
	Optional<Book> findByIsbn(String isbn);
	boolean existsByIsbn(String isbn);
	Book save(Book book);
	void deleteByIsbn(String isbn);
}
```

- 리포지터리 인터페이스는 도메인에 속하지만 구현은 지속성 계층에 속함

```java
@Repository
public class InMemoryBookRepository implements BookRepository {
	
	private static final Map<String, Book> books = new ConcurrentHashMap<String, Book>();
	@Override
	public Iterable<Book> findAll() {
		return books.values();
	}

	@Override
	public Optional<Book> findByIsbn(String isbn) {
		return existsByIsbn(isbn) ? Optional.of(books.get(isbn)) : Optional.empty();
	}

	@Override
	public boolean existsByIsbn(String isbn) {
		return books.get(isbn) != null;
	}

	@Override
	public Book save(Book book) {
		books.put(book.isbn(), book);
		return book;
	}

	@Override
	public void deleteByIsbn(String isbn) {
		books.remove(isbn);
	}
}
```

#### 도메인 오류를 알리기 위한 예외의 사용

```java
public class BookAlreadyExistsException extends RuntimeException{
  public BookAlreadyExistsException(String isbn) {
    super("A book with ISBN " + isbn + " already exists");
  }
}

public class BookNotFoundException extends RuntimeException{
	public BookNotFoundException(String isbn) {
		super("The book with ISBN " + isbn + " was not found");
	}
}
```

### 스프링 MVC를 이용한 REST API 구현

```java
@RestController // 클래스가 스프링 컴포넌트이고 REST 엔드포인트를 위한 핸들러를 제공한다는 것을 나타내는 스테레오 타입 애너테이션
@RequestMapping("/books") // 클래스가 핸들러를 제공하는 루트 패스 URI
public class BookController {
    private final BookService bookService;

    public BookController(BookService bookService) {
        this.bookService = bookService;
    }

    @GetMapping
    public Iterable<Book> get() {
        return bookService.viewBookList();
    }

    @GetMapping("{isbn}")
    public Book getByIsbn(@PathVariable String isbn) {
        return bookService.viewBookDetails(isbn);
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Book post(@RequestBody Book book) {
        return bookService.addBookToCatalog(book);
    }

    @DeleteMapping("{isbn}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable String isbn) {
        bookService.removeBookFromCatalog(isbn);
    }

    @PutMapping("{isbn}")
    public Book put(@PathVariable String isbn, @RequestBody Book book) {
        return bookService.editBookDetails(isbn, book);
    }
}
```

### 데이터 유효성 검사 및 오류 처리

- ISBN은 올바른 형식으로 정의되어야 한다
- 제목은 반드시 있어야 한다
- 저자는 반드시 있어야 한다
- 가격은 반드시 있어야 하고 0 보다 큰 값이어야 한다
- 자바 빈 유효성 검사(Java Bean Validation)는 애너테이션을 통해 자바 객체에 대한 제약 조건 및 유효성 검사 규칙을 표현하기 위해 많이 사용하는 규격
- 스프링 부트는 자바 빈 유효성 검사 API와 그 구현을 포함하고 있는 스타터 의존성을 제공함
  - implementation 'org.springframework.boot:spring-boot-starter-validation'

```java
public record Book(
	@NotBlank(message = "The book ISBN must be defined.")
	@Pattern(
		regexp = "^([0-9]{10}[0-9]{13})$",
		message = "The ISBN format must be valid."
	) // 주어진 정규 표현식의 값과 일치하는 형식
	String isbn,
	@NotBlank(message = "The book title must be defined.") // 널 값이 아니고 공백이 아닌 문자를 최소 하나 이상
	String title,
	@NotBlank(message = "The book author must be defined.")
	String author,
	@NotNull(message = "The book price must be definec.")
	@Positive( // 널 값이 아니고 0보다 큰 값
		message = "The book price must be freater than zero."
	)
	Double price
) {
}
```

- 자바 빈 유효성 검증 API의 애너테이션은 제약 조건을 정의하지만 유효성 검증이 이뤄지지는 않음
- 스프링에게 해당 개체에 대한 유효성을 검사하도록 지시하어야 하는데 @RequestBody가 메서드 인수로 지정될 때 @Valid 애너테이션을 사용하면 됨

```java
@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Book post(@Valid @RequestBody Book book) {
    return bookService.addBookToCatalog(book);
}

@PutMapping("{isbn}")
public Book put(@PathVariable String isbn, @Valid @RequestBody Book book) {
    return bookService.editBookDetails(isbn, book);
}
```

- API를 구축할 때 도메인 데이터만큼 오류 메시지도 중요함
- REST API인 경우 HTTP 응답은 목적에 맞는 상태 코드를 가져야 하고 클라이언트가 문제를 발견하는 데 도움이 되도록 의미있는 메시지를 포함해야 함
- REST API의 오류를 처리하려면 자바 표준 예외를 사용하고 @RestControllerAdvice 클래스를 통해 주어진 예외가 발생할 때 어떤 작업을 수행할지 정의하면 됨

```java
@RestControllerAdvice // 클래스가 중앙식 예외 핸들러임을 표시
public class BookControllerAdvice {

	@ExceptionHandler(BookNotFoundException.class) // 핸들러가 실행되어야 할 대상인 예외 정의
	@ResponseStatus(HttpStatus.NOT_FOUND)
	String bookNotFoundHandler(BookNotFoundException ex) {
		return ex.getMessage(); // HTTP 응답 본문에 포함할 메시지
	}

	@ExceptionHandler(BookAlreadyExistsException.class)
	@ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY) // 예외를 발생할 때 HTTP 응답에 포함될 상태코드
	String bookAlreadyExistsHandler(BookAlreadyExistsException ex) {
		return ex.getMessage();
	}

	@ExceptionHandler(MethodArgumentNotValidException.class)
	@ResponseStatus(HttpStatus.BAD_REQUEST)
	public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
		var errors = new HashMap<String, String>();
		ex.getBindingResult().getAllErrors().forEach(error -> {
			String fieldName = ((FieldError) error).getField();
			String errorMessage = error.getDefaultMessage();
			errors.put(fieldName, errorMessage);
		});
		return errors;
	}
}
```

### 미래 요구 사항을 위해 진화하는 API

- API는 독립적은 애플리케이션이지만 다른 애플리케이션에 서비스를 제공하기 위해 존재하고 클라이언트와 완전히 독립적으로
코드를 변경할 수 있는 경우는 별로 없음
- API를 이전 버전과 호환되게 변경하는 것이 좋음
- 어쩔 수 없이 클라이언트에 영향을 끼치는 변경을 해야 할때는 API 버저닝을 사용할 수 있음
  - 엔드포인트에 대해 버전을 도입
  - /v2/books 와 같이 버전 번호가 들어갈 수 있음
  - 또는 HTTP 헤더로 지정할 수 있음
- 다른 접근법은 REST API 클라이언트가 API의 변경에 가능한 한 탄력적으로 대응하도록 만드는데 중점을 둠
  - REST 아키텍처의 하이퍼미디어를 사용하는 것
- REST API는 요청된 객체, 다음에 어디로 가야하는지에 대한 정보, 관련 작업을 수행하기 위한 링크를 반환할 수 있음
- Hypermedia as the Engin of Application State (HATEOAS)

--------

## 스프링 RESTful 애플리케이션 테스트

- 고품질 소프트웨어를 작성하려면 자동화된 테스트가 가장 중요
- 개발자는 기존 코드를 리팩터링할 수 있는데 리팩터링 하는 것은 기존에 잘 작동하던 기능을 손상시킬 수 있기 때문에 위험
  - 자동화된 테스트가 있다면 이러한 위험은 줄어듬
- 테스트 커버리지를 최대로 하는 것을 목표로 하기보다는 의미 있는 테스트를 작성해야 함
  - 게터와 세터에 대한 테스트 코드는 무의미
- 단위 테스트(unit tests)는 애플리케이션의 단위가 되는 하나의 구성 요소의 작동을 개별적으로 검증하고 통합 테스트(integration tests)는
애플리케이션 내에서 서로 상호작용하는 여러 부분들이 전체적으로 어떻게 작동하는지 확인
- 스프링에서 단위 테스트를 실행할 때는 스프링 애플리케이션 컨텍스트를 로드할 필요가 없고 라이브러리에도 의존하지 않음
- 통합 테스트를 실행하려면 스프링 애플리케이션 콘텍스트가 필요

### JUnit 5를 이용한 단위 테스트

- 단위 테스트는 하나의 구성 요소를 고립된 단위로 보고 그 작동을 테스트하려는 목적을 갖음
- 테스트의 대상이 되는 코드가 필요로 하는 의존성이 있다면 어떤 것이라도 목(mock) 객체를 사용해 외부 구성 요소를 차단함

```java
class BookValidationTests {
	private static Validator validator;
	
	@BeforeAll // 클래스 내의 테스트를 실행하기 전에 가장 먼저 실행할 코드 블록
	static void setUp() {
		ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
		validator = factory.getValidator();
	}
	
	@Test // 테스트 케이스를 나타냄
	void whenAllFieldsCorrectThenValidationSucceeds() {
		var book = new Book("1234567890", "Title", "Author", 9.90);
		Set<ConstraintViolation<Book>> violations = validator.validate(book);
		assertThat(violations).isEmpty();
	}
	
	@Test
	void whenIsbnDefinedButIncorrectThenValidationFails() {
		var book = new Book("a234567890", "Title", "Author", 9.90);
		Set<ConstraintViolation<Book>> violations = validator.validate(book);
		assertThat(violations).hasSize(1);
		assertThat(violations.iterator().next().getMessage())
			.isEqualTo("The ISBN format must be valid.");
	}
}
```

### @SpringBootTest를 통한 통합 테스트

- @SpringBootTest 애너테이션은 테스트를 실행할 때 테스트 클래스에서 애플리케이션 콘텍스트를 자동으로 부트스트랩하기 위해 사용함
- 콘텍스트를 만들기 위해 사용하는 설정은 필요한 경우 사용자 정의로 변경할 수 있음
- 변경하지 않으면 스프링 부트의 자동 설정을 포함해 @SpringBootApplication 애너테이션으로 표시된 클래스가 컴포넌트 스캔 및 속성을 위한 설정 소스가 됨
- 모의 환경과 실행 서버 환경 모두 WebTestClient 클래스를 사용해 REST API를 테스트할 수 있음
  - MockMvc 및 TestRestTemplate과 비교할때 현대적이고 풍부한 API를 제공함
  - 스프링 웹플럭스 프로젝트의 일부이기 때문에 의존성 추가 필요
  - testImplementation 'org.springframework.boot:spring-boot-starter-webflux'


```java
@SpringBootTest(
	webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
) // 완전한 스프링 웹 애플리케이션 컨텍스트와 임의의 포트를 듣는 서블릿 컨테이너를 로드
class CatalogServiceApplicationTests {
	@Autowired 
	private WebTestClient webTestClient; // 테스트를 위해 REST 엔드포인트를 호출할 유틸리티

	@Test
	void whenPostRequestThenBookCreated() {
		var expectedBook = new Book("1231231231", "Title", "Author", 9.90);
		webTestClient.post() // POST 요청
			.uri("/books") // 엔드포인트
			.bodyValue(expectedBook) // 요청 본문
			.exchange() // 요청 전송
			.expectStatus().isCreated() // HTTP 응답 코드 확인
			.expectBody(Book.class).value(actualBook -> {
				assertThat(actualBook).isNotNull();
				assertThat(actualBook.isbn())
					.isEqualTo(expectedBook.isbn());
			});
	}
}
```

### @WebMvcTest를 사용한 REST 컨트롤러의 테스트

- 어떤 통합 테스트는 완전한 애플리케이션 컨텍스트가 필요하지 않을 수 있음
  - 데이터 지속성 계층을 테스트할 때는 웹 구성 요소를 로드할 필요가 없음
  - 웹 구성 요소를 테스트할 때는 데이터 지속성 계층을 로드할 필요가 없음
- 스프링 부트는 애플리케이션의 특정한 일부만 대상으로 해서 애플리케이션 컨텍스트를 어떤 컴포넌트의 하위 그룹으로만 초기화할 수 있음
- 슬라이스 테스트(slice test)는 @SpringBootTest 애너테이션을 사용하지 않고 웹 MVC, 웹 플럭스, REST 클라이언트, JDBC, JPA, 몽고디비, 레디스, JSON과
같은 애플리케이션의 특정 부분을 위한 전용 애너테이션을 뜻함
- @WebMvcTest 애너테이션을 사용하면 스프링 MVC 컨트롤러가 의도한 대로 작동하는지 테스트할 수 있음
- @WebMvcTest는 모의 웹 환경에서 스프링 애플리케이션 컨텍스트를 로드하고 스프링 MVC 인프라를 설정하며 @RestController 및 @RestControllerAdvice
와 같은 MVC 계층에서 사용되는 빈만 포함됨
  - 테스트 중인 특정 컨트롤러가 사용하는 빈만 포함하도록 컨텍스트를 제한하는 것이 좋음

```java
@WebMvcTest(BookController.class) // 스프링 MVC 컴포넌트에 중점을 두고 명시적으로는 해당 클래스를 타깃으로 하는 테스트 클래스임을 나타냄
class BookControllerMvcTests {
	@Autowired
	private MockMvc mockMvc; // 모의 환경에서 웹 계층을 테스트하기 위한 유틸리티 클래스

	@MockBean // 스프링 애플리케이션 컨텍스트에 BookService의 모의 객체를 추가
	private BookService bookService;

	@Test
	void whenGetBookNotExistingThenShouldReturn404() throws Exception {
		String isbn = "7373737373940";
		given(bookService.viewBookDetails(isbn))
			.willThrow(BookNotFoundException.class); // 모의 빈이 어떻게 작동할 것인지 규정
		mockMvc
			.perform(get("/books/" + isbn))
			.andExpect(status().isNotFound());
	}
}
```

- @MockBean 애너테이션으로 생성한 모의 객체는 애플리케이션 컨텍스트에 포함된다는 점에서 모키토로 생성한 표준 모의 객체와는 다름
- 컨텍스트가 이 빈을 오토와이어링해야 할 때마다 실제 구현 객체가 아닌 목 객체로 의존성 주입을 함

### @JsonTest를 사용한 JSON 직렬화 테스트

- @JsonTest는 스프링 애플리케이션 컨텍스트를 로드하고 사용 중인 특정 라이브러리에 대한 JSON 매퍼를 자동으로 구성함(잭슨 기본설정)
- JsonPath 및 JSONAssert 라이브러리르 사용해 JSON 매핑이 예상대로 작동하는지 확인하는 데 사용할 수 있는 JacksonTester 유틸리티도 구성함

```java
@JsonTest // JSON 직렬화에 중점을 둔 테스트 클래스임을 나타냄
public class BookJsonTests {

	@Autowired
	private JacksonTester<Book> json; // JSON 직렬화 및 역직렬화를 확인하기 위한 유틸리티 클래스

	@Test
	void testSerialize() throws Exception {
		var book = new Book("1234567890", "Title", "Author", 9.90);
		var jsonContent = json.write(book);
		assertThat(jsonContent).extractingJsonPathStringValue("@.isbn")
			.isEqualTo(book.isbn());
		assertThat(jsonContent).extractingJsonPathStringValue("@.title")
			.isEqualTo(book.title());
		assertThat(jsonContent).extractingJsonPathStringValue("@.author")
			.isEqualTo(book.author());
		assertThat(jsonContent).extractingJsonPathNumberValue("@.price")
			.isEqualTo(book.price());
	}

	@Test
	void testDeserialize() throws Exception {
		var content = """
			{
			"isbn": "1234567890",
			"title": "Title",
			"author": "Author",
			"price": 9.90
			}
			""";
		assertThat(json.parse(content))
			.usingRecursiveComparison()
			.isEqualTo(new Book("1234567890", "Title", "Author", 9.90));
	}
}
```

------------

## 배포 파이프라인: 빌드 및 테스트

- 지속적 전달은 고품질 소프트웨어를 신속하고 안정적이며 안전하게 출시하기 위한 총제적 접근법
- 기본 패턴은 배포 파이프라인
- 커밋된 코드는 파이프라인을 통해 배포 가능한 소프트웨어가 됨

#### 커밋 단계(commit stage)

- 개발자가 새로운 코드를 기본 브랜치에 커밋하면 빌드, 단위 테스트, 통합 테스트, 정적 코드 분석 및 패키지 생성이 이루어짐
- 마지막에는 실행 가능한 애플리케이션 아티팩트가 아티팩트 저장소에 저장됨
  - 이것이 릴리스 후보
  - 메이븐 저장소에 저장된 JAR 아티팩트나 컨테이너 저장소에 저장된 컨테이너 이미지일 수 있음

#### 수락 단계(acceptance stage)

- 프로덕션과 유사한 환경에 애플리케이션을 배포하고 릴리스 가능성에 대한 신뢰를 높이기 위한 테스트를 추가로 실행함
- 느리지만 전체 배포 파이프라인 실행을 1시간 미만으로 유지하기 위해 노력해야 함
- 성능 테스트, 보안 테스트, 준수 테스트 같은 기능적 수용 테스트와 비기능적 수용 테스트가 있음

#### 프로덕션 단계(production stage)

- 릴리스 후보가 커밋과 수락 단계를 거치고 나면 프로덕션에 배포할 수 있다고 확신할 수 있음

### 배포 파이프라인의 커밋 단계 이해

- 개발자는 하루에 여러 번 작은 분량의 작업 결과를 메인 브랜치에 커밋함
- 각 코드 커밋 후 배포 파이프라인의 커밋 단계는 변경된 애플리케이션을 빌드하고 테스트함
- 취약성 스캐너는 그라이프 사용

```shell
grype .
```

### 깃허브 액션을 이용한 커밋 단계 구현

- 배포 파이프라인 자동화를 위해 선택할 수 있는 솔루션은 많음
- 깃허브 액션은 깃허브에 내장된 플랫폼으로 코드 저장소에서 직접 소프트웨어 워크플로를 자동화할 수 있음
- 워크플로는 깃허브 저장소 루트의 .github/workflow 폴더에 정의되어야 하며 깃허브 액션에서 제공하는 YAML 형식에 따라 기술되어야 함

```yaml
name: Commit Stage // 워크플로의 이름
on: push // 새 코드를 저장소로 푸시하면 워크플로를 시작함

jobs:
  build: // 작업의 고유 식별자
    name: Build and Test // 작업의 인간 친화적 명칭
    runs-on: ubuntu-22.04 // 작업이 실행될 머신의 유형
    permissions: // 작업에 부여된 권한
    contents: read // 현재 깃 저장소를 체크 아웃할 수 있는 권한
    security-events: write // 깃허브에 보안 이벤트를 제출할 수 있는 권한
    step:
      - name: Checkout source code
        uses: actions/checkout@v3
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          cache: gradle
      - name: Code vulnerability scanning
        uses: anchore/scan-action@v3
        id: scan
        with:
          path: "${{ github.workspace }}"
          fail-build: false
          severity-cutoff: high
          acs-report-enable: true
      - name: Upload vulnerability report
        uses: github/codeql-action/upload-sarif@v2
        if: success() || failure()
        with:
          sarif_file: ${{ steps.scan.outputs.sarif }}
      - name: Build, unit tests and integration tests
        run: |
          chmod +x gradlew
          ./gradlew build
```

----------

## 요약

- 클라우드 네이티브 애플리케이션은 자체 코드베이스에서 관리해야 하고 모든 의존성은 그래들이나 메이븐과 같은 도구를 사용해 매니페스트 파일로 선언해야 함
- 클라우드 네이티브 애플리케이션은 환경이 제공하는 서버에 의존하지 않고 임베디드 서버를 사용하고 독립적으로 실행함
- API 우선 원칙 계약을 수립하기 위해 비즈니스 로직을 구현하기 전에 API를 먼저 설계할 것
