# 외부화 설정 관리

- 애플리케이션의 특정 측면을 설정하기 위해 application.yaml 파일에 값을 지정함
  - 여러 환경에 배포한다면 환경마다 설정값이 달라질 수 있음
- 일반적인 방식은 애플리케이션을 소스 코드와 여러 다른 환경에 대한 각각의 설정 데이터를 포함하는 번들로 패키징하고 실행할 떄
플래그를 통해 원하는 설정을 선택함
  - 특정 환경에 대한 설정 데이터를 업데이트해야 한다면 애플리케이션을 다시 빌드해야함
- 배포할 때 변경될 수 있는 것이라면 어떤 것이라도 설정 가능한 것이어야 함
  - 기능 플래그, 크리덴셜, 데이터베이스 리소스, 외부 API URL 등
  - 크리덴셜은 특히 소스 코드 저장소에 있어선 안됨

------

## 스프링 설정: 속성과 프로파일

- 설정이라는 용어는 문맥에 따라 다른 의미를 가질 수 있음
  - 스프링 프레임워크의 핵심 기능과 ApplicationContext에 대해 논의하고 있다면 설정은 어떤 빈이 스프링 컨테이너에 의해 관리되어야 하는지
  그리고 필요한 경우 의존성 주입의 여부를 정의하는 것을 의미
- 지금 하는 설정이란 배포 사이에 변경될 가능성이 있는 모든 것을 의미
- 스프링에서는 Environment 라는 추상화 기능을 통해 설정 소스에 상관없이 모든 설정 데이터에 액세스할 수 있음
  - 스프링 애플리케이션 환경의 두 가지 주요 측면은 속성(property)과 프로파일(profile)

### 속성: 설정을 위한 키-값 쌍

- java.util.Properties를 통해 지원되는 키-값 쌍으로 특별한 제약 없이 사용할 수 있음
- 스프링 부트는 여러 소스에서 속성을 자동으로 로드함
- 동일한 속성이 여러 소스에 정의되면 우선순위를 결정하는 규칙이 있음

1. 테스트 클래스의 @TestPropertySource 애너테이션
2. 커맨드라인 인수
3. System.getProperties() 메서르를 사용한 JVM 시스템 속성
4. System.getenv() 메서드를 사용한 OS 환경 변수
5. 설정 데이터 파일
6. @Configuration 클래스의 @PropertySource 애너테이션
7. SpringApplication.setDefaultProperties 으로 기본 설정된 속성

- 설정 데이터 파일은 더 세부적인 우선순위가 있음

1. JAR 외부에 패키징된 application-{profile}.properties, yaml 에 정의된 프로파일별 애플리케이션 속성
2. JAR 외부에 패키징된 application.properties, yaml에 정의된 기본 애플리케이션 속성
3. JAR 내부에 패키징된 application-{profile}.properties, yaml 에 정의된 프로파일별 애플리케이션 속성
4. JAR 내부에 패키징된 application.properties, yaml에 정의된 기본 애플리케이션 속성

- 스프링 속성 처리의 장점은 설정값을 얻고자 할 때 특정 소스에 대해 알 필요 없이 Environment 추상화를 사용하면 통합 인터페이스를 토앻
모든 소스에 정의된 속성에 액세스할 수 있음

#### 애플리케이션 속성의 사용


```java
@Autowired
private Environment environment;

public String getServerPort() {
    return environment.getProperty("server.port");
}
```

- Environment 객체를 명시적으로 호출하지 않아도 사용할 수 있음

```java
@Value("${server.port}")
private String serverPort;

public String getServerPort() {
    return serverPort;
}
```

- 코드 내에 하드코딩하지 않고도 속성을 사용해 애플리케이션을 설정할 수 있지만 환경 객체 또는 @Value를 사용해도 속성 키는 여전히 하드 코딩되어 있고
관리하기 까다로움
  - 스프링 팀은 @ConfigurationProperties 애너테이션으로 표시한 특수한 빈을 통해 설정 데이터를 액세스하는 것을 권장함

#### 사용자 지정 속성 정의

```java
@SpringBootApplication
@ConfigurationPropertiesScan // 스프링 콘텍스트에 설정 데이터 빈을 로드
public class CloudnativeApplication {
	public static void main(String[] args) {
		SpringApplication.run(CloudnativeApplication.class, args);
	}
}

@ConfigurationProperties(prefix = "polar") // 'polar'로 시작하는 설정 속성에 대한 소스
public class PolarProperties {
    private String greeting; // polar.greeting(프리픽스 + 필드명)

    public String getGreeting() {
        return greeting;
    }

    public void setGreeting(String greeting) {
        this.greeting = greeting;
    }
}
```

- 선택 사항으로는 build.gradle 파일에 스프링 부트 설정 프로세서라는 새로운 의존성을 추가할 수 있음
  - 프로젝트를 빌드할 때 새로운 속성에 대한 메타데이터가 자동으로 생성되고 META-INF/spring-configuration-metadata.json에 저장됨

```groovy
configurations { // 프로젝트를 빌드할 때 그래들이 설정 프로세서를 사용하도록 설정
    compileOnly {
        extendsFrom annotationProcessor
    }
}

dependencies {
    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
}
```

#### 사용자 지정 속성 사용

- @ConfigurationProperties 애너테이션이 달린 클래스 또는 레코드는 표준 스프링 빈이므로 필요한 곳이면 어디든 주입할 수 있음

```java
@RestController
public class HomeController {

	private final PolarProperties polarProperties;

	public HomeController(PolarProperties polarProperties) {
		this.polarProperties = polarProperties;
	}

	@GetMapping("/")
	public String getGreeting() {
		return polarProperties.getGreeting();
	}
}
```

### 프로파일: 기능 플래그와 설정 그룹

- 어떤 빈은 특정 조건 하에서만 스프링 콘텍스트로 로드해야 될 때가 있음
  - 로컬로 작업하거나 테스트하는 경우
- 프로파일은 빈을 논리적으로 묶는 그룹
- 한 번에 하나 혹은 그 이상의 프로파일을 활성화할 수도 있고 활성화된 프로파일이 없을 수도 있음

#### 프로파일을 기능 플래그로 사용

- 지정된 프로파일이 활성화된 경우에만 빈 그룹을 로드할 때 배포 환경을 그룹화와 연관지어서는 안됨
  - dev, prod 와 같은 프로파일을 사용해 빈을 조건부로 로드하는 것은 흔한 실수
  - 애플리케이션이 환경과 결합되며 클라우드 네이티브 애플리케이션에는 바람직하지 않음

```java
@Component
@Profile("testdata")
public class BookDataLoader {
	private final BookRepository bookRepository;

	public BookDataLoader(BookRepository bookRepository) {
		this.bookRepository = bookRepository;
	}

	@EventListener(ApplicationReadyEvent.class)
	public void loadBookTestData() {
		var book1 = new Book("1234567891", "Northern Lights",
			"Lyra Silverstar", 9.90);
		var book2 = new Book("1234567892", "Polar Journey",
			"Iorek Polarson", 12.90);
		bookRepository.save(book1);
		bookRepository.save(book2);
	}
}
```

- 개발 환경에서 spring.profiles.active 속성을 사용해 테스트 데이터 프로파일을 활성화할 수 있음
- bootRun 작업을 실행할 때 특별히 로컬 개발 환경을 위한 testdata 프로파일을 설정하는 것이 좋음

```groovy
bootRun {
    systemProperty 'spring.profiles.active', 'testdata'
}
```

#### 프로파일을 설정 그룹으로 사용

- 특정 프로파일이 활성화된 경우에만 로드하는 설정 데이터를 정의할 수 있음
- application-dev.yaml 파일을 만들고 속성을 정의하면 dev 프로파일이 활성화될 때만 스프링 부트가 이 파일의 값을 사용함
- 단순 속성 파일에 우선하기에 dev에 정의된 값은 그냥 yaml 값보다 우선함

----------

## 외부화된 구성: 하나의 빌드, 여러 설정

- 애플리케이션을 빌드해서 패키지를 만든 후 더이상 변경하지 않을 수 있음
  - 설정 변경이 필요한 경우 외부에서 이루어짐

```shell
java -jar build/libs/catalog-service-0.0.1-SNAPSHOT.jar
```

- 속성을 아직 재정의하지 않았기 때문에 루트 엔드포인트는 application.yaml 파일에 정의된 값을 사용함

### 커맨드라인 인수를 통한 애플리케이션 설정

- 프로덕션 환경의 애플리케이션에서 커맨드라인 인수는 우선순위가 가장 높음

```shell
java -jar build/libs/catalog-service-0.0.1-SNAPSHOT.jar --polar.greeting="Welcome to the catalog from CLI"
```

### JVM 시스템 속성을 통해 애플리케이션 구성

- 커맨드라인 인수와 유사하게 스프링 속성을 재정의하지만 우선순위는 더 낮음

```shell
java -Dpolar.greeting="Welcome to the Catalog from JVM" -jar build/libs/catalog-service-0.0.1-SNAPSHOT.jar
```

- JVM 시스템 속성은 스프링 속성과 동일한 이름을 가지며 일반적으로 -D를 속성 앞에 붙임
- CLI 인수 및 JVM 속성을 사용하면 설정을 외부화하고 애플리케이션의 불가변 빌드를 유지할 수 있지만 명령이 약간씩 다르기 때문에 배포할 때
오류가 발생할 수 있음

### 환경 변수를 통해 애플리케이션 구성

- 15요소 방법론에서는 이 방식을 권장
- 모든 운영체제가 화나경 변수를 지원하기 때문에 어떤 환경에서도 이식할 수 있음
- 대부분의 프로그래밍 언어는 환경 변수에 액세스할 수 있는 기능을 제공함
  - System.getenv()
- 스프링에서는 환경 변수를 명시적으로 읽을 필요 없음
  - 시작 단계에서 자동으로 읽고 Environment 객체에 추가하기 때문
  - Environment 인터페이스 또는 @Value 애너테이션을 통해 해당 값에 액세스할 수 있음
- 스프링 속성의 키에 대해 모든 문자를 대문자로 만들고 점이나 대시를 밑줄로 바꾸면 리눅스 환경 변수 구문으로 변경할 수 있음
  - POLAR_GREETING
- 환경 변수를 사용해 설정 데이터를 저장하는 경우 애플리케이션을 실행하기 위해 명령을 변경할 필요가 없음

---------

## 스프링 클라우드 컨피그 서버로 중앙식 설정 관리하기

- 환경 변수를 사용하더라도 처리할 수 없는 문제
  - 설정 데이터는 애플리케이션 코드만큼 중요하므로 지속성부터 시작해 애플리케이션 코드와 동일한 관리와 주의를 가지고 처리해야 하는데
  어디에 저장해야 할까?
  - 환경 변수에 대해서는 세부적인 액세스 제어를 할수없는데 어떻게 제어할까?
  - 설정 데이터는 애플리케이션 코드와 마찬가지로 변경되는데 어떻게 추적하고 설정을 감사해야 할까?
  - 설정 데이터를 변경한 후 어떻게 애플리케이션을 다시 시작하지 않고도 런타임에 읽을 수 있도록 할까?
  - 애플리케이션 인스턴스 수가 증가하면 각 인스턴스에 대해 분산된 방식으로 설정을 처리하는것이 어려워질텐데 어떻게 극복할까?
  - 속성이나 환경 변수는 설정 암호화를 지원하지 않기 때문에 암호를 안전하게 저장할 수 없는데 시크릿을 어떻게 관리해야 할까?
- 설정 서비스(configuration service)
  - 자기 자신만의 설정 서비스를 실행하고 스프링 애플리케이션을 설정하는 데 사용할 수 있는 모듈을 스프링 클라우드 프로젝트가 제공함
- 클라우드 공급업체 서비스(cloud vendor service)
  - 클라우드 공급업체가 제공하는 플랫폼에서 애플리케이션을 실행할 때 이들 업체가 제공하는 설정 서비스의 사용
- 클라우드 플랫폼 서비스(cloud platform service)
  - 쿠버네티스 플랫폼에서 애플리케이션을 실행할 때 컨피그맵 및 시크릿을 사용한다
- 중앙 집중식 설정에 대한 아이디어는 두 가지 주요 구성 요소를 중심으로 구축
  - 설정 데이터에 대한 데이터 저장소로 지속성, 버전 관리, 액세스 제어를 제공
  - 데이터 저장소에 기반해 설정 데이터를 관리하고 여러 애플리케이션에 설정 데이터를 제공하는 서버의 역할
- 설정 서버는 모든 애플리케이션을 지원하는 서비스라는 점에서 단일 장애 지점(single point of failure)이 될 위험이 있음
  - 기본적으로 최소한 두 개의 복제본을 배포

### 깃을 통한 설정 데이터 저장

- 설정 서버는 설정 데이터를 제공할 책임이 있음
- 스프링 클라우드 컨피그 서버는 설정 데이터를 저장하기 위해 다양한 백엔드 솔루션과 통합
  - 깃 저장소가 가장 일반적
- 스프링 클라우드 컨피그는 특정 애플리케이션의 설정을 위해 사용할 속성 파일을 식별하기 위해 세 가지 매개변수를 사용
  - {application}: spring.application.name 속성에 정의된 애플리케이션의 이름
  - {profile}: spring.profile.active 속성에 정의된 활성 프로파일 중 하나
  - {label}: 특정 저장소에서 사용하는 식별자
    - 깃의 경우 태그, 브랜치 이름 또는 커밋 ID

### 설정 서버 구성

- 설정 서버는 전형적인 스프링 부트 애플리케이션으로 설정 서버 기능을 가능케 하는 특정 속성을 가지고 있고 깃 저장소를 설정 데이터 백엔드로 사용

#### 프로젝트 부트스트래핑

```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '2.7.3'
    id 'io.spring.dependency-management' version '1.0.13.RELEASE'
}

group = 'com.polarbookshop'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '17'


repositories {
    mavenCentral()
}

ext {
    set('springCloudVersion', "2021.0.3")
}

dependencies {
    implementation 'org.springframework.cloud:spring-cloud-config-server'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}

tasks.named('test') {
    useJUnitPlatform()
}
```

#### 설정 서버 활성화

```java
@SpringBootApplication
@EnableConfigServer
public class ConfigServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(ConfigServiceApplication.class, args);
	}

}
```

#### 설정 서버 설정

```yaml
server:
  port: 8888
  tomcat:
    connection-timeout: 2s
    keep-alive-timeout: 15s
    threads:
      max: 50
      min-spare: 5

spring:
  application:
    name: config-service
  cloud:
    config:
      server:
        git:
          uri: https://github.com/devch96/config-repo
          default-label: main          
          timeout: 5
          clone-on-start: true
          force-pull: true
```

### 복원력 높은 설정 서버 생성

- 컨피그 서비스는 높은 가용성을 가져야 함
  - 프로덕션 환경에서 여러 인스턴스로 배포함
- 컨피그 서비스는 설정 데이터 백엔드로 깃 저장소를 사용하기 때문에 둘 사이의 상호작용에서 더향상된 복원력이 있어야 함
  - spring.cloud.config.server.git.timeout 속성은 이 목적을 위해 사용됨
- 설정 데이터를 최초로 가져온 후 로컬에 복제함
  - close-on-start 속성을 사용해 복제가 서비스 시작시 이루어질 수 있도록 true로 지정
  - 시작 단계가 느려지겠지만 배포 후에 오류를 발생하는것보다야 나음
- 로컬 저장소가 원격 저장소와 달라질 수 있기 때문에
  - force-pull 옵션 사용
- 로컬 복제본은 무작위로 생성된 이름의 폴더에 저장되도록 기본 설정되어 있음
  - 필요한 경우 basedir 속성 사용

### 설정 서버 REST API 이해

- 스프링 클라우드 컨피그 서버는 서로 다른 조합을 사용한 엔드포인트를 통해 속성을 제공함

```text
/{application}/{profile}[/{label}]
/{application}-{profile}.yaml
/{label}/{application}-{profile}.yaml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties
```

- 표준 REST API를 제공하기 때문에 다른 언어 및 프레임워크로 개발된 애플리케이션이라 할지라도 REST API를 통해 동일한 설정 서버를
사용할 수 있음

------------

## 스프링 클라우드 컨피그 클라이언트로 설정 서버 사용

### 설정 클라이언트 구축

```groovy
ext {
    set('springCloudVersion', '2021.0.3')
}

dependencies {
    implementation 'org.springframework.cloud:spring-cloud-starter-config'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}
```

```yaml
spring:
  application:
    name: catalog-service
  config:
    import: "optional:configserver:"
  cloud:
    config:
      uri: http://localhost:8888
```

- 카탈로그 서비스가 설정 정보를 컨피그 서비스에서 가져오도록 해야 하기에 spring.config.import 속성에 configserver: 라는 값을 전달해야 함
  - 카탈로그 서비스와 같은 클라이언트 애플리케이션에 대해 작업할 때 로컬 환경에서는 설정 서버의 실행을 원하지도 않을 수 있음
  - optional: 를 통해 상호작용을 선택적으로 만들 수 있음
  - 운영에서는 하면 안됨
- 컨피그 서비스의 URL을 등록함
  - 다른 환경에 배포할 때 URL 값만 변경하면 됨

### 내결함성이 높은 설정 클라이언트 구축

- 설정 서버가 작동하고 있더라도 분산 환경에서 상호작용이 일어나기에 문제가 발생할 수 있음
  - 애플리케이션이 신속히 실패하도록 타임아웃을 정의하는 것이 좋음

```yaml
spring:
  application:
    name: catalog-service
  config:
    import: "optional:configserver:"
  cloud:
    config:
      uri: http://localhost:8888
      request-connect-timeout: 5000 // 설정 서버에 연결될 때까지 기다리는 시간(밀리초)
      request-read-timeout: 5000 // 데이터를 읽을 때까지 기다리는 시간(밀리초)
```

- 설정 서비스가 일시적으로 사용할 수 없는 상태일 가능성은 여전히 있음
- 재시도 패턴을 활용해야 함

```groovy
dependencies {
  implementation 'org.springframework.retry:spring-retry'
}
```

```yaml
spring:
  application:
    name: catalog-service
  config:
    import: "optional:configserver:"
  cloud:
    config:
      uri: http://localhost:8888
      request-connect-timeout: 5000
      request-read-timeout: 5000
      fail-fast: true
      retry:
        max-attempts: 6 // 시도의 최대 횟수
        initial-interval: 1000 // 최초 재시도 지연 시간(밀리초)
        max-interval: 2000 // 재시도 지연 최대 시간(밀리초)
        multiplier: 1.1 // 지연 시간 계산 승수
```

### 런타임 시 설정 새로고침

- 컨비그 서비스를 지우너하는 깃 저장소에 새로운 변경 사항을 푸시하면?
- 표준 스프링부트 애플리케이션에서는 속성을 변경하고 반영하려면 애플리케이션을 다시 시작해야 함
- 스프링 클라우드 컨피그는 실행 시간에 클라이언트 애플리케이션에서 설정을 업데이트할 수 있음
- 설정 저장소에 새 변경사항이 푸시될 때마다 설정 서버와 통합된 모든 애플리케이션에 신호를 보내고 애플리케이션은 설정 변경에 영향 받는 부분을
재로드함
- 핫 리로드(hot reload)
  - 실행 중인 서비스 인스턴스에 특수한 POST 요청을 보내 변경된 설정 데이터를 재로드하게 함

#### 설정 새로고침 활서오하

- 원격 깃 저장소에 새로운 설정 변경 사항을 커밋하고 푸시한 다음 클라이언트 애플리케이션의 특정 엔드포인트로 POST 요청을 보내고
애플리케이션 컨텍스트 내에서 RefreshScopeRefreshedEvent를 발생할 수 있도록 함
  - 스프링 부트 액추에이터 사용

```groovy
dependencies{
  implementation 'org.springframework.boot:spring-boot-starter-actuator'
}
```

- 엔드포인트 설정
  - 기본 설정상 노출되지 않기 때문에 명시적으로 활성화해야 함

```yaml
management:
  endpoints:
    web:
      exposure:
        include: refresh // /actuator/refresh 엔드포인트 노출
```

- 새로고침 이벤트인 RefreshScopeRefreshedEvent 는 이 이벤트를 처리하는 컴포넌트가 없다면 무의미
- 새로고침이 트리거될 때마다 다시 로드해야할 빈에 @RefreshScope 애너테이션을 사용
- @ConfigurationProperties 빈을 통해 사용자 정의 속성을 정의했기 때문에 기본적으로 RefreshScopeRefreshedEvent를 듣고 있음

-----------

