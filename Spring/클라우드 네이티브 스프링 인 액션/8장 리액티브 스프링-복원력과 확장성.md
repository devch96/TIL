# 리액티브 스프링-복원력과 확장성

- 데이터베이스 호출이나 HTTP 요청/응답 통신을 사용한 다른 서비스와의 상호작용과 같이 I/O 작업이 많은
애플리케이션은 요청당 스레드 모델로는 기술적 한계에 봉착하게 됨
- 요청당 스레드 모델에서는 각 요청을 처리하기 위해 하나의 스레드를 할당하는데 이때 스레드는 해당 요청만 처리함
- 요청을 처리할 때 데이터베이스 또는 서비스 호출을 해야 하는 경우 스레드는 호출을 한 후 응답을 기다리면서 유휴(idle) 상태가 되고 스레드는 블로킹 됨
- 유휴 시간 동안 해당 스레드에 할당된 리소스는 다른 용도로 사용할 수 없기에 낭비하게 됨
- 리액티브 애플리케이션은 비동기적이고 비차단 방식으로 작동하므로 계산 리소스를 보다 효율적으로 사용함
  - 이런 방식은 사용한 만큼만 사용료를 지불하는 클라우드에서 엄청난 장점이 됨
- 스레드는 지원 서비스에 호출을 보낸 후에 유휴 상태로 빠지는 대신 곧바로 다른 작업을 실행함

-------

## 리액터와 스프링의 비동기 및 비차단 아키텍처

- 리액티브 시스템은 `반응성, 복원성, 탄력성이 높고, 메시지가 주도하는 시스템`

### 요청당 스레드에서 이벤트 루프로

- 요청당 스레드는 대기 시간 동안 해당 요청을 처리하기 위해 스레드에 할당된 자원을 효율적으로 사용하지 못하고, 더 많은 사용자를
동시에 지원하려면 가용 스레드와 리소스를 충분히 가지고 있어야 함
  - 애플리케이션의 확장성을 제약하고 계산 리소스를 효율적으로 사용하지 못함
- 리액티브 애플리케이션에서는 스레드를 특정 요청에 독점적으로 할당하지 않고 이벤트를 기반으로 비동기적으로 처리
  - 데이터베이스 읽기가 필요한 경우 해당 요청을 처리하는 스레드는 데이터베이스로부터 데이터를 받을 때까지 기다리지 않음
  - 콜백을 등록해놓고 데이터가 준비될 때마다 알림이 전송되면 그 시점에 사용 가능한 스레드 중 하나가 콜백을 실행하게 됨
- 이벤트 루프라고 불리는 이 패러다임은 애플리케이션의 확장성에 엄격한 제약을 가하지 않음
- 실제로 스프링 리액티브 애플리케이션의 기본 설정은 CPu 코어당 하나의 스레드만 사용하는 것
  - 비차단 I/O 기능과 이벤트 기반 통신 패러다임을 통해 리액티브 애플리케이션은 계산 리소스를 보다 효율적으로 활용할 수 있음
- 리액티브 애플리케이션의 필수 기능 중 하나는 제어 흐름이라고도 하는 비차단 배압
  - 데이터를 처리하는 쪽에서 수신 데이터의 양을 제어해 자신이 처리할 수 있는 것보다 더 많은 데이터를 받는 위험을 낮추는 것
- 이벤트 중심 방식으로 사고 방식을 전환하는 것 외에도 리액티브 애플리케이션은 비동기 I/O로 인해 디버깅과 문제 해결이 더 어려움

### 프로젝트 리액터: 모노와 플럭스를 갖는 리액티브 스트림

- 프로젝트 리액터는 JVM에서 비동기식 비차단 애플리케이션을 구축하기 위한 프레임워크
  - 리액터는 리액티브 스트림 사양의 여러 구현 중 하나
- 개념적으로 리액티브 스트림은 데이터 파이프라인을 만들기 위해 사용하는 자바 Stream API와 유사
  - 차이점이라면 자바 스트림은 풀 기반이라 명령형 방식이고 동기적으로 데이터를 처리하는 반면 리액티브 스트림은 푸시 기반이라
  새로운 데이터가 생성되면 생성한 쪽, 생산자로부터 통보를 받기 때문에 소비자는 비동기적으로 데이터를 처리함
- 리액티브 스트림은 생산자/소비자 패러다임에 따라 작동하며 생산자는 퍼블리셔라고도 함
  - 생산자는 어딘가에서 사용될 데이터를 생성
- 리액터는 Mono 및 Flux를 제공하는데 두 클래스는 객체에 대한 Producer 인터페이스를 구현하는 중앙 API로 비동기식, 관찰 가능한 데이터 스트림을 구성함
  - Mono: 비동기적인 값이 없거나 하나가 있음을 나타냄(O.1)
  - Flux: 비동기적인 값이 없거나 하나 이상의 시퀀스를 나타냄(O.N)
- 소비자는 생산자에 구독 신청을 하고 새로운 데이터가 생성될 때마다 알림을 받기 때문에 구독자라고도 부름
  - 구독의 일환으로 소비자는 배압을 정의하는데 생산자에게 자신이 한 번에 처리할 수 있는 데이터의 양을 알려주는 것을 의미
  - 얼마나 많은 데이터를 받을지에 대해 제어를 소비자 쪽에 둠으로써 소비자가 너무 많은 데이터를 받아 처리하지 못하는 상황에 빠지는 상황을
  방지할 수 있음
- 리액티브 스트림은 구독자가 있을 때만 활성화 됨
- 자바 스트림은 플루언트 API를 사용해 map, flatMap, filter 같은 연산자를 통해 데이터를 처리할 수 있는데 각 연산자는 이전 단계의 결과는 불가변
상태로 유지하면서 Stream 객체를 새로 만듬
- 리액티브 스트림에서도 유사하게 비동기적으로 받은 데이터를 처리하기 위해 플루언트 API와 연산자를 사용해 리액티브 스트림을 만들 수 있음

### 스프링 리액티브 스택 이해

- 스프링을 사용해 애플리케이션을 만들 때 서블릿 스택과 리액티브 스택 중 하나를 선택할 수 있음
  - 서블릿 스택은 동기적 차단식 I/O와 요청당 스레드 모델을 사용
  - 리액티브 스택은 비동기적 비차단식 I/O와 이벤트 루프 모델을 사용
  - 서블릿 스택은 서블릿 API와 서블릿 컨테이너(톰캣과 같은)를 기반으로 함
  - 리액티브 모델은 리액티브 스트림 API와 네티(또는 3.1 이상의 서블릿 컨테이너)를 기반으로 함
  - 서블릿 스택은 스프링 MVC를 사용
  - 리액티브 스택은 스프링 웹플럭스를 사용
- 스프링 생태계의 모든 주요 프레임워크는 리액티브 및 비리액티브 옵션을 제공

-----------

## 스프링 웹플럭스와 스프링 데이터 R2DBC를 갖는 리액티브 서버

```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    runtimeOnly 'org.postgresql:postgresql'
    runtimeOnly 'org.postgresql:r2dbc-postgresql'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-testcontainers'
    testImplementation 'io.projectreactor:reactor-test'
    testImplementation 'org.testcontainers:junit-jupiter'
    testImplementation 'org.testcontainers:postgresql'
    testImplementation 'org.testcontainers:r2dbc'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

- 스프링 리액티브 웹
  - 스프링 웹플럭스를 통해 리액티브 웹 애플리케이션을 구축하기 위한 라이브러리를 제공하며 네티를 기본 임베디드 서버로 포함
- 테스트컨테이너
  - 경량 도커 컨테이너를 사용해 애플리케이션을 테스트하기 위해 필요한 라이브러리를 제공
- 설정 파일이나 WebServerFactoryCustomizer 구성 요소를 통해 설정할 수 있음

```yaml
server:
  port: 9002
  shutdown: graceful # 우아한 종료 활성화
  netty:
    connection-timeout: 2s # 서버와 TCP 연결을 수립하기 위해 기다리는 시간
    idle-timeout: 15s # 데이터가 전송되지 않는 경우 TCP 연결을 닫기 전에 기다리는 시간


spring:
  application:
    name: order-service
  lifecycle:
    timeout-per-shutdown-phase: 15s
```

### 스프링 데이터 R2DBC를 사용한 리액티브 데이터 지속성

- 자바 애플리케이션에서는 관계형 데이터베이스와 통신하기 위한 드라이버로 보통 JDBC를 사용하지만 리액티브를 지원하지 않음
- R2DBC 드라이버는 PostgreSQL, 마리아 DB, MySQL, SQL 서버 및 오라클 DB와 같은 모든 주요 데이터베이스를 지원

#### 주문 서비스에 대한 PostgreSQL 데이터베이스 실행

```yaml
  polar-postgres:
    image: "postgres:14.4"
    container_name: "polar-postgres"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumns:
      - ./postgresql/init.sql:/docker-entrypooint-initdb.d/init.sql
```

#### R2DBC를 사용한 데이터베이스 연결

```yaml
spring:
  r2dbc:
    username: user
    password: password
    url: r2dbc:postgresql://localhost:5432/polardb_order
    pool:
      max-create-connection-time: 2s # 풀에서 연결 객체 하나를 얻을 때까지 기다릴 수 있는 최대한의 시간
      initial-size: 5 # 연결 풀의 초기 크기 
      max-size: 10 # 풀이 최대한으로 가질 수 있는 연결의 수
```

#### 지속성 엔티티 정의

- 엔티티와 관계형 테이블의 매핑 전략은 자바 객체 이름을 소문자로 변환하는 것으로 기본 설정
  - Order 레코드일 경우 order 테이블로 매핑
  - order는 SQL 예약어
  - 테이블 이름을 orders로 하고 @Table 애터네이션으로 객체 관계 매핑을 설정


```java
@Table("orders")
public record Order(
	@Id
	Long id,

	String bookIsbn,
	String bookName,
	Double bookPrice,
	Integer quantity,
	OrderStatus status,

	@CreatedDate
	Instant createdDate,

	@LastModifiedDate
	Instant lastModifiedDate,

	@Version
	int version
) {
	public static Order of(String bookIsbn, String bookName, Double bookPrice, Integer quantity, OrderStatus status) {
		return new Order(
			null, bookIsbn, bookName, bookPrice, quantity, status, null, null, 0
		);
	}
}

public enum OrderStatus {
  ACCEPTED,
  REJECTED,
  DISPATCHED
}
```

- R2DBC 감사 기능은 @EnableR2dbcAuditing 애너테이션으로 표시된 설정 클래스를 통해 활성화할 수 있음

#### 리액티브 리포지터리 사용

```java
public interface OrderRepository extends ReactiveCrudRepository<Order, Long> {
}
```

#### 플라이웨이를 사용한 데이터베이스 스키마 관리

```groovy
dependencies {
  runtimeOnly 'org.flywaydb:flyway-core'
  runtimeOnly 'org.postgresql:postgresql'
  runtimeOnly 'org.springframework:spring-jdbc'
}
```

```sql
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY NOT NULL,
    book_isbn varchar(255) NOT NULL,
    book_name varchar(255),
    book_price float8,
    quantity int NOT NULL ,
    status varchar(255) NOT NULL,
    created_date timestamp NOT NULL,
    last_modified_date timestamp NOT NULL ,
    version integer NOT NULL
)
```

```yaml
spring:
  flyway:
    user: ${spring.r2dbc.username}
    password: ${spring.r2dbc.password}
    url: jdbc:postgresql://localhost:5432/polardb_order
```

### 리액티브 스트림을 사용한 비즈니스 로직 구현

- 기본 설정상 스프링 웹플럭스는 모든 것이 리액티브로 작동한다고 가정
  - 프레임워크를 사용해 작업할 때 Mono, Flux와 같은 Publisher를 프레임워크와 주고받는것
  - OrderRepository를 비 리액티브에서 하듯이 Optional와 Collection을 반환하지 않고 Mono와 Flux 객체를 통해 오더에 액세스함

```java
@Service
public class OrderService {
    private final OrderRepository orderRepository;

    public OrderService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    public Flux<Order> getAllOrders() {
        return orderRepository.findAll();
    }

    public Mono<Order> submitOrder(String isbn, int quantity) {
        return Mono.just(buildRejectedOrder(isbn, quantity))
                .flatMap(orderRepository::save);
    }
    
    public static Order buildRejectedOrder(String bookIsbn, int quantity) {
        return Order.of(bookIsbn, null, null, quantity, OrderStatus.REJECTED);
    }
}
```

- 자바 슽트림에서 Stream.of()로 스트림 객체를 만드는 것과 같은 방식으로 Mono.just()로 객체를 만듬

##### map 대 flatMap

- 두 연산자 모두 리액티브 스트림(Mono, Flux)을 반환
- map은 두 개의 표준 자바 유형 사이를 매핑하는 반면 flatMap은 자바 유형을 리액티브 스트림으로 매핑함
- OrderRepository의 save() 메서드는 Order 유형의 객체를 인수로 받아 Mono를 반환함
  - map을 사용하게 되면 대상 유형이 리액티브 스트림이라고 생각하지 않기 때문에 Mono<Mono<Order>> 객체를 반환함

### 스프링 웹플럭스로 REST API 노출

```java
public record OrderRequest(
	@NotBlank(message = "The book ISBN must be defined.")
	String isbn,
	
	@NotNull(message = "The book quantity must be defined.")
	@Min(value = 1, message = "You must order at least 1 item.")
	@Max(value = 5, message = "You cannot order more than 5 items.")
	Integer quantity
){}

@RestController
@RequestMapping("orders")
public class OrderController {
    private final OrderService orderService;

    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    @GetMapping
    public Flux<Order> getAllOrders() {
        return orderService.getAllOrders();
    }

    @PostMapping
    public Mono<Order> createOrder(@RequestBody @Valid OrderRequest orderRequest) {
        return orderService.submitOrder(orderRequest.isbn(), orderRequest.quantity());
    }
}
```

----------

## 스프링 웹 클라이언트를 사용한 리액티브 클라이언트

- 스프링 프레임워크는 HTTP 요청을 수행하기 위한 클라이언트가 번들로 제공되는데 RestTemplate과 WebClient
  - RestTemplate는 템플릿 메서드 API를 기반으로 차단 방식의 HTTP 요청/응답 상호작용을 위해 원래부터 제공된 스프링 REST 클라이언트
    - 유지 보수 모드, 실질적으로 중단된 상태
  - WebClient는 차단 및 비차단 I/O를 제공하므로 명령형 및 리액티브 애플리케이션 양쪽에서 사용 가능

### 스프링에서 서비스 간 통신

- 15요소 방법론에 따라 모든 지원 서비스는 자원 바인딩을 통해 애플리케이션에 연결되어야 함
  - 데이터베이스의 경우 크리덴셜 및 URL을 스프링 부트의 설정 속성을 통해 지정
  - 지원 서비스가 다른 애플리케이션인 경우에도 비슷하게 URL 제공해야 함

```java
@ConfigurationProperties(prefix = "polar")
public record ClientProperties(
	@NotNull
	URI catalogServiceUri
) 
{}
```

```yaml
polar:
  catalog-service-uri: "http://localhost:9001"
```

### 데이터 교환 방법에 대한 이해

- 사용자가 특정 도서를 주문할 때마다 주문 서비스는 카탈로그 서비스를 호출해 주문 가능한 상태인지 확인하고 제목, 저자, 가격과 같은 세부 사항을 가져와야 함
- 서로 주고받는 데이터를 어떻게 모델링?
  - 공유 라이브러리 생성
    - 두 애플리케이션에서 같이 사용되는 클래스를 공유 라이브러리를 만들고 각 프로젝트에서 의존성 라이브러리로 임포트
    - 양 쪽 구현이 공유 라이브러리를 통해 결합됨
  - 클래스 중복
    - 결합되지는 않지만 한 쪽 애플리케이션에서 클래스를 변경한다면 다른 쪽 애플리케이션에서도 변경해야 함

```java
public record Book(
	String isbn,
	String title,
	String author,
	Double price
) {
}
```

- 없는 필드는 버려짐

### 웹 클라이언트를 통한 REST 클라이언트 구현

```java
@Configuration
public class ClientConfig {
	@Bean
	WebClient webClient(ClientProperties clientProperties, WebClient.Builder webClientBuilder) {
		return webClientBuilder.baseUrl(clientProperties.catalogServiceUri().toString())
			.build();
	}
}

@Component
public class BookClient {
    private static final String BOOKS_ROOT_API = "/books/";
    private final WebClient webClient;

    public BookClient(WebClient webClient) {
        this.webClient = webClient;
    }

    public Mono<Book> getBookByIsbn(String isbn) {
        return webClient
                .get() // GET 메서드
                .uri(BOOKS_ROOT_API + isbn) // URI는 /books/{isbn}
                .retrieve() // 요청을 보내고 응답을 받음
                .bodyToMono(Book.class); // 받은 객체를 Mono<Book>으로 반환
    }
}

public Mono<Order> submitOrder(String isbn, int quantity) {
    return bookClient.getBookByIsbn(isbn)
            .map(book -> buildAcceptedOrder(book, quantity))
            .defaultIfEmpty(
                    buildRejectedOrder(isbn, quantity))
            .flatMap(orderRepository::save);
}

public static Order buildAcceptedOrder(Book book, int quantity) {
    return Order.of(book.isbn(), book.title() + " - " + book.author(),
            book.price(), quantity, OrderStatus.ACCEPTED);
}
public static Order buildRejectedOrder(String bookIsbn, int quantity) {
    return Order.of(bookIsbn, null, null, quantity, OrderStatus.REJECTED);
}
```

-------------

## 리액티브 스프링을 통한 복원력 높은 애플리케이션

- 복원력은 장애가 발생하더라도 시스템을 계속 사용할 수 있게 유지하면서 서비스를 제공할 수 있는 속성
- 사용자가 실패를 알아차리지 못한 채 계속 시스템을 사용할 수 있게 하는 것이 목표
  - 최악의 경우 기능이 저하될 수는 있어도 여전히 사용할 수는 있어야 함
- 복원력을 달성하는 데 중요한 점은 문제가 해결될 때까지 해당 구성 요소를 격리하는 것
  - 폴라 북숍의 경우 카탈로그 서비스에 오류가 발생해 응답하지 않을 때 주문 서비스에 영향을 끼쳐서는 안 됨

### 타임아웃

- 원격 서비스를 호출할 때마다 응답을 받을 수 있을지, 받는다면 언제 받을지 미리 알 수는 없음
- 타임아웃은 적절한 시간 내에 응답을 받지 않더라도 애플리케이션의 응답성을 유지하기 위한 간단하면서도 효과적인 도구
- 타임아웃 예
  - 연결 타임아웃
    - 원격 자원과 통신 채널을 수립하는 데 걸리는 시간에 대한 제한
    - server.netty.connection-timeout
  - 연결 풀 타임아웃
    - 연결 풀에서 연결 객체를 얻는 데 걸리는 시간에 대한 제한
    - spring.datasource.hikari.connection-timeout
  - 읽기 타임아웃
    - 원격 리소스로부터 읽을 수 있는 시간의 제한

#### 웹 클라이언트에 대한 타임아웃 정의

```java
public Mono<Book> getBookByIsbn(String isbn) {
    return webClient
        .get()
        .uri(BOOKS_ROOT_API + isbn)
        .retrieve()
        .bodyToMono(Book.class)
        .timeout(Duration.ofSeconds(3), Mono.empty());
}
```

- 타임아웃이 초과하면 예외를 발생하는 대신 폴백을 제공해 다른 대체 작동을 수행할 수 있음

#### 타임아웃을 효과적으로 사용하는 방법의 이해

- 타임아웃의 적절한 값을 설정하는 것은 시스템 아키텍처를 전체적으로 고려해야 함
- 폴백을 수행하거나 예외를 발생하기보다는 요청 재시도를 고려해볼 수 있음

### 재시도

- 무턱대고 재시도를 계속할 경우 DoS 공격이랑 다를바가 없음.
- 지수 백오프 전략을 사용해 재시도 횟수가 늘어남에 따라 지연 시간도 늘리는 것

#### 웹 클라이언트에 대한 재시도 정의

- 프로젝트 리액터는 작동이 실패하면 재시도할 수 있는 retryWhen() 연산자를 제공
  - 위치가 중요
  - timeout() 뒤에서는 재시도에 대한 타임아웃이 적용된다는 것
  - retryWhen() 뒤에 timeout() 연산자가 오면 타임아웃이 전체 작동에 적용된다는 것을 의미

```java
public Mono<Book> getBookByIsbn(String isbn) {
    return webClient
        .get()
        .uri(BOOKS_ROOT_API + isbn)
        .retrieve()
        .bodyToMono(Book.class)
        .timeout(Duration.ofSeconds(3), Mono.empty())
        .retryWhen(
            Retry.backoff(3, Duration.ofMillis(100))
        );
}
```

#### 재시도의 효과적 사용

- 읽기 작업과 같은 멱등적 요청은 해를 끼치지 않고 재시도할 수 있음
- 멱등적이 아닌 요청을 재시도해서는 안됨
  - 일관성이 깨진 상태를 초래할 위험이 있음
  - 책을 주문 할 때 첫 번째 주문 요청의 응답이 네트워크 상에서 소실됐다고 해서 주문 요청을 계속 재시도하면 결제가 여러번 이루어질 수 있음

### 폴백 및 오류 처리

- 폴백은 시스템의 나머지 부분이 잘못 작동하거나 결함이 있는 상태가 되는 것을 방지하고 동시에 장애를 일부 영역으로 한정하는 데 도움이 될 수 있음
- 타임아웃과 같이 특정 사레에서만이 아니라 복원력 향상을 위한 일반적인 전략에도 폴백을 포함시켜야 함
- 프로젝트 리액터는 특정 오류가 발생할 때 폴백을 정의하기 위한 onErrorResume() 연산자를 제공

```java
public Mono<Book> getBookByIsbn(String isbn) {
    return webClient
        .get()
        .uri(BOOKS_ROOT_API + isbn)
        .retrieve()
        .bodyToMono(Book.class)
        .timeout(Duration.ofSeconds(3), Mono.empty())
        .onErrorResume(WebClientResponseException.NotFound.class, ex -> Mono.empty())
        .retryWhen(
            Retry.backoff(3, Duration.ofMillis(100)))
        .onErrorResume(Exception.class, ex -> Mono.empty());
}
```

- 핵심 목표는 실패가 발생하더라도 사용자가 이를 알아채지 못하고 서비스를 계속 사용할 수 있을 만큼 높은 복원력을 지닌 시스템을 설계하는 것

----------

## 스프링, 리액터, 테스트컨테이너를 이용한 리액티브 애플리케이션의 테스트

```groovy
dependencies {
    testImplementation 'com.squareup.okhttp3:mockwebserver'
}
```

### 모의 웹 서버로 REST 클라이언트 테스트

- OkHttp 프로젝트는 HTTP 기반 요청/응답 상호작용의 테스트에 사용할 수 있는 모의 웹 서버를 제공

```java
class BookClientTests {
	private MockWebServer mockWebServer;
	private BookClient bookClient;

	@BeforeEach
	void setup() throws IOException {
		this.mockWebServer = new MockWebServer();
		this.mockWebServer.start(); // 테스트 케이스를 실행하기 앞서 모의 서버를 시작
		var webClient = WebClient.builder() // 모의 서버 URL을 웹 클라이언트의 베이스 URL로 사용
			.baseUrl(mockWebServer.url("/").uri().toString())
			.build();
		this.bookClient = new BookClient(webClient);
	}

	@AfterEach
	void clean() throws IOException {
		this.mockWebServer.shutdown(); // 테스트 케이스가 끝나면 모의 서버를 중지
	}

	@Test
	void whenBookExistsThenReturnBook() {
		var bookIsbn = "1234567890";

		var mockResponse = new MockResponse() // 모의 서버에 의해 반환되는 응답을 정의
			.addHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
			.setBody("""
				{
					"isbn": %s,
					"title": "Title",
					"author": "Author",
					"price": 9.90,
					"publisher": "Polarsophia"
				}
				""".formatted(bookIsbn));
		mockWebServer.enqueue(mockResponse); // 모의 서버가 처리하는 큐에 모의 응답을 추가

		Mono<Book> book = bookClient.getBookByIsbn(bookIsbn);
		StepVerifier.create(book) // BookClient가 반환하는 객체로 StepVerifier 객체를 초기화
			.expectNextMatches(
				b -> b.isbn().equals(bookIsbn)
			).verifyComplete(); // 리액티브 스트림이 성공적으로 완료됐는지 확인
	}
}
```

### @DataR2dbcTest 및 테스트컨테이너를 이용한 데이터 지속성 테스트

```java
@DataR2dbcTest // R2DBC 컴포넌트에 집중하는 테스트 클래스
@Import(DataConfig.class) // 감사를 활성화하기 위한 R2DBC 설정 임포트
@Testcontainers // 테스트컨테이너의 자동 시작과 중지를 활성화
class OrderRepositoryR2dbcTests {
	@Container // 테스트를 위한 PostgreSQL 컨테이너를 식별
	static PostgreSQLContainer<?> postgresql = new PostgreSQLContainer<>(DockerImageName.parse("postgres:14.12"));

	@Autowired
	private OrderRepository orderRepository;

	@DynamicPropertySource // 테스트 PostgreSQL 인스턴스에 연결하도록 R2DBC와 플라이웨이 설정 변경
	static void postgresqlProperties(DynamicPropertyRegistry registry) {
		registry.add("spring.r2dbc.url", OrderRepositoryR2dbcTests::r2dbcUrl);
		registry.add("spring.r2dbc.username", postgresql::getUsername);
		registry.add("spring.r2dbc.password", postgresql::getPassword);
		registry.add("spring.flyway.url", postgresql::getJdbcUrl);
	}

	private static String r2dbcUrl() { // 테스트컨테이너가 JDBC와는 다르게 R2DBC에 대해서는 연결 문자열을 제공하지 않음
		return String.format("r2dbc:postgresql://%s:%s/%s", postgresql.getHost(),
			postgresql.getMappedPort(PostgreSQLContainer.POSTGRESQL_PORT), postgresql.getDatabaseName());
	}

	@Test
	void createRejectedOrder() {
		var rejectedOrder = OrderService.buildRejectedOrder("1234567890", 3);
		StepVerifier.create(orderRepository.save(rejectedOrder))
			.expectNextMatches(
				order -> order.status().equals(OrderStatus.REJECTED)
			).verifyComplete();
	}
}
```

### @WebFluxTest를 이용한 REST 컨트롤러 테스트

```java
@WebFluxTest(controllers = OrderController.class)
class OrderControllerWebFluxTests {

	@Autowired
	private WebTestClient webClient;

	@MockBean
	private OrderService orderService;


	@Test
	void whenBookNotAvailableThenRejectOrder() {
		var orderRequest = new OrderRequest("1234567890", 3);
		var expectedOrder = OrderService.buildRejectedOrder(
			orderRequest.isbn(), orderRequest.quantity());
		given(orderService.submitOrder(
			orderRequest.isbn(), orderRequest.quantity())
		).willReturn(Mono.just(expectedOrder));

		webClient.post()
			.uri("/orders/")
			.bodyValue(orderRequest)
			.exchange()
			.expectStatus().is2xxSuccessful()
			.expectBody(Order.class).value(actualOrder -> {
				assertThat(actualOrder).isNotNull();
				assertThat(actualOrder.status()).isEqualTo(OrderStatus.REJECTED);
			});
	}
}
```