# 클라우드 네이티브 패턴 및 기술

- 클라우드 네이티브로 간주할 수 있는 애플리케이션을 개발하려면 우수 사례와 개발 패턴으로 구성된 12요소 방법론에서 출발하면 좋음

---------

## 클라우드 네이티브 개발 원칙: 12요소와 확장

- 원래의 요소들의 내용을 새롭게하고 세 가지 요소를 새로 추가함
- 15요소 방법론

### 하나의 코드베이스, 하나의 애플리케이션

- 애플리케이션과 코드베이스 사이의 일대일 관계를 설정함
- 애플리케이션은 그에 해당하는 코드베이스가 하나만 있어야 함
- 공유 코드는 별도의 코드베이스로 유지되면서 의존성 라이브러리로 포함되든지 독자적으로 실행할 수 있는 서비스로 다른 애플리케이션을 지원해야 함

### API 우선

- 클라우드 네이티브 애플리케이션을 설계할 때 API 우선 접근 방식을 사용하면 분산 시스템에 적합하도록 시스템을 고려하고 다른 팀 간의 업무를
배분할 수 있음
- API를 먼저 설계함으로써 해당 애플리케이션을 백엔드 서비스로 사용하는 다른 팀은 해당 API를 가지고 자신들의 시스템 개발을 진행할 수 있음
- 코드 계약을 미리 설계하면 다른 시스템과의 통합은 더욱 견고해지고 배포 파이프라인에서 테스트가 용이해짐

### 의존성 관리

- 애플리케이션의 모든 의존 라이브러리는 명시적인 방식으로 선언되어야 하며 이를 통해 의존 라이브러리 관리 툴이 중앙 저장소에서 다운로드 할 수 있어야 함
- 자바 애플리케이션이라면 메이븐이나 그래들 같은 도구를 사용하면 잘 따를 수 있음

### 설계, 빌드, 릴리스, 실행

- 설계 단계(design stage): 특정 애플리케이션 기능에 필요한 기술, 의존성 및 툴이 결정됨
- 빌드 단계(build stage): 코드베이스를 컴파일하고 의존 라이브러리와 함께 패키지로 만들어 빌드라고 부르는 불가편 아티팩트를 생성
- 릴리스 단계(release stage): 배포하기 위해 빌드를 특정 설정과 결합
- 실행 단계(run stage): 애플리케이션의 특정 릴리스가 실행 환경에서 작동

### 설정, 크리덴셜 및 코드

- 15요소 방법론에서는 설정(configuration)에 대한 정의를 배포 사이에 변경될 가능성이 있는 모든 것이라고 정의
  - 애플리케이션의 설정을 변경해야 한다면 코드의 변경이나 애플리케이션의 재빌드 없이도 할 수 있어야 함
- 설정의 예로는 데이터베이스 또는 메시징 시스템과 같은 백엔드 서비스에 대한 리소스 정보, 타사 API에 액세스할 수 있는 유저 정보 및 기능 플래그 등
- 설정이 코드에 포함되어 있거나 코드베이스에서 발견되면 안됨
- 15요소 방법론은 환경 변수를 사용한 환경설정을 권고함

### 로그

- 애플리케이션은 로그 저장이나 순환에 대해서는 신경쓰지 말아야 함
- 로그 수집기와 같은 외부 툴을 사용해 수집하고 검사

### 일회성

- 클라우드 환경에서는 애플리케이션이 삭제될 수 있음
  - 실패가 발생하고 응답하지 않으면 종료하고 새 인스턴스를 늘리면 됨
- 언제라도 애플리케이션을 시작하거나 중지할 수 있는 경우를 일회성 이라고 함
- 애플리케이션이 종료 신호를 받으면 새로운 요청을 수락하지 않고 진행중인 요청을 모두 완료한 다음 종료하는 것을 우아한 종료(graceful shutdown)이라고 함

### 자원 서비스

- 자원 서비스는 어떤 애플리케이션이 자신의 기능을 제공하기 위해 사용하는 외부 리소스로 정의 할 수 있음
  - 데이터베이스, 메시지 브로커, 캐싱 시스템, SMTP 서버, FTP 서버, RESTful 웹 서비스 등
- 자원 서비스를 탈착식 리소스처럼 처리하면 애플리케이션 코드를 수정하지 않고도 리소스를 쉽게 변경할 수 있음

### 환경 동일성

- 환경 동일성은 모든 환경을 가능한 한 비슷하게 ㅇ ㅠ지하는 것
- 이 요소를 통해 메꾸고자 하는 간극은 세가지 정도로 존재
  - 시간 차이
    - 15요소 방법론은 자동화 및 지속적 배포를 활용하여 개발자가 코드를 작성한 이후부터 프로덕션에 배포할 때까지의
    기간을 줄이기 위해 노력
  - 사람 차이
    - 데브옵스 문화를 수용해 개발자와 운영자 간의 협력을 증진하고 만든 사람이 실행한다는 철학을 실현함
  - 도구 차이
    - 모든 환경에서 동일한 유형과 동일한 버전의 지원 서비스를 사용해야 함

### 관리 프로세스

- 애플리케이션을 지원하기 위해 몇 가지 관리 작업이 필요함
  - 데이터베이스 마이그래이션, 배치, 점검 보수와 같은 작업
  - 이들은 일회성 프로세스로 처리해야 함
- 애플리케이션 프로세스에 대해 수행한 것과 동일한 고려사항이 관리 프로세스에도 적용되어야 함
- 관리 작업은 한 번 실행한 후에 더 이상 사용하지 않는 작은 독립형 서비스 또는 상태가 없는 플랫폼에서 특정 이벤트가 발생할 때 실행하도록
설정된 함수로 구성하거나 애플리케이션의 일부로 특정 앤드포인트를 호출해 실행하도록 하는 것이 좋음

### 포트 바인딩

- 15요소 방법론을 따르는 애플리케이션은 독립적이어야 하고 포트 바인딩을 통해 서비스를 제공해야 함
- 프로덕션에는 외부로 공개된 엔드포인트로 들어온 요청을 특정 포트에 바인딩된 내부 서비스로 변환하는 라우팅 서비스가 가능함

### 상태를 갖지 않는 프로세스

- 확장성을 보장하기 위해 애플리케이션이 상태를 갖지 않는 프로세스가 되도록 설계하고 아무것도 공유하지 않는 아키텍처를 채택해야 함
  - 애플리케이션 인스턴스 간에 상태를 공유해서는 안된다는 의미
- 애플리케이션 인스턴스를 파괴하고 인스턴스를 새로 만들면 데이터가 손실되는지 자문할것
- 애플리케이션은 상태를 갖지 않도록 설계하고 대신 상태는 데이터 저장소와 같은 상태를 갖는 서비스를 통해 처리해야 함

### 동시성

- 상태를 갖지 않도록 애플리케이션을 설계하는 것만으로는 확장성을 담보하기에 부족
- 애플리케이션은 동시성을 통해 많은 사용자에게 서비스를 제공할 수 있어야 함

### 원격 측정

- 클라우드에서 분산 시스템을 관리하는 것은 복잡한데 복잡성을 관리하려면 시스템의 작동을 원격으로 모니터링할 수 있어야 함
- 로그, 메트릭, 추적, 상태, 이벤트 등

### 인증 및 승인

- 제로 트러스트 접근법에 따라 시스템 내 상호작용의 안전성은 몯느 설계적, 인프라적 수준에서 확보되어야 함
- 인증을 통해 누가 애플리케이션을 사용하고 있는지 추적, 사용자 권한을 통해 특정 작업을 수행할 수 있는지 확인 가능

----------

## 스프링을 사용한 클라우드 네이티브 애플리케이션 구축

### 스프링 개요

- 스프링은 여러 프로젝트로 이루어져 있음
- 스프링 프레임워크는 스프링 콘텍스트 또는 스프링 컨테이너라고 부르는 실행 콘텍스트를 제공하는데 여기에서 빈, 속성, 리소스가
애플리케이션의 전체 라이프 사이클에 걸쳐 관리됨

### 스프링 부트 애플리케이션 구축

- 전문 서점을 관리하고 북극점과 북극에 관한 책을 온라인으로 판매하기를 원함
  - 클라우드 네이티브 방식을 고려

#### 빌드 설정

```groovy
plugins {
  id 'org.springframework.boot' version '2.7.3' // 스프링부트의 버전
  id 'io.spring.dependency-management' version '1.0.13.RELEASE' // 의존성 관리 기능 제공
  id 'java' // 애플리케이션의 컴파일, 빌드, 테스트 작업을 수립하고 그래들에 자바 지원을 제공
}

group = 'com.polarbookshop' // 서비스 프로젝트의 그룹 ID
version = '0.0.1-SNAPSHOT' // 애플리케이션의 버전
sourceCompatibility = '17' // 프로젝트 빌드 시 사용할 자바 버전

repositories { // 의존 라이브러리를 검색할 아티팩트 저장소
  mavenCentral()
}

dependencies { // 애플리케이션에 의해 사용될 의존 라이브러리
  implementation 'org.springframework.boot:spring-boot-starter-web'
  testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') { // JUnit 5가 제공하는 JUnit 플랫폼으로 테스트하도록 설정
  useJUnitPlatform()
}
```

- 스프링 웹(org.springframework.boot:spring-boot-starter-web)
  - 스프링 MVC로 웹 애플리케이션을 빌드하는 데 필요한 라이브러리를 제공하며 임베디드 서버로는 기본 설정상 톰캣이 포함되어 있음
- 스프링 부트 테스트(org.springframework.boot:spring-boot-starter-test)
  - 스프링 테스트, JUnit, 어서트J(AssertJ), 모키토를 포함해 애플리케이션을 테스트할 수 있는 여러 라이브러리 및 유틸리티를 제공함

#### 애플리케이션 부트스트래핑

```java
@SpringBootApplication // 스프링 설정 클래스를 정의하고 컴포넌트 스캔과 스프링 부트 자동 설정을 실행
public class CloudnativeApplication {
	public static void main(String[] args) { // 애플리케이션을 시작하는 메서드. 현재 클래스를 애플리케이션의 부트스트랩 단계에서 실행하도록 설정
		SpringApplication.run(CloudnativeApplication.class, args);
	}
}
```

- @SpringBootApplication 애너테이션은 아래와 같은 세 가지 다른 애너테이션을 한꺼번에 포함
  - @Configuration: 해당 클래스가 빈을 정의하는 클래스임을 나타냄
  - @ComponentScan: 컴포넌트 검색을 통해 빈을 찾아 스프링 콘텍스트에 자동으로 등록
  - @EnableAutoConfiguration: 자동 설정 기능을 활성화

------------

## 도커를 통한 애플리케이션 컨테이너화

- 대부분의 의존성은 그래들에 의해 관리되고 애플리케이션과 함께 JAR 아티팩트로 패키징됨
- 자바 런타임은 이 아티팩트에 포함되지 않음
- 컨테이너를 사용하지 않는다면 애플리케이션을 배포하는 머신에 자바 런타임을 설치해야함

### 도커 소개: 이미지 및 컨테이너

- 컴퓨터에 도커 플랫폼을 설치하면 클라이언트/서버 아키텍처를 특징으로 하는 도커 엔진 패키지를 갖게 됨
- 도커 서버(Docker server)에는 도커 데몬(Docker demon)이 포함되어 있는데 도커 데몬은 백그라운드에서 실행하면서 이미지, 컨테이너, 볼륨,
네트워크 같은 도커 객체를 만들고 관리함
- 도커 서버가 실행되는 컴퓨터를 도커 호스트라고 함
- 컴퓨터에서 컨테이너를 실행하려면 컴퓨터가 도커 호스트여야 하고 도커 데몬이 실행중이어야 함
- 도커 데몬은 API를 제공하는데 API를 통해 컨테이너를 실행하거나 볼륨을 생성하는 것과 같은 명령을 도커에 전달할 수 있음
  - API를 사용해 데몬과 상호작용하는 것이 도커 클라이언트
- 도커 클라이언트는 명령어 기반이며 도커 컴포즈와 같이 스크립트 방식을 사용하거나 도커 명령어 인터페이스를 사용해 도커 데몬과의 직접 상호작용하면서 명령을 전달
- 컨테이너 이미지는 내부에서 애플리케이션을 실행하는 데 필요한 모든 것을 포함하는 실행 가능한 경량의 패키지
- 도커 이미지 형식은 컨테이너 이미지를 만드는 데 가장 많이 사용됨
- 컨테이너는 컨테이너 이미지의 실행 가능한 인스턴스

### 컨테이너를 통한 스프링 애플리케이션의 실행

- 클라우드 네이티브 빌드팩 사용
- 클라우드 네이티브 빌드팩은 낮은 층위의 Dockerfile을 사용하는 대신 더 높은 층위의 추상화를 통해 애플리케이션 소스 코드를 컨테이너
이미졸 자동 변환하는 기능을 제공
- 클라우드 네이티브 빌드팩 사양을 구현한 패키토 빌드팩은 그래들과 메이븐에 대한 스프링 부트 플러그인을 통해 스프링 부트를 지원
  - 별도로 툴이나 의존성 라이브러리를 추가한다든지 도커파일을 작성하지 않고도 스프링 부트 애플리케이션을 컨테이너화할 수 있음

```shell
./gradlew bootBuildImage
```
- 생성된 이미지는 기본적으로 project_name : version 이라는 이름을 갖음

```shell
docker images catalog-service:0.0.1-SNAPSHOT
```

- 이미지를 실행하고 컨테이너화된 애플리케이션이 올바르게 작동하는지 확인

```shell
docker run --rm --name catalog-service -p 8080:8080 catalog-service:0.0.1-SNAPSHOT
```

- docker run
  - 이미지에서 컨테이너를 실행
- --rm
  - 실행이 끝난 후 컨테이너를 삭제
- --name
  - 컨테이너의 이름
- -p 8080:8080
  - 8080포트를 통해 컨테이너 외부로 서비스를 노출

---------

## 쿠버네티스로 컨테이너 관리

- 쿠버네티스(k8s)는 컨테이너 애플리케이션의 배포, 확장, 관리를 자동화하기 위한 오픈소스 시스템
- 도커에서 컨테이너로 작업할 때 배포 대상은 하나의 머신
- 여러 대의 머신에 배포해야 할 경우에는 여러 호스트에 걸쳐 컨테이너를 연결하려면 컨테이너 엔진 이상의 무언가가 필요

### 쿠버네티스 소개: 배포, 파드, 서비스

- 컨테이너 구성에는 컨테이너 런타임이 있는 컴퓨터가 필요
- 쿠버네티스를 사용하면 오케스트레이션 구성이기 때문에 클러스터가 필요
- 쿠버네티스 클러스터는 컨테이너화된 애플리케이션을 실행하는 작업자 머신의 집합
  - 작업자 머신을 노드 라고 함
- 모든 클러스터에는 적어도 하나의 작업자 노드가 존재하며, 미니큐브를 사용하면 로컬 머신에서 쉽게 단일 노드 클러스터를 사용할 수 있음
- 프로덕션, 즉 실제 서비스 환경에서는 클라우드 공급자가 관리하는 클러스터를 사용하게 됨
- 쿠버네티스 클러스터에는 작업자 노드(worker node)라고 부르는 머신이 여러 대 존재할 수 있는데 이 작업자 노드에 컨테이너화된 애플리케이션이 배포됨
- 컨테이너가 실행되고 네트워크에 연결할 수 있도록 작업자 노드는 CPU, 메모리, 네트워크, 스토리지 등을 제공함
- 컨트롤 플레인(control plane)은 작업자 노드를 관리하는 컨테이너 오케스트레이션 계층
  - API 및 인터페이스를 통해 컨테이너의 라이프사이클을 정의, 배포, 관리함
- 쿠버네티스와의 상호작용은 CLI 클라이언트인 kubectl을 통해 이루어짐
- kubectl은 컨트롤 플레인과의 통신을 통해 작업자 노드에서 작업을 수행함
  - 클라이언트는 작업자 노드와 직접 연결하지 않음
- 파드(pod)
  - 가장 작은 배포 단위로 하나 이상의 컨테이너를 포함할 수 있음
  - 일반적으로 하나의 파드에는 애플리케이션이 하나만 있지만 핵심 애플리케이션을 지원하기 위한 컨테이너가 추가로 포함될 수 있음
    - 로깅이나 초기화 단게에서 실행할 관리 작업 같은 기능을 제공하는 컨테이너
  - 쿠버네티스는 컨테이너를 직접 관리하지 않고 파드를 관리함
- 배포(deployment)
  - 배포 객체를 통해 애플리케이션에 대해 원하는 배포 상태를 쿠버네티스에 알림
  - 여러 개의 파드를 하나의 집합체로 관리하는 것이 가능함
- 서비스(service)
  - 서비스 정의를 통해 배포(파드의 집합)는 클러스터 내의 다른 노드나 외부로 노툴됨
  - 파드 인스턴스들이 균일한 부하를 갖도록 관리함
- 새 애플리케이션을 실행하려는 경우 쿠버네티스 객체에 대해 리소스 매니페스트(resource manifest)를 정의할 수 있는데 이것은 애플리케이션에 대해
원하는 상태를 기술하는 파일
  - 5개를 복제해서 8080 포트를 통해 외부로 노출되어야 한다 라고 명시할 수 있음
  - YAML을 사용해 작성됨

### 쿠버네티스에서 스프링 애플리케이션 실행

- 컨테이너 이미지로 카탈로그 서비스를 배포하도록 쿠버네티스에 명령해야 함
  - 이미지는 이전에 생성
- 미니큐브는 도커 허브 레지스트리에서 이미지를 가져오도록 기본 설정되어 있기 때문에 다른 명령어가 필요

```shell
minikube start
minikube image load catalog-service:0.0.1-SNAPSHOT
```

- 파드는 배포의 단위이지만 파드를 직접 관리하진 않음
  - 쿠버네티스가 대신 관리
- 파드는 애플리케이션 인스턴스이기에 영구적이지 않고 삭제할 수 있음
- 클라우드 네이티브의 목표를 달성하려면 플랫폼이 파드 인스턴스를 관리하고 한 인스턴스가 다운되면 다른 파드로 대체될 수 있어야 하기에
배포 리소스가 필요함
- 쿠버네티스는 애플리케이션 인스턴스를 파드 리소스로 생성할 수 있음

```shell
kubectl create deployment catalog-service --image=catalog-service:0.0.1-SNAPSHOT
```

- kubectl create
  - 쿠버네티스 리소스 생성
- deployment
  - 생성할 리소스 유형
- catalog-service
  - 배포 이름

- 생성한 배포 객체 확인

```shell
kubectl get deployment
```

- 쿠버네티스가 배포 생성 명령을 실행할 때 내부적으로는 배포 리소스에 정의된 애플리케이션용 파드가 만들어짐
- 생성된 파드 객체 확인

```shell
kubectl get pod
```

- ㅋ버네티스의 기본 설정으로는 파드로 실행중인 애플리케이션에 액세스할 수 없음

```shell
kubectl expose deployment catalog-service --name=catalog-service --port=8080
```

- kubectl expose
  - 쿠버네티스 리소스를 노출
- deployment
  - 노출할 리소스 유형
- catalog-service
  - 노출할 배포의 이름
- --name=catalog-service
  - 서비스 이름
- --port=8080
  - 서비스를 노출할 포트 번호
- 서비스 객체에 의해 애플리케이션은 클러스터 내부의 다른 구성 요소에 노출됨
- 서비스 확인

```shell
kubectl get service catalog-service
```

- 컴퓨터의 로컬 포트(예 8000)로부터 클러스터 내에서 서비스에 노출된 포트(8080)로 트래픽을 전달할 수 있음
  - 도커의 포트 매핑과 비슷

```shell
kubectl port-forward service/catalog-service 8000:8080
```

- kubectl port-forward
  - 포트 포워딩 명령
- service/catalog-service
  - 노출할 리소스
- 8000
  - 로컬 호스트의 포트
- 8080
  - 서비스 포트

```shell
kubectl delete service catalog-service
kubectl delete deployment catalog-service
minikube stop
```

---------

## 폴라 북숍: 클라우드 네이티브 애플리케이션

### 프로젝트에서 사용되는 패턴과 기술

#### 웹과 상호작용

- HTTP를 통해 동기식으로 상호작용하는 RESTful 서비스를 블로킹 방식(전통적인 서블릿) 혹은 넌블로킹(리액티브 프로그래밍)으로 구축함
  - 스프링 MVC와 리액터 프로젝트에 기반한 스프링 웹플럭스가 주요 도구
- 클라우드 네이티브 애플리케이션을 구축할 때는 느슨하게 결합된 서비스를 설계하고 분산 시스템 환경에서 데이터의 일관성을 유지할 수 있는 방법을 고려해야 함
- 동기식 통신은 하나의 기능을 수행하기 위해 연관된 서비스가 많을수록 문제의 여지가 많음
  - 이벤트 기반 프로그래밍이 클라우드에서 인기를 얻고 있는 이유
- 이벤트 및 메시징 시스템을 사용해 서비스를 분리하고 데이터 일관성을 보장하는 방법을 알아봄
- 스프링 클라우드 스트림을 사용해 서비스 간의 데이터 흐름을 구현하고 스프링 클라우드 함수를 사용해 메시지 처리르 위한 함수를 정의함

#### 데이터

- PostgreSQL 사용
- 클라우드 네이티브 애플리케이션은 상태를 갖지 않지만 상태를 어딘가에는 저장해야 함
- 레디스를 사용해 세션 데이터를 외부의 데이터 저장소에 저장함으로써 애플리케이션은 상태를 갖지 않고 확장 가능할 수 있음
  - 스프링 세션을 사용하면 클러스터 환경에서 사용자 세션을 쉽게 구현할 수 있음
  - 스프링 세션 데이터 레디스

#### 라우팅

- 분산 시스템이기 때문에 라우팅 설정이 필요함
- 쿠버네티스는 서비스 디스커버리 기능이 내장되어 있는데 이를 통해 서비스는 물리적 주소나 호스트 이름과는 독립적으로 존재할 수 있음
- 클라우드 네이티브 애플리케이션은 확장 가능하므로 하나의 서비스가 여러 개의 인스턴스를 가질 수 있고, 서비스와 여러 인스턴스 사이의 상호작용을 고려해야 함
- 쿠버네티스는 기본적으로 작업 부하 분산 기능을 가지고 있기 때문에 애플리케이션에서 이것을 따로 구현할 필요가 ㅇ없음
