# 예외

------------

## 사라진 SQLException

- JdbcContext로 만들었던 코드를 JdbcTemplate을 적용하도록 바꾸면서 throws SQLException이 사라짐
- 어디로갔나?

### 초난감 예외처리

#### 예외 블랙홀

```java
try{
    ...
} catch(SQLException e) {
    // 예외를 잡고 아무것도 하지 않는다.
}
```

- 예외가 발생하면 그것을 catch블록을 써서 잡아내는 것까지는 좋은데 아무것도 하지 않고 별문제 없는 것처럼 넘어가 버리는 건 정말 위험한 일
- 프로그램 실행 중에 어디선가 오류가 있어서 예외가 발생했는데 그것을 무시하고 계속 진행해버리기 때문
  - 예상치 못한 다른 문제를 일으킴
- 습관이 되면 무서우니 연습이나 예제를 만드는 잠깐에서도 그래선 안됨

```java
catch(SQLException e) {
    System.out.println(e);
}

catch(SQLException e) {
    e.printStackTrace();
}
```

- 위 같은 것도 안됨
- 예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 함

```java
catch(SQLException e) {
    e.printStackTrace();
    System.exit(1);
}
```

- 차라리 이게 남
  - 실전에서 이렇게 하라는 것이 아님
  - 예외를 무시하거나 잡아먹지 말란 말
- 굳이 예외를 잡아서 뭔가 조치를 취할 방법이 없다면 잡지 말아야 함
- 메서드에 throws SQLException을 선언해서 메서드 밖으로 던지고 자신을 호출한 코드에 예외처리 책임을 전가

#### 무의미하고 무책임한 throws

- 예외를 잡아봐야 해결할 방법도 없고 각종 긴 이름의 예외들을 처리하는 코드를 매번 throws로 선언하기도 귀찮은 개발자들은
기계적으로 throws Exception을 붙이기도 함
- 메서드 선언에서 의미 있는 정보를 얻을 수 없기 때문에 호출하는 메서드 쪽에서도 throws Exception을 따라서 붙이는 수 밖에 없음
- 매우 안좋음

### 예외의 종류와 특징

- 자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지
  - Error
    - java.lang.Error 클래스의 서브 클래스
    - 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용
    - JVM에서 발생시키고 애플리케이션 코드에서 잡으려고 하면 안 됨
      - OutOfMemoryError나 ThreadDeath 같은 에러는 잡아봤자 아무런 대응 방법이 없음
    - 시스템 레벨에서 특별한 작업을 하는 것이 아니라면 애플리케이션에서는 에러 처리에 신경쓰지 않아도 됨
  - Exception과 체크 예외
    - java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들
    - 에러와 달리 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용
    - Exception 클래스는 다시 체크 예외와 언체크 예외로 구분됨
      - 체크 예외 :Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 것
      - 언체크 예외 :Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속한 것
    - 체크 예외가 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 함
      - try-catch, throws
      - 컴파일 에러 발생함
  - RuntimeException과 언체크/런타임 예외
    - java.lang.RuntimeException 클래스를 상속한 예외
    - 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불림
      - try-catch, throws 하지 않아도 됨
    - 프로그램의 오류가 있을 때 발생하도록 의도된 것
    - 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외

### 예외처리 방법

#### 예외 복구

- 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
- 에러 메시지가 사용자에게 그냥 던져지는 것은 복구가 아님
- 예외가 처리됐으면 비록 기능적으로는 사용자에게 예외상황으로 비쳐도 애플리케이션에서는 정상적으로 설계된 흐름을 따라 진행해야 함
  - 원격 DB 서버에 접속하다 실패해서 SQLException이 발생하는 경우에 재시도
    - 물론 정해진 횟수만큼 재시도해서 실패했다면 예외 복구는 포기해야 함

#### 예외처리 회피

- 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
  - throws 문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 catch 문으로 예외를 잡은 후에 로그를 남기고
  다시 예외를 던지는 것(rethrow)
- 빈 catch 블록으로 잡아서 예외가 발생하지 않는 것처럼 만드는 경우는 드물지만 특별한 의도를 가지고 예외를 복구한것이니 회피한 것은 아님

#### 예외 전환

- 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메서드 밖으로 던지는 것
- 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다는 것
- 두 가지 목적
  - 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우
    - API가 발생하는 기술적인 로우레벨을 상황에 적합한 의미를 가진 예외로 변경하는 것
      - 새로운 사용자를 등록(같은 아이디의 사용자가 있음)
      - SQLException이 나오지만 서비스 계층에서는 왜 SQL?
      - DuplicateUserIdException 같은 예외로 바꿔 던져주는 게 좋음
  - 예외를 처리하기 쉽고 단순하게 만들기 위해 포장(wrap)하는 것
    - 중첩 예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지느 방식은 같음
    - 하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아닌 주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로
    바꾸는 경우에 사용

### 예외처리 전략

#### 런타임 예외의 보편화

- 자바 엔터프라이즈 서버환경은 수많은 사용자가 동시에 요청을 보내고 각 요청이 독립적인 작업으로 취급됨
- 하나의 요청을 처리하는 중에 예외가 발생하면 해당 작업만 중단시키면 그만
- 독립형 애플리케이션과 달리 서버의 특정 계층에서 예외가 발생했을 때 작업을 일시 중지하고 사용자와 커뮤니케이션하면서 예외상황을 복구할 수 있는 방법이 없음
- 예외상황을 미리 파악하고 차단혹은 서버 관리자나 개발자에게 통보해주는 편이 남

#### 애플리케이션 예외

- 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에의해 의도적으로 발생시키고 반드시 catch 해서 무언가
조치를 취하도록 요구하는 예외
  - 애플리케이션 예외라고 함
- 은행 출금시 잔고 부족 상황
  - 정상적인 출금처리를 했을 경우와 잔고 부족이 발생했을 경우에 각각 다른 종류의 리턴 값
    - 결과 상태를 나타내는 정보로 리턴 값을 사용함
      - 0 혹은 -1과 같은 특별한 값
    - 결과 값에 대한 정책이 완벽하게 갖춰져 있고, 사전에 상수로 정의해둔 표준 코드를 사용하지 않는다면 개발자 사이의 의사소통 문제로 인해
    제대로 동작하지 않을 위험이 있음
  - 정상적인 흐름을 따르는 코드는 그대로 두고 잔고 부족과 같은 예외 상황에서는 비즈니스적인 의미를 띤 예외를 던지도록 만드는 것

### SQLException은 어떻게 됐나?

- 대부분의 SQLException은 복구할 방법이 없음
- 스프링의 JdbcTemplate은 모든 SQLException을 런타임 예외인 DataAccessException으로 포장해서 던져줌

------------

## 예외 전환

- 스프링의 JdbcTemplate이 던지는 DataAccessException
  - 복구가 불가능한 예외인 SQLException에 대해 애플리케이션 레벨에서 신경쓰지 않도록 함
  - SQLException에 담긴 다루기 힘든 상세한 예외정보를 의미 있고 일관성 있는 예외인 DataAccessException으로 전환해 추상화하는 용도로 씀

### JDBC의 한계

#### 비표준 SQL

- 대부분의 DB는 비표준 SQL문을 지원함

#### 호환성 없는 SQLException의 DB 에러 정보

- DB마다 SQL만 다른 것이 아니라 에러의 종류와 원인도 제각각임
- DB 에러 코드는 DB 벤더가 정의한 고유한 에러 코드를 사용하기 때문
- S

### DB 에러 코드 매핑을 통한 전환

- 스프링은 DataAccessException이라는 SQLException을 대체할 수 있는 런타임 예외를 정의하고, 에러 코드를 매핑하여 사용자에게 돌려줌
- 드라이버나 DB 메타정보를 참고하여 DB 종류를 확인하고 DB별로 미리 준비된 매핑정보를 참고해 적절한 예외 클래스를 선택함
  - DB가 달라져도 같은 종류의 에러라면 동일한 예외를 받을 수 있음

### DAO 인터페이스와 DataAccessException 계층구조

- 여러 프레임워크들이 던지는 예외가 다름
  - JPA: PersistenceException
  - Hibernate: HibernateException
  - JDO: JdoException
- 가장 단순한 방법은 인터페이스에 throws Exception
  - 무책임
- 사실 대부분의 프레임워크에서는 런타임 예외로 바꿔 던지기 때문에 체크하지 않아도 되지만 DAO를 사용하는 클라이언트 입장에서는
DAO의 사용 기술에 따라서 예외 처리 방법이 달라져야 하기 때문에 인터페이스가 있다 하더라도 DAO의 기술에 의존적이 될 수 밖에 없음

#### 데이터 엑세스 예외 추상화와 DataAccessException 계층 구조

- 스프링은 자바의 다양한 데이터 엑세스 기술을 사용할 때 발생하는 예외들을 추상화해서 DataAccessException 계층구조 안에 정리해놈
- 하지만 일부 기술에서만 발생하는 예외도 있음
  - JPA, 하이버네이트처럼 ORM에서는 발생하지만 JDBC에는 없는 예외
- 공통적으로 나타나는 예외를 포함해서 데이터 액세스 기술에서 발생 가능한 대부분의 예외를 계층구조로 분류해놓음
-  인터페이스 사용, 런타임 예외 전환과 함께 DataAccessException 예외 추상화를 적용하면 데이터 액세스 기술과 구현 방법에 독립적인 이상적인 DAO를
만들 수 있음

### 기술에 독립적인 UserDao 만들기

#### 인터페이스 적용

```java
public interface UserDao {
    void add(User user);
    User get(String id);
    List<User> getAll();
    void deleteAll();
    int getCount();
}

public class UserDaoJdbc implements UserDao {
  ...
}
```

## 정리

- 예외를 잡아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발하는 것은 위험
- 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 함
- SQLException의 에러 코드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환될 필요가 있음
- 스프링은 DataAccessException을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공함
- DAO를 데이터 액세스 기술에서 독립시키려면 인터페이스 도입과 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요