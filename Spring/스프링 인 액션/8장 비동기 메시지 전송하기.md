# 비동기 메시지 전송하기

- REST를 사용한 동기화 통신뿐만이 아닌 비동기 메시징을 사용할 수 있다.
- 비동기 메시징은 애플리케이션 간에 응답을 기다리지 않고 간접적으로 메시지를 전송하는 방법이다.
  - 통신하는 애플리케이션 간의 결합도를 낮추고 확장성을 높여준다.
- 스프링이 제공하는 비동기 메시징
  - JMS(Java Message Service)
  - RabbitMQ
  - AMQP(Advanced Message Queueing Protocol)
  - 아파치 카프카(Apache Kafka)

---------------------

## JSM로 메시지 전송하기

- JMS는 두 개 이상의 클라이언트 간에 메시지 통신을 위한 공통 API를 정의하는 자바 표준이다.
- 스프링은 JmsTemplate이라는 템플릿 기반의 클래스를 통해 JMS를 지원한다.
- JmsTemplate을 사용하면 프로듀서가 큐와 토픽에 메시지를 전송하고, 컨슈머는 그 메시지들을 받을 수 있다.

### JMS 설정하기

- 스타터 의존성 빌드만 추가하면 되지만, 아파치 ActiveMQ 또는 아파치 ActiveMQ Artemis 중 어느 브로커를 사용할지 결정해야 한다.
- 어떤 브로커를 선택하든 메시지를 송수신하는 코드 작성 방법에는 영향을 주지 않으며, 브로커에 대한 연결을 생성하기 위해 스프링을 구성하는 방법만 다르다.
- 기본적으로 스프링은 Artemis 브로커가 localhost의 61616 포트를 리스닝하는 것으로 간주한다.
- 개발 환경에서는 이대로 사용해도 상관 없지만 실무 환경으로 이양할 때는 스프링에게 브로커를 어떻게 사용해야하는지 가르쳐주는 속성을 설정해야 한다.
  - spring.artemis.host
    - 브로커의 호스트
  - spring.artemis.port
    - 브로커의 포트
  - spring.artemis.user
    - 브로커를 사용하기 위한 사용자(선택 속성)
  - spring.artemis.password
    - 브로커를 사용하기 위한 사용자 암호(선택 속성)

### JmsTemplate을 사용해서 메시지 전송하기

- Jms 스타터 의존성이 빌드에 지정되면, 메시지를 송수신하기 위해 주입 및 사용할 수 있는 JmsTemplate을 스프링 부트가 자동 구성한다.
- JmsTemplate이 없다면 메시지 브로커와의 연결 및 세션을 생성하는 코드는 물론이고, 메시지를 전송하는 도중 발생할 수 있는 예외를 처리하는 수많은 코드도
우리가 작성해야 한다.
- 하지만 JmsTemplate을 사용하면 send()와 convertAndSend()의 두 개 메서드만 있으며, 각 메서드는 서로 다른 매개변수를 지원하기 위해
오버로딩되어 있다.

```java
@Service
public class JmsOrderMessagingService implements OrderMessagingService{
    private JmsTemplate jms;
    
    @Autowired
    public JmsOrderMessagingService(JmsTemplate jms){
        this.jms = jms;
    }
    
    @Ovverride
    public void sendOrder(Order order){
          jms.send(new MessageCreator() {
              @Override
              public Message createMessage(Session session) throws JmsException{
                  return session.createObjectMessage(order);
              }
          }
          );
      }
}
```

- sendOrder() 메서드에서는 MessageCreator 인터페이스를 구현한 익명 내부 클래스를 인자로 전달하여 jms.send()를 호출한다.
- 람다를 사용하면 sendOrder() 메서드 코드를 좀 더 깔끔하게 작성할 수 있다.
```java
@Override
public void sendOrder(Order order){
    jms.send(session -> session.createObjectMessage(order));
}
```
- jms.send() 메시지의 도착지를 지정해야 한다.
```yaml
spring:
  jsm:
    template:
      default-destination: tacocloud.order.queue
```
- 기본 도착지가 아닌 다른 곳에 메시지를 전송해야 한다면 send() 메서드의 매개변수로 도착지를 지정해야 한다.

```java
@Bean
public Destination orderQueue(){
    return new ActiveMQQueue("tacocloud.order.queue");
}
```
- 이 Destination 빈이 JmsOrderMessagingService에 주입되면 send()를 호출할 때 이 빈을 사용하여 메시지 도착지를 지정할 수 있다.
```java
@Service
public class JmsOrderMessagingService implements OrderMessagingService{
    private JmsTemplate jms;
    private Destination orderQueue;
    
    @Autowired
    public JmsOrderMessagingService(JmsTemplate jms, Destination orderQueue){
        this.jms = jms;
        this.orderQueue = orderQueue;
    }
    
    @Ovverride
    public void sendOrder(Order order){
          jms.send(new MessageCreator() {
              @Override
              public Message createMessage(Session session) throws JmsException{
                  return session.createObjectMessage(order);
              }
          }
          );
      }
}
```
- send()의 첫 번째 인자로 Destination 객체 대신 도착지 이름만 지정하는 것이 더 쉽다.

```java
@Override
public void sendOrder(Order order){
        jms.send("tacocloud.order.queue",
        session -> session.createObjectMessage(order));
}
```

#### 메시지 변환하고 전송하기

- JmsTemplate의 converAndSend() 메서드는 MessageCreator를 제공하지 않아도 되므로 메시지 전송이 간단하다.
  - 전송될 객체를 converAndSend()의 인자로 직접 전달하면 해당 객체가 Message 객체로 변환되어 전송된다.

```java
@Override
public void sendOrder(Order order){
    jms.convertAndSend("tacocloud.order.queue", order);
}
```

#### 메시지 변환기 구현하기

- MessageConverter는 스프링에 정의된 인터페이스이며, 두 개의 메서드만 정의되어 있다.

```java
public interface MessageConverter{
    Message toMessage(Object object, Session session) throws JMSException, MessageConversionException;
    Object fromMessage(Message message);
}
```

- 간단해서 구현하기 쉽지만, 스프링이 구현해둔 것들을 사용하면 된다.
  - MappingJackson2MessageConverter
    - Jackson 2 Json 라이브러리를 사용해서 메시지를 JSON으로 상호 변환한다.
  - MarshallingMessageConverter
    - JAXB를 사용해서 메시지를 XML로 상호 변환한다.
  - MessagingMessageConverter
    - 수신된 메시지의 MessageConverter를 사용해서 해당 메시지를 Message 객체로 상호 변환한다.
    - JMS 헤더와 연관된 JmsHeaderMapper를 표준 메시지 헤더로 상호 변환한다.
  - SimpleMessageConverter
    - 문자열을 TextMessage로, byte 배열을 BytesMessage로, Map을 MapMessage로, Serializable 객체를 ObjectMessage로
    상호 변환한다.
- 기본적으로는 SimpleMessageConverter가 사용되며, 이 경우 전송될 객체가 Serializable 인터페이스를 구현하는 것이어야 한다.
- 이 메시지 변환기를 사용하는 것이 좋지만 Serializable 인터페이스를 구현해야 한다는 제약을 피하기 위해 MappingJackson2MessageConverter를
사용할 수도 있다.
- 다른 메시지 변환기를 적용할 때는 해당 변환기의 인스턴스를 빈으로 선언만 하면 된다.
```java
@Bean
public MappingJackson2MessageConverter messageConverter(){
    MappingJackson2MessageConverter messageConverter = 
        new MappingJackson2MessageConverter();
    messageConverter.setTypeIdPropertyName("_typeId");
    return messageConverter;
}
```
- 