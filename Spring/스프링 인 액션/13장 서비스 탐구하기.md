# 서비스 탐구하기

-----------

## 마이크로서비스 이해하기

- 그동안 단일 파일로 애플리케이션을 배포하는 것은 당연한 것으로 여겼고, 대부분의 애플리케이션이 그렇게 개발되어 왔다.
  - 작고 간단한 애플리케이션을 개발할 때 좋은 방법이다.
- 단일 애플리케이션은 언뜻 보기엔 간단하나 다음과 같은 문제가 따른다.
  - 전체를 파악하기 어렵다
    - 코드가 점점 더 많아질수록 애플리케이션에 있는 각 컴포넌트의 역할을 알기 어려워진다
  - 테스트가 더 어렵다
    - 애플리케이션이 커지면서 통합과 테스트가 더 복잡해진다
  - 라이브러리 간의 충돌이 생기기 쉽다
    - 애플리케이션의 한 기능에서 필요한 라이브러리 의존성이 다른 기능에서 필요한 라이브러리 의존성과 호환되지 않을 수 있다.
  - 확장 시에 비효율적이다.
    - 시스템 확장을 목적으로 더 많은 서버에 애플리케이션을 배포해야 할 때는 일부가 아닌 전체를 배포해야 한다.
    - 애플리케이션 기능의 일부만 확장하더라도 전체를 배포해야 한다
  - 적용할 테크놀러지를 결정할 때도 애플리케이션 전체를 고려해야 한다
    - 프로그래밍 언어, 런타임 플랫폼, 프레임워크, 라이브러리를 선택할 때 애플리케이션 전체를 고려하여 선택해야 한다
  - 프로덕션으로 이양하기 위해 많은 노력이 필요하다
    - 단일 애플리케이션은 크기와 복잡도 때문에 더 엄격한 개발 프로세스와 철두철미한 테스트가 필요하다
- 마이크로서비스 아키텍처는 분산 아키텍처이므로 네트워크 지연과 같은 문제들이 발생할 수 있다.

---------

## 서비스 레지스트리 설정하기

- 스프링 클라우드는 큰 프로젝트이며, 마이크로서비스 개발을 하는 데 필요한 여러 개의 부속 프로젝트로 구성된다.
  - 이 중 하나가 스프링 넷플릭스

#### 유레카란?

- 유레카는 마이크로서비스 애플리케이션에 있는 모든 서비스의 중앙 집중 레지스트리로 작동한다.
- 유레카 자체도 마이크로서비스로 생각할 수 있으며, 더 큰 애플리케이션에서 서로 다른 서비스들이 서로를 찾는 데 도움을 주는 것이 목적이다.
- 서비스 인스턴스가 시작될 때 해당 서비스는 자신의 이름을 유레카에 등록한다.
- 다른 서비스가 해당 서비스를 사용해야 할때, 특정 호스트의 이름과 포트 정보를 유레카에서 찾으면, 유레카가 알려준다.
- 다른 서비스가 해당 서비스의 어떤 인스턴스를 사용할지 결정할 때 특정 인스턴스를 매번 선택하는 것을 피하기 위해 클라이언트 측에서 동작하는 로드 밸런싱
알고리즘을 적용하는 것이 좋은데 이때 사용될 수 있는 것이 또 다른 넷플릭스 프로젝트인 리본(Ribbon)이다.
- 리본은 다른 서비스를 대신하여 해당 서비스 인스턴스를 선택하는 클라이언트 측의 로드 밸런서다.

#### 클라이언트 측의 로드 밸런서를 사용하는 이유

- 클라이언트 측의 로드 밸런서인 리본은 중앙 집중화된 로드 밸런서에 비해 몇 가지 장점을 갖는다.
  - 각 클라이언트에 하나의 로컬 로드 밸런서가 있으므로 클라이언트의 수에 비례하여 자연스럽게 로드 밸런서의 크기가 조정된다.
  - 서버에 연결된 모든 서비스에 획일적으로 같은 구성을 사용하는 대신, 로드 밸런서는 각 클라이언트에 가장 적합한 로드 밸런싱 알고리즘을
  사용하도록 구성할 수 있다.

### 유레카 구성하기

- 하나보다는 여러 개의 유레카 서버가 함께 동작하는 것이 안전하므로 유레카 서버들이 클러스터로 구성되는 것이 좋다.
  - 단일 장애점(Single Point Of Failure)은 생기지 않기 때문
- 기본적으로 유레카는 다른 유레카 서버로부터 서비스 레지스트리를 가져오거나 다른 유레카 서버의 서비스로 자신을 등록하기도 한다.

```yaml
server:
  port: 8761
eureka:
  instance:
    hostname: localhost
  client:
    fetch-registry: false
    register-with-eureka: false
    service-url:
      default-zone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

#### 자체-보존 모드를 비활성화시키기

- eureka.server.enableSelfPreservation
- 유레카 서버는 서비스 인스턴스가 자신을 등록하고 등록 갱신 요청을 30초마다 전송하기를 기대한다.
- 세 번의 갱신 기간 동안 서비스 인스턴스로부터 등록 갱신 요청을 받지 못하면 해당 서비스 인스턴스의 등록을 취소하게 된다.
- 중단되는 서비스의 수가 임계값을 초과하면 유레카 서버는 네트워크 문제가 생긴 것으로 간주하고 레지스트리에 등록된 나머지 서비스 데이터를 보존하기 위해
자체 보존 모드가 된다.
  - 추가적인 서비스 인스턴스의 등록 취소가 방지된다.
- 프로덕션 설정에서는 자체 보존 모드를 true로 설정하는 것이 좋다.

### 유레카 확장하기

#### 프로덕션 환경의 스프링 클라우드 서비스

- 두 개 이상의 유레카 인스턴스를 구성하는 가장 쉽고 간단한 방법은 application.yml 파일에 스프링 프로파일을 지정하는 것이다.
- 한 번에 하나씩 프로파일을 사용해서 유레카를 두 번 시작시키면 된다.

----------------

## 요약

- 스프링 클라우드 넷플릭스는 자동-구성과 @EnableEurekaServer 애노테이션을 사용해서 넷플릭스 유레카 서비스 레지스트리를 쉽게 생성할 수 있다.
- 다른 서비스가 찾을 수 있도록 마이크로서비스는 이름을 사용해서 자신을 유레카 서버에 등록한다.
- 리본은 클라이언트 측의 로드 밸런서로 동작하면서 서비스 이름으로 서비스 인스턴스를 찾아 선택한다
- 리본 로드 밸런싱으로 처리되는 RestTemplate 또는 Feign에 의해 자동으로 구현되는 인터페이스를 사용해서 클라이언트 코드는 자신의 REST 클라이언트를
정의할 수 있다.
- 로드 밸런싱된 RestTemplate, WebClient 또는 Feign 클라이언트 인터페이스 중 어느 것을 사용하더라도 서비스의 위치가 클라이언트 코드에 하드코딩되지
않는다.