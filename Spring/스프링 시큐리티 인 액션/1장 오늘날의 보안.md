# 오늘날의 보안

- 소프트웨어 시스템의 개발에 관여하는 모든 사람들이 처음부터 보안을 고려해야 한다.
- 성능, 확장성, 가용성, 보안과 같은 소프트웨어의 비기능적 특징은 시간이 지남에 따라 단기적 영향과 장기적 영향을 미칠 수 있다.
- 소프트웨어 시스템을 다룰 때는 여러 비기능적 측면을 고려해야 한다.

-----------

## 스프링 시큐리티: 개념과 장점

- 스프링 시큐리티는 인증과 접근 제어를 위해 세부적인 맞춤 구성이 가능한 강력한 프레임워크이다.
  - 스프링 애플리케이션에 보안을 적용하는 과정을 크게 간소화한다.
- 스프링 시큐리티는 스프링 애플리케이션에서 애플리케이션 수준 보안을 구현하기 위한 사실상의 표준이지만, 스프링 시큐리티를 이용해도
애플리케이션이 자동으로 보호되는 것은 아니다.
- 개발자는 애플리케이션의 필요에 맞게 스프링 시큐리티를 구성하고 맞춤 구성하는 방법을 알아야 하는데, 기능적 요구 사항에서 아키텍처까지 여러 요소에 따라
방법이 달라진다.
- 스프링 시큐리티 구성 요소의 다른 책임은 시스템의 다른 부분 간의 데이터 전송 및 저장과 관련이 있다.

--------

## 소프트웨어 보안이란?

- 보안은 계층별로 적용해야 하며 각 계층에 다른 접근 방식이 필요하다.
- 각 계층을 더 잘 보호할수록 악읮거인 대상이 데이터에 접근하거나 무단 작업을 수행할 가능성이 낮아진다.
- 소프트웨어 시스템에서 보안은 애플리케이션 수준에만 적용되는 것이 아니다.
  - 네트워킹의 경우 여러 문제를 고려하고 특정한 관행을 적용해야 한다.
  - 스토리지에도 완전히 다른 사항이 적용된다.
- 애플리케이션 수준 보안은 애플리케이션이 실행되는 환경과 애플리케이션이 처리하고 저장하는 데이터를 보호하기 위해 해야 하는 모든 것을 나타낸다.
  - 애플리케이션에 사용되고 영향을 받는 데이터에만 국한되는 문제가 아님.
  - 악의적인 개인이 전체 시스템에 영향을 줄 수 있는 취약성이 있을 수 있음
    - 악성 사용자가 애플리케이션 보안이 적용되지 않은 VM에 침입하는 데 성공하면 시스템에 속한 다른 애플리케이션 도 통제 할 수 있다. 두 개의 서로 다른
    AZ 간에 통신이 이루어지면 악성 사용자는 더 쉽게 메시지를 가로챌 수 있으며 이 취약성을 악용해 데이터를 훔치거나 사용자를 가장할 수 있다.
- 인증과 권한 부여는 사실상 거의 모든 애플리케이션에 사용된다.
  - 인증은 애플리케이션이 사용자(사람 또는 다른 애플리케이션)를 식별하는 방법이다.
  - 사용자를 식별하는 목적은 나중에 그들이 무엇을 하도록 허용해야 하는지 결정하기 위한 것인데 이것이 권한 부여다.

------------

## 보안이 중요한 이유는 무엇인가?

- 보안에 충분한 주의를 기울이지 않으면 원치 않는 대가를 치러야 할 수 있다.
- 대가는 보통 금전적 비용이지만 수익성 손실을 초래하는 여러 형태로 나타나기도 한다.

-------------

## 웹 애플리케이션의 일반적인 보안 취약성

- 애플리케이션에 보안을 적용하는 방법을 배우기 전에 무엇으로부터 애플리케이션을 보호하는지 알아야 한다.
- 일반적인 취약성의 목록
  - 인증 취약성
  - 세션 고정
  - XSS(교차 사이트 스크립팅)
  - CSRF(사이트 간 요청 위조)
  - 주입
  - 기밀 데이터 노출
  - 메서드 접근 제어 부족
  - 알려진 취약성이 있는 종속성 이용

### 인층과 권한 부여의 취약성

- 인증(Authentication)은 애플리케이션이 이를 이용하려는 사람을 식별하는 프로세스를 말한다.
- 권한 부여(Authorization)는 인증된 호출자가 특정 기능과 데이터에 대한 이용 권리가 있는지 확인하는 프로세스다.
  - 모바일 은행 애플리케이션을 예로 들면 대부분의 인증된 사용자는 자금을 이체할 수 있지만, 자신의 계좌에서만 가능하다.
- 인증 취약성이 있다는 것은 사용자가 악의를 가지고 다른 사람의 기능이나 데이터에 접근할 수 있다는 의미다.
  - 스프링 시큐리티와 같은 프레임워크로 이러한 취약성이 발생할 우려를 줄일 수 있지만, 올바르게 이용하지 않으면 위험성은 있다.
    - 스프링 시큐리티를 이용해 특정 역할이 있는 인증된 사용자만 특정 엔드포인트에 접근하도록 정의할 수 있지만, 데이터 수준에 제한이 없으면 다른 사용자의
    데이터를 이용할 수 있는 허점이 생길 수 있다.

### 세션 고정이란?

- 세션 고정(Session fixation) 취약성은 웹 애플리케이션의 더 구체적이고 심각한 약점이다.
- 이 취약성이 존재하면 공격자는 이미 생성된 세션 ID를 재이용해 유효한 사용자를 가장할 수 있다.
- 이 취약성은 웹 애플리케이션이 인증 프로세스 중에 고유한 세션 ID를 할ㅈ당하지 않아 기존 세션 ID가 재사용될 가능성이 있을 때 발생한다.

### XSS(교차 사이트 스크립팅)란?

- XSS(교차 사이트 스크립팅)는 서버에 노출된 웹 서비스로 클라이언트 쪽 스크립트를 주입해 다른 사용자가 이를 실행하도록 하는 공격이다.
  - 원치 않는 외래 스크립트의 실행을 방지하기 위해 이용하기 전이나 심지어 저장하기 전에도 요청을 적절하게 소독하는 과정이 필요하다.
  - 이 취약성이 악용되면 계정 가장(세션 고정과 결합)이나 DDoS와 같은 분산 공격 참여 등의 결과가 발생할 수 있다.

### CSRF(사이트 간 요청 위조)란?

- CSRF(사이트 간 요청 위조)도 웹 애플리케이션에 흔한 취약성이다.
- CSRF 공격은 특정 서버에서 작업을 호출하는 URL을 추출해 애플리케이션 외부에서 재사용할 수 있다고 가정한다.
- 서버가 요청의 출처를 확인하지 않고 무턱대고 실행하면 다른 모든 곳에서 요청이 실행될 수 있다.
- 공격자는 CSRF를 통해 동작을 숨겨서 사용자가 서버에서 원치 않는 동작을 실행할 수 있다.
  - 시스템의 데이터를 변경하는 동작을 실행한다.

### 웹 애플리케이션의 주입 취약성 이해

- 주입(Injection) 공격에서 공격자는 시스템에 특정 데이터를 유입하는 취약성을 이용한다.
- 주입 공격은 시스템에 피해를 가할 목적의 클라이언트 쪽 스크립트를 주입하거나, SQL, XPath, OS 명령, LDAP 주입 등 여러 가지가 있다.

### 민감한 데이터의 노출 처리하기

- 기밀 데이터 공개는 복잡성 측면에서 가장 기초적이고 단순한 취약성 같지만 여전히 흔한 실수 중 하나로 남아 있다.
  - 많은 온라인 자습서와 여러 서적에서 설명의 편의를 위해 구성 파일에서 직접 자격 증명을 정의하기 때문일 수 있다.
- 민감한 데이터의 노출과 관련해서는 애플리케이션에서 콘솔에 기록하거나 데이터베이스에 저장하는 로그 정보도 있다.
  - 공개 정보가 아닌 것은 절대 로그에 기록하지 말아야 한다. 여기서 공개라는 것은 누구든지 해당 정보에 접근하고 볼 수 있다는 뜻이다.
- 애플리케이션에 예외가 발생했을 때 서버가 클라이언트에 반환하는 정보에 주의할 필요가 있다.
  - 잘못된 요청을 처리하는 과정에서 애플리케이션이 너무 많은 세부 정보를 반환해서 구현을 노출할 수 있다.
  - 동작도 데이터 노출을 통한 취약성이다.
    - NPE가 발생하는 경우 응답 본문에 예외가 나오지 않아야 하고, 상태는 500이 아닌 400이어야 한다.
- 응답에 예외 스택을 넣는 것도 좋지 않다.
  - 애플리케이션의 내부 구조가 공개된다.
    - 명명 방식, 특정 작업에 이용되는 객체, 객체 간의 관계를 알 수 있다.
    - 로그를 통해 애플리케이션이 이용하는 종속성의 버전을 알 수도 있다.
- 공격자는 극히 작은 세부 정보까지 활용한다.

```json
응답 A
{
  "상태": 401,
  "오류": "권한 없음",
  "메시지": "사용자 이름이 올바르지 않음",
  "경로": "/login"
}
응답 B
{
  "상태": 401,
  "오류": "권한 없음",
  "메시지": "암호가 올바르지 않음",
  "경로": "/login"
}
```
- 같은 인증 엔드포인트를 호출한 다른 결과를 보여준다.
- 클래스 디자인이나 시스템 인프라에 대한 정보는 노출되지 않은 것 같지만 컨텍스트 정보를 공개하는 메시지에는 숨겨진 취약성이 있을 수 있다.
- 클라이언트로 반환되는 응답이 특정 입력이 무엇인지 추측하게 도와줘서는 안 된다.
- 앞의 예에서 두 경우 모두 동일한 메시지를 제공해야 한다.
```json
{
  "상태": 401,
  "오류": "권한 없음",
  "메시지": "사용자 이름 또는 암호가 올바르지 않음",
  "경로": "/login"
}
```

### 메서드 접근 제어 부족이란?

- 애플리케이션 수준에도 한 계층에만 권한 부여를 적용하면 안 된다.
- 때에 따라서는 특정 기능을 아예 호출할 수 없게 해야 한다.
- 권한 부여가 엔드포인트 수준에서만 수행된다면 리포지토리나 서비스계층에서는 인증된 사용자에게 속하지 않은 계정을 요청해도 반환하기 때문에
애플리케이션의 모든 계층에 권한 부여를 적용해야 한다.

### 알려진 취약성이 있는 종속성 이용

- 개발하는 애플리케이션이 아니라 기능을 만들기 위해 이용하는 라이브러리나 프레임워크 같은 종속성에 취약성이 있을 수 있다.
- 소프트웨어를 개발할 때는 알려진 취약성이 있는 종속성을 이용하지 않도록 필요한 모든 조치를 취해야 한다.

----------------

## 다양한 아키텍처에 적용된 보안

- 소프트웨어 아키텍처가 서로 다르면 가능한 유출과 취약성도 서로 다르다.
- 아키텍처는 애플리케이션의 스프링 시큐리티 구성을 선택할 때 큰 영향을 미치며 기능적 요구 사항과 비기능적 요구 사항도 마찬가지다.
- 구현하는 솔루션에 따라 보안 접근 방식이 다르므로 스프링 시큐리티의 구성도 다르다.

### 일체형 웹 애플리케이션 설계

- 이 애플리케이션에는 백엔드와 프론트엔드 개발 간의 직접적인 분리가 없다.
- 일반적으로 이러한 종류의 애플리케이션이 보는 방식은 애플리케이션이 HTTP 요청을 수신하고 HTTP 응답을 클라이언트에 보내는 일반 서블릿
흐름을 통하는 것이다.
- 때에 따라 각 클라이언트에 대해 더 많은 HTTP 요청을 통해 특정 세부 정보를 저장하기 위한 서버 쪽 세션이 있을 수 있다.
- 세션이 있는 한 세션 고정 취약성과 CSRF 가능성을 고려해야 하고, HTTP 세션에 저장하는 정보도 고려해야 한다.

### 백엔드/프론트엔드 분리를 위한 보안 설계

- 일반적으로 서버 쪽 세션을 줄이고 클라이언트 쪽 세션으로 대체하는 것이 좋다.
- CSRF 및 CORS 구성은 일반적으로 더 복잡하다.
- 엔드포인트 인증에 HTTP Basic을 이용하려면 호출마다 자격 증명을 전송해야 하지만, 자격 증명은 암호화되지 않으므로 각 엔드포인트 호출의 헤더에
자격 증명이 노출된다.(권장되지 않는다)
- OAuth 2 흐름이라는 더 나은 접근법을 이용하는 인증과 권한 부여를 사용한다.

### OAuth 2 흐름 이해

- 백엔드에 요청할 때마다 자격 증명을 다시 전송하고 자격 증명을 클라이언트 쪽에 저장하는 것은 분명 좋지 않은 방법이며,
OAuth 2 흐름으로 인증과 권한 부여를 구현하는 것이 더 나은 방법이다.
- OAuth 2 프레임워크는 권한 부여 서버와 리소스 서버라는 두 가지 별도의 엔티티를 정의한다.
- 권한 부여 서버의 목적은 사용자에게 권한을 부여하고 사용자의 이용 권리 집합을 지정하는 토큰을 제공하는 것이다.
  - 이 기능을 구현하는 백엔드 부분을 리소스 서버라고 하며 호출할 수 있는 엔드포인트는 보호된 리소스로 볼 수 있다.
- OAuth 2 권한 부여 흐름
  - 사용자가 애플리케이션의 기능에 접근한다. 애플리케이션은 백엔드의 리소스를 호출해야 한다.
  - 애플리케이션이 리소스를 호출하려면 먼저 엑세스 토큰을 얻어야 하므로 권한 부여 서버를 호출해서 토큰을 얻는다. 이 요청을 위해
  사용자 자격 증명이나 때에 따라 갱신 토큰을 보낸다.
  - 자격 증명이나 갱신 토큰이 올바르면 권한 부여 서버가 새로운 액세스 토큰을 클라이언트로 반환한다.
  - 필요한 리소스를 호출할 때 리소스 서버에 대한 요청의 헤더는 액세스 토큰을 이용한다.
- OAuth 2 흐름의 이점
  - 클라이언트는 사용자 자격 증명을 저장할 필요 없이 액세스 토큰과 갱신 토큰만 저장하면 된다.
  - 애플리케이션은 사용자 자격 증명을 네트워크에 노출하지 않는다.
  - 누군가가 토큰을 가로채면 사용자 자격 증명을 무효로 할 필요 없이 토큰을 실격시킬 수 있다.
  - 톸느을 이용하면 제삼자가 사용자를 가장하지 않고도 사용자 대신 리소스에 접근할 수 있다. 물론 이 경우 공격자가 토큰을 훔칠 수 있지만
  토큰은 일반적으로 수명이 제한되므로 이 취약성을 악용할 수 있는 기간도 제한된다.

### API 키, 암호화 서명, IP 검증을 이용해 요청 보안

- 두 백엔드 구성 요소 간에 요청이 있을 때 이 접근법이 필요할 수 있다.
  - 요청 및 응답 헤더에 정적 키 이용
  - 암호화 서명으로 요청 및 응답 서명
  - IP 주소에 검증 적용
- 정적 키를 이용하는 것은 가장 약한 접근법이다.
  - 네트워크에서 키 값을 교환하는 것이니 트래픽이 데이터 센터 외부로 이동하면 가로채기 쉽다.
  - 이 접근법을 이용할 때는 일반적으로 IP 주소 허용 목록을 함께 결합한다.
- 통신의 신뢰성을 테스트하는 더 좋은 방법은 암호화 서명을 이용하는 것이다.
  - 구현은 두 개의 비대칭 키 쌍을 이용할 수 있으며 개인 키를 교환하지 않는다고 가정한다.
  - 서명을 계산하는 데 더 많은 리소스가 소비된다는 단점이 있다.
- IP 주소 검증
  - 애플리케이션이 수락하도록 구성한 IP 주소 외의 주소에서 오는 요청을 거부한다고 가정한다.
  - IP 검증은 애플리케이션 수준에서 수행되지 않고 훨씬 이전의 네트워킹 계층에서 수행된다.

-----------

## 요약

- 스프링 시큐리티는 스프링 애플리케이션을 보호하기 위한 가장 인기 있는 선택이며 다양한 스타일과 아키텍처에 적용할 수 있는 갖가지 대안을 제공한다.
- 시스템의 계층별로 보안을 적용해야 하며 계층별로 다른 관행을 이용해야 한다.
- 보안은 소프트웨어 프로젝트를 시작할 때부터 고려해야 하는 공통 관심사다.
- 일반적으로 취약성을 예방하는 투자 비용보다 공격의 대가가 훨씬 크다.
