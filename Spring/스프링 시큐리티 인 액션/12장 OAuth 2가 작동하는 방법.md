# OAuth 2가 작동하는 방법

------------

## OAuth 2 프레임워크

- OAuth 2를 권한 부여 프레임워크라고 부르는 경우가 많으며, 타사 웹사이트나 웹이 리소스에 접근할 수 있게 허용하는 것이
주 목적이다.
  - 종종 위임 프로토콜이라고 부르기도 한다.
- OAuth 2는 특정 구현이나 라이브러리가 아니다.
- 모든 요청에 대한 자격 증명을 보내는 방식은 특정한 경우에는 괜찮을 수 있지만 일반적으로 다음을 의미하기 때문에 바람직하지 않다.
  - HTTP Basic 인증(모든 요청에 대해 자격 증명을 보냄)
  - 네트워크를 통해 자격증명이 자주 공유된다.
  - 클라이언트가 자격 증명을 저장해 인증 및 권한 부여 요청과 함꼐 자격 증명을 서버에 보낼 수 있게 한다.

-----------

## OAuth 2 인증 아키텍처의 구성 요소

- OAuth 2 구성 요소는 다음을 포함한다
  - 리소스 서버
    - 사용자가 소유한 리소스를 호스팅하는 서버.
    - 리소스는 사용자의 데이터이거나 사용자가 수행할 수 있는 작업일 수 있다.
  - 사용자(또는 리소스 소유자)
    - 리소스 서버가 노출하는 리소스를 소유하는 개인
    - 일반적으로 사용자는 사용자 이름과 암호로 신원을 증명함
  - 클라이언트
    - 사용자를 대신해 사용자가 소유한 리소스에 접근하는 애플리케이션
    - 클라이언트는 클라이언트 ID와 클라이언트 비밀을 이용해 신원을 증명.
    - 이러한 자격 증명은 사용자 자격 증명과는 다름
    - 클라이언트는 요청할 때 자신을 증명하는 자체 자격 증명이 필요
  - 권한 부여 서버
    - 클라이언트가 리소스 서버가 노출하는 사용자의 리소스에 접근할 권한을 부여하는 애플리케이션
    - 권한 부여 서버는 클라이언트가 사용자 대신 리소스에 접근 권한이 있다고 결정하면 토큰을 발급함.
    - 클라이언트는 이 토큰을 이용해 권한 부여 서버에서 권한을 받았음을 리소스 서버에 증명함.
    - 리소스 서버는 유효한 토큰이 있으면 클라이언트가 요청한 리소스에 접근하게 허용함.

------------

## OAuth 2를 구현하는 방법 선택

- OAuth 2를 이용한다는 것은 권한 부여에 토큰을 이용한다는 뜻이다.
- OAuth 2는 그랜트(grant)라고 하는 토큰을 얻는 여러 방법을 제공한다
- 일반적인 OAuth 2 그랜트 유형
  - 승인 코드
  - 암호
  - 갱신 토큰
  - 클라이언트 자격 증명

### 승인 코드 그랜트 유형의 구현

- 가장 많이 이용되는 OAuth 2 흐름 중 하나이다.
- 승인 코드 그랜트 유형의 작동 단계
1. 인증 요청을 한다
2. 액세스 토큰을 얻는다.
3. 보호된 리소스를 호출한다.


#### 1단계: 승인 코드 그랜트 유형으로 인증 요청 수행

- 클라이언트는 사용자가 인증해야 하는 권한 부여 서버의 엔드포인트로 사용자를 리디렉션한다.
- 사용자를 권한 부여 서버로 리디렉션할 때 클라이언트는 다음 세부 정보가 포함된 요청 쿼리로 권한 부여 엔드포인트를 호출한다.
  - response_type
    - 클라이언트가 코드를 기대한다는 것을 권한 부여 서버에 알리는 값인 code를 포함한다.
  - client_id
    - 애플리케이션 자체를 식별하는 클라이언트 ID 값
  - redirect_uri
    - 인증 성공 후 사용자를 리디렉션할 위치를 권한 부여 서버에 알려준다.
    - 때때로 권한 부여 서버는 각 클라이언트의 기본 리디렉션 URI를 이미 알고 있으므로 보낼 필요가 없다.
  - scope
    - 허가된 권한과 비슷하다
  - state
    - CSRF 보호를 위한 CSRF 토큰을 정의한다.
- 인증에 성공하면 권한 부여 서버는 리디렉션 URI로 클라이언트를 다시 호출하고 코드와 상태 값을 제공한다.
- 클라이언트는 상태 값이 요청에 보낸 것과 같은지 검사해 다른 사람이 리디렉션 URI를 호출하려는 것이 아닌지 확인한다.

#### 2단계: 승인 코드 그랜트 유형으로 액세스 토큰 얻기

- 1단계에서 생성된 코드는 사용자가 리소스에 접근할 수 있도록 사용자가 인증했다는 클라이언트의 증명이다.
- 클라이언트는 토큰을 얻기 위해 코드로 권한 부여 서버를 호출한다.
- 권한 부여 서버가 곧바로 액세스 토큰을 반환하지 않는 이유는 실제 올바른 클라이언트에서 받았는지 확인하지 않은
액세스 토큰으로 리디렉션 URI를 곧바로 호출한다는 흐름이 덜 안전하기 때문이다.
  - 먼저 승인 코드를 보내도록 하므로 클라이언트는 액세스 토큰을 얻기 위해 자격 증명으로 자신이 누구인지 다시 증명해야 한다.
- 클라이언트는 액세스 토큰을 얻기 위해 다음 사항을 제시하고 호출한다.
  - 사용자의 허가를 입증하는 승인 코드
  - 자신이 승인 코드를 가로챈 다른 사람이 아니며 실제로 같은 클라이언트임을 증명하는 자격 증명
- 클라이언트는 권한 부여 서버에 요청하고 이 요청에는 다음 세부 정보가 들어 있다.
  - code
    - 1단계에서 받은 승인 코드. 사용자가 인증받았음을 증명한다.
  - client_id 및 client_secret
    - 클라이언트의 자격 증명
  - redirect_uri
    - 1단계에서 검증에 사용된것과 같다
  - grant_type
    - 이용된 흐름의 유형을 식별하며 authorization_code 값을 가진다.
    - 서버가 여러 흐름을 지원할 수 있으므로 항상 현재 실행된 인증 흐름이 무엇인지 지정하는 것이 필수적이다.
- 서버는 이에 대한 응답으로 access_token을 반환한다.
  - 이 토큰은 클라이언트가 리소스 서버에서 노출하는 리소스를 호출하는 데 사용할 수 있는 값이다.

#### 3단계: 승인 코드 그랜트 유형으로 보호된 리소스 호출

- 클라이언트는 리소스 서버의 엔드포인트를 호출할 때 권한 부여 요청 헤더의 액세스 토큰을 사용한다.
- 그랜트 유형 승인 코드에 대한 비유
  - 서점에 책을 주문함(나: 리소스 사용자)
  - 책을 대신 가져오라고 부탁함(친구: 클라이언트)
  - 서점은 나에게 전화해 책을 받아올 사람을 보냈는지 확인(권한 부여 서버가 사용자에게 직접 전화)
  - 서점은 친구에게 책을 건네줌(리소스 서버가 클라이언트에게 리소스를 전달함)

    
### 암호 그랜트 유형 구현

- 리소스 소유자 자격 증명 그랜트 유형이라고도 한다.
- 애플리케이션은 클라이언트가 사용자 자격 증명을 수집하고 이를 이용해 인증하며 권한 부여 서버에서 액세스 토큰을 얻는다.
- 이 인증 흐름은 클라이언트와 권한 부여 서버를 같은 조직에서 구축하고 유지 관리할 때만 이용한다.
- 암호 그랜트 유형은 다음과 같은 두 단계로 처리된다.
1. 액세스 토큰을 요청한다. 
2. 액세스 토큰을 이용해 리소스를 호출한다.

#### 1단계: 암호 그랜트 유형으로 액세스 토큰 요청

- 클라이언트는 사용자 자격 증명을 수집하고 권한 부여 서버를 호출해 액세스 토큰을 얻는다.
- 클라이언트는 액세스 토큰을 요청할 때 다음 세부 정보를 함께 보낸다.
  - grant_type
    - password 값을 가진다
  - client_id 및 client_secret
    - 클라이언트가 자신을 인증하기 위한 자격 증명
  - scope
    - 허가된 권한
  - username 및 password
    - 사용자 자격 증명.
    - 일반 텍스트 형식으로 요청 헤더의 값으로 전송된다.

#### 2단계: 암호 그랜트 유형으로 액세스 토큰을 이용해 리소스 호출

- 액세스 토큰을 얻은 클라이언트는 이 토큰으로 리소스 서버의 엔드포인트를 호출할 수 있으며 승인 코드 그랜트 유형을 이용할 때와 마찬가지로
권한 부여 요청 헤더에 액세스 토큰을 추가한다.
- 암호 그랜트 유형에 대한 비유
  - 승인 코드 유형의 비유와 비슷하나, 내가 친구에게 신분증을 주어 직접 증명하게 함
    - 사용자가 클라이언트를 신뢰해야 함

### 클라이언트 자격 증명 그랜트 유형 구현

- OAuth 2가 지원하는 가장 단순한 그랜트 유형이며 사용자가 관여하지 않을 때, 즉 두 애플리케이션 간의 인증을 구현할 때
이용할 수 있다.
- 클라이언트 자격 증명 그랜트 유형을 처리하는 과정은 암호 그랜트 유형과 비슷하나 액세스 토큰을 요청할 때 자격 증명이 필요하지 않다.
- 클라이언트 자격 증명 구현 단계

1. 액세스 토큰을 요청한다.
2. 액세스 토큰을 이용해 리소스를 호출한다

#### 1단계: 클라이언트 자격 증명 그랜트 유형으로 액세스 토큰 얻기

- 클라이언트는 액세스 토큰을 얻기 위해 다음 세부 정보와 함께 권한 부여 서버에 요청을 보낸다.
  - grant_type
    - client_credentials 값을 가진다.
  - client_id 및 client_secret
    - 클라이언트 자격 증명을 나타낸다
  - scope
    - 허가된 권한을 나타낸다

#### 2단계: 클라이언트 자격 증명 그랜트 유형으로 액세스 토큰을 이용해 리소스 호출

- 권한 부여 요청 헤더에 액세스 토큰을 추가하여 엔드포인트를 호출한다.


### 갱신 토큰으로 새 액세스 토큰 얻기

- 만료되지 않는 토큰은 거의 사용자 자격 증명만큼 강력하기 때문에, 가능하면 토큰이 최소한의 수명을 가지도록 해야 한다.
- 이용된 그랜트 유형에 따라 클라이언트는 새 액세스 토큰을 얻기 위해 흐름을 다시 실행할 수 있다.
- 권한 부여 서버는 재인증할 필요를 없애기 위해 액세스 토큰과는 값과 용도가 다른 갱신 토큰을 발행할 수 있다.
- 앱은 갱신 토큰으로 재인증 없이 새 액세스 토큰을 얻을 수 있다.
- 자격 증명을 안전하지 않게 저장하거나 매번 사용자를 리디렉션할 필요 없이 갱신 토큰을 저장하고 필요할 때 이용해 새 엑세스 토큰을 얻을 수 있다.
- 갱신 토큰을 가진 클라이언트는 액세스 토큰이 만료될 때 다음 세부 정보가 포함된 요청을 발행한다.
  - refresh_token 값을 가지는 grant_type
  - 갱신 토큰의 값을 가지는 refresh_token
  - 클라이언트의 자격 증명을 포함하는 client_id와 client_secret
  - 같거나 더 작은 허가 권한을 정의하는 scope (더 많은 허가 권한을 부여해야 할 때는 재인증이 필요하다)

------------------

## OAuth 2의 허점

- 클라이언트에서 CSRF(사이트 간 요청 위조) 이용
  - 애플리케이션이 CSRF 보호 매커니즘을 적용하지 않으면 사용자가 로그인했을 때 CSRF가 가능하다.
- 클라이언트 자격 증명 도용
  - 보호되지 않은 자격 증명을 저장하거나 전송하면 이를 공격자가 도용하는 위반이 발생할 수 있다.
- 토큰 재생
  - 네트워크를 통해 보내는 동안 누군가 가로챌 수 있다.
  - 도난당한 토큰은 재사용될 수 있다.
- 토큰 하이재킹
  - 인증 프로세스를 방해하고 리소스에 액세스하기 위한 토큰을 훔치는 것을 의미한다.
  - 갱신 토큰을 이용하는 잠재적인 취약성이기도 한데, 갱신 토큰을 가로채고 새 액세스 토큰을 얻는 데 이용할 수 있기 때문이다.

-------------

## 요약

- OAuth 2 프레임워크는 엔티티가 사용자 대신 리소스에 접근할 수 있게 하는 방법을 기술한다. 애플리케이션에 OAuth 2 프레임워크를 이용해 인증 및
권한 부여 논리를 구현할 수 있다.
- 애플리케이션이 액세스 토큰을 얻기 위해 사용할 수 있는 다양한 흐름을 그랜트라고 한다. 시스템 아키텍처에 따라 적합한 그랜트 유형을 선택해야 한다.
  - 승인 코드 그랜트 유형
    - 사용자가 직접 권한 부여 서버에서 인증하여 클라이언트가 액세스 토큰을 얻을 수 있게 해준다.
    - 사용자가 클라이언트를 신뢰하지 않고 클라이언트와 자격 증명을 공유하기를 원하지 않을 때 적합하다.
  - 암호 그랜트 유형
    - 사용자가 자신의 자격 증명을 클라이언트와 공유한다고 가정한다.
    - 클라이언트를 신뢰할 수 있는 경우에만 이 유형을 적용해야 한다.
  - 클라이언트 자격 증명 그랜트 유형
    - 클라이언트가 자격 증명으로만 인증하여 토큰을 얻는다는 의미
    - 클라이언트가 사용자의 리소스가 아닌 리소스 서버의 엔드포인트를 호출해야 할 때 이 그랜트 유형을 선택한다.
- 스프링 시큐리티는 OAuth 2 프레임워크를 지원해서 애플리케이션에서 몇 줄의 코드로 프레임워크를 구성할 수 있다.
- 스프링 시큐리티는 ClientRegistration의 인스턴스를 이용해 권한 부여 서버에서 클라이언트의 등록을 나타낸다.
- 스프링 시큐리티 OAuth 2 구현에서 특정 클라이언트 등록을 찾는 책임이 있는 구성 요소를 ClientRegistrationRepository라고 한다.
스프링 시큐리티로 OAuth 2 클라이언트를 구현할 때는 사용 가능한 ClientRegistration이 하나 이상 있는 ClientRegistrationRepository 객체를 정의해야 한다.