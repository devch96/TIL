# 스프링 프로젝트 시작하기

- 스프링은 어떤 종류의 애플리케이션에도 잘 들어맞도록 매우 유연하게 설계된 범용 프레임워크
  - 아키텍처의 종류나 프로젝트를 구성하는 방법에 자유도가 높음
- 스프링이 유연하다고 해서 아무렇게나 가져다 쓰면 스프링이 주는 유익을 제대로 얻지 못할 수 있음

---------

## 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션

- 스프링으로 만들 수 있는 애플리케이션의 종류에는 제한이 없음
  - 자바 언어를 사용하는 모든 종류의 프로젝트라면 어디든 사용 가능
  - 웹, 스윙, 이클립스 RCP로 만드는 독립형 프로그램에도 적용 가능
  - 애플릿, 모바일 애플리케이션도 가능
- 하지만 스프링은 주로 자바 엔터프라이즈 환경에서 동작하는 애플리케이션을 개발하는 목적으로 사용됨

### 클라이언트와 백엔드 시스템

- 가장 많이 사용된느 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성
  - DB를 사용하는 웹 애플리케이션

### 애플리케이션 서버

- 스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE(J2EE) 서버가 필요로함

#### 경량급 WAS/서블릿 컨테이너

- 스프링은 기본적으로 톰캣이나 제티 같은 가벼운 서블릿 컨테이너만 있어도 충분
  - EJB나 리소스 커넥터, WAS가 제공하는 분산 서비스 등이 굳이 필요하지 않음

#### WAS

- 미션 크리티컬한 시스템에서 요구하는 고도의 안정성이나 고성능 시스템에서 필수적인 안정적인 리소스 관리,
레거시 시스템의 연동이나 기존 EJB로 개발된 모듈을 함께 사용하는 등의 필요가 있다면 상용 또는 오픈소스 WAS를 이용할 수 있음

### 스프링 애플리케이션의 배포 단위

- 세 가지 단위로 배포 가능함

#### 독립 웹 모듈

- war로 패키징된 독립 웹 모듈
- 톰캣 같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법

#### 엔터프라이즈 애플리케이션

- 확장자가 ear

#### 백그라운드 서비스 모듈

- rar 패키징
- 스프링으로 만든 애플리케이션이 UI를 가질 필요는 없고 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있다면 rar 모듈
- WAS가 반드시 필요함

---------------

## 애플리케이션 아키텍처

- 클라이언트와 백엔드 시스템의 종류와 사용 기술, 연동 방법을 결정했다면 시스템 레벨의 아키텍처는 대략 구성된 셈
  - 스프링 웹 애플리케이션의 아키텍처를 결정해야 함
- 아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어
  - 가장 단순한 정의를 보자면 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것
- 아키텍처는 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동적인 행위와 깊은 관계가 있음

### 계층형 아키텍처

- 관심, 책임, 성격, 변하는 이유와 방식이 서로 다른 것들을 분리함으로써 분리된 각 요소의 응집도는 높이고 결합도는 낮추는 것

#### 아키텍처와 SoC

- 오브젝트 레벨에서 분리의 문제에 대해 생각
  - 두 개의 오브젝트로 분리
  - 유연한 결합을 가질 수 있도록 인터페이스를 두고 DI
- 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용 가능함
- 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋음
  - 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해 개발과 변경 작업이 모두 빨라질 수 있음
- 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 계층형 아키텍처라고 부름
  - 계층이라는 의미를 가진 영어 단어인 티어를 써서 멀티 티어 아키텍처라고도 함
  - 웹 기반 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해 3계층 애플리케이션이라고 함

#### 3계층 아키텍처와 수직 계층

- 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 데이터 엑세스 계층, 비즈니스 로직을 담고 이쓴ㄴ 서비스 계층, 웹 기반의
UI를 만들어내고 흐름을 관리하는 프레젠테이션 계층으로 구분
- 이름이 다양함
- 프레젠테이션 계층
  - 웹 계층
  - UI 계층
  - MVC 계층
- 서비스 계층
  - 매니저 계층
  - 비즈니스 로직 계층
- 데이터 엑세스 계층
  - DAO 계층
  - EIS 계층

#### 데이터 엑세스 계층

- DAO 계층이라고도 불림
  - DAO 패턴을 보편적으로 사용하기 때문
- DB 외에도 ERP, 레거시 시스템, 메인 프레임 등에 접근하는 역할을 하기 때문에 EIS(Enterprise Information System) 계층이라고도 함

#### 서비스 계층

- 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성됨
- 객체지향적인 설계 기법이 적용된 코드를 통해 비즈늬스 로직의 핵심을 잘 담아내고 이를 쉽게 테스트하고 유연하게 확장할 수 있음
- 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없음
  - 추상화 수직 계층 구조란 계층 안에서 추상화를 통해 수직으로 만든것
    - DAO 계층에 SimpleJdbcLayer, JdbcTemplate, 등등

#### 프레젠테이션 계층

- 매우 다양한 기술과 프레임워크의 조합을 가질 수 있음
  - HTTP 프로토콜
  - HTML, 자바스크립트
  - 등등

#### 계층형 아키텍처 설계의 원칙

- 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 함
- 각 계층은 자신의 계층의 책임에만 충실해야 함

```java
public ResultSet findUsersByName(String name) throws SQLException;
```

- 위 DAO 인터페이스는 데이터 액세스 계층의 인터페이스다
- 서비스는 해당 인터페이스를 사용해야 하는데 예외처리와 ResultSet이라는 데이터 액세스 기술에 얽매인다

```java
public List<User> findUsersByName(String name)
```

- 으로 바꿔야 한다
- 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층에 전달해서도 안된다
  - HttpServletRequest나 HttpServletResponse, HttpSession 등
- 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야 함
- 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 함

### 애플리케이션 정보 아키텍처

- 엔터프라이즈 애플리케이션은 독립 애플리케이션과 달리 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지함
- 장기간 보관되는 상태정보는 주로 DB나 메인프레임 같은 EIS 백엔드 시스템에 저장됨
- 하나의 업무 작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경우에 유지돼야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고, 서버의 사용자별 세션 메모리에
저장되기도 함

#### DB/SQL 중심의 로직 구현 방식

- 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있음
  - 사용자의 이름으로 정보를 검색해서 일치하는 사용자의 아이디, 비밀번호, 이름, 가입일자를 보여주는 작업
  - 하나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어짐
  - 사용자 조회라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어짐
  - 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경됨
- 대용량 데이터를 다루면서 빠른 처리가 필요한 경우네는 일부 로직을 DB 내에 존재하는 PL/SQL과 같은 저장 프로시저 형태로 만들기도 함
- 이러한 방식은 개발하기 쉽다는 장점이 있음
  - 처음에는 그럼
  - 복잡해지면 어려움
  - 자바 코드를 단지 DB와 화면을 연결해주는 단순한 인터페이스 도구로 전략시킴
- 개발자들끼리 서로 간섭 없이 자신에게 할당된 기능을 독립적으로 만드는 데도 편하고 공통 모듈 정도만 제공되는 것을 사용하고 그 외의 기능은
단위 업무 또는 화면 단위로 만듬
- 하지만 변화에 매우 취약함
  - 객체지향의 장점이 별로 활용되지 못함
- SQL이나 저장 프로시저에 담긴 로직은 테스트하기 힘듬

#### 거대한 서비스 계층 방식

- DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법
- DB에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는것
- 상대적으로 단순한 DAO 로직을 사용하고, 비즈니스 로직의 대부분을 서비스 계층에 집중하는 방법은 거대한 서비스 계층을 만들게 됨
- 장점
  - 애플리케이션 코드에 비즈니스 로직이 담겨 있기 때문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기도 쉬움
  - DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있음
- 단점
  - 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽기 때문에 계층 간의 결합도가 큼
  - 서비스 계층의 메서드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 메서드에서 중복돼서 나타나기 쉬움

### 오브젝트 중심 아키텍처

- 오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을
각 계층 사이에서 정보를 전송하는 데 사용한다는 것
- 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용함
  - 대게 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높음
    - DB에는 없지만 비즈니스 로직에만 존재하는 모델도 있기 때문에 항상 일치하는 것은 아님

#### 데이터와 오브젝트

- 데이터 중심 아키텍처에서는 SQL과 DB 관점에서 생각함
  - 두 개의 정보를 조합해서 가져오는 방법은 JOIN을 이용해 2차원 구조의 정보를 만드는 것
  - SQL 실행 결과는 맵이나 배열에 담음

```java
while(rs.next()) {
    Map<String, Object> resMap = new HashMap<>();
    resMap.put("categoryid", rs.getString(1));
    resMap.put("description", rs.getString(2));
    ...
    list.add(resMap);
}
```

- 서비스 계층에 전달되는 것은 List 타입이므로 안에 담긴 내용이 어떤것인지 알 수 없음
- 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담김

```java
public class Category {
    int categoryid;
    String description;
    Set<Product> products;
}

public class Product {
    int productid;
    String name;
    int price;
    Category category;
}
```

#### 도메인 오브젝트의 문제점

- 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수도 있음
  - DAO는 비즈니스 로직의 사용 방식을 알지 못하므로 도메인 오브젝트의 모든 필드 값을 다 채워서 전달하는 경우가 대부분임
- 가장 이상적인 방법은 JPA나 하이버네이트와 같은 오브젝트 매핑(ORM) 기술을 사용하는 것
  - 지연된 로딩 기법을 제공해줌

#### 빈약한 도메인 오브젝트 방식

- 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않다면 온전한 오브젝트라고 보기 힘듬
  - 물론 이렇게라도 도메인 모델을 반영한 오브젝트에 정보를 담아 활용하는 편이 도메인 오브젝트를 전혀 사용하지 않는 것보다는 훨씬 나음
- 도메인 모델을 반영해서 만들어진 도메인 오브젝트이니 그 기능이라고 하면 도메인의 비즈니스 로직이라 볼 수 있음
  - 빈약한 도메인 오브젝트 방식은 서비스 계층에 비즈니스 로직이 존재함
  - 정보의 구조가 다를 뿐 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층구조와 비슷함

#### 풍성한 오브젝트 방식

- 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것
- 특정 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있음
- 이러한 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것

```java
public class Category {
    List<Product> products;
    
    public int calTotalOfProductPrice() {
        int sum = 0;
        for(Product prd : this.products()) {
            sum += prd.getPrice();
        }
        retrun sum;
    }
}
```

- 도메인 오브젝트 안에 로직을 담아두면 이 로직을 서비스 계층의 메서드에 따로 만드는 경우보다 응집도가 높음
  - 데이터와 그것을 사용하는 기능이 한 곳에 모여있기 때문
  - Category에 대해 상품 가격을 계산하는 작업이 CategoryService 외의 서비스 계층 오브젝트에서 필요하다면 Category 오브젝트를
  파라미터로 해서 CategoryService의 메서드를 호출하는 것은 번거로움
  - DI도 해줘야함

#### 도메인 계층 방식

- 도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 오브젝트 방식으로는 만족할 수 없음
  - 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식
  - 서비스 계층과 데이터 액세스 계층의 사이에 존재하게 하는 것
- 스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요함
  - AspectJ AOP
  - 스프링 AOP는 스프링의 빈 오브젝트일 뿐
- 주의하지 않으면 심각한 혼란을 초래할 수 있음