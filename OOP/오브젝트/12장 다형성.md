# 다형성

- 상속의 목적은 코드 재사용이 아닌 타입 계층을 구조화하기 위함이다.
  - 상속을 이용해 자식 클래스를 추가하려 한다면 단순히 코드를 재사용하기 위해서인지 아니면 클라이언트 관점에서 인스턴스들을
  동일하게 행동하는 그룹으로 묶기 위해서인지 질문해야 한다.

-----------

## 다형성

- 다형성(Polymorphism)이라는 단어는 그리스어에서 '많은'을 의미하는 'poly'와 '형태'를 의미하는 'morph'의 합성어로
'많은 형태를 가질 수 있는 능력'을 의미한다.
- 객체지향 프로그래밍에서 사용되는 다형성
  - 다형성
    - 유니버셜(Universal) 다형성
      - 매개변수(Parametric) 다형성
        - 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식
        - 제네릭 프로그래밍과 관련이 높음
      - 포함(Inclusion) 다형성
        - 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력
        - 서브타입(Subtype) 다형성이라고도 부름
        - 객체지향 프로그래밍에서 가장 널리 알려진 형태의 다형성이기 때문에 특별한 언급 없이 다형성이라고 할 때는 포함 다형성을 의미함.
    - 임시(Ad Hoc) 다형성
      - 오버로딩(Overloading) 다형성
        - 일반적으로 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
          - Money 클래스 안에 서로 다른 타입의 파라미터를 받아 금액을 증가시키는 메서드들
          - 메서드 오버로딩을 사용하면 유사한 작업을 수행하는 메서드의 이름을 통일할 수 있기 때문에 기억해야 하는 이름의 수를
          극적으로 줄일 수 있음
      - 강제(Coercion) 다형성
        -  언어가 지우너하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
          - 자바에서 연산자인 '+'는 두 항이 모두 정수일 경우에는 정수에 대한 덧셈 연산자로 동작하지만 하나는 정수형이고 다른 하나는 문자열인 경우에
            연결 연산자로 동작함.
          - 이때 정수형 피연산자는 문자열 타입으로 강제 형변환됨.

----------------

## 상속의 양면성

- 타입 계층에 대한 고민 없이 코드를 재사용하기 위해 상속을 사용하면 이해하기 어렵고 유지보수하기 버거운 코드가 만들어질 확률이 높다.

### 상속을 사용한 강의 평가

```java
public class Lecture{
    private int pass;
    private String title;
    private List<Integer> scores = new ArrayList<>();
    
    public double average(){
        return scores.stream().mapToInt(Integer::intValue)
                .average().orElse(0);
    }
    
    public List<Integer> getScores(){
        return Collections.unmodifiableList(scores);
    }
    
    public String evaluate(){
        return String.format("Pass:%d Fail:%d", passCount(), failCount());
    }
    
    private long passCount(){
        return scores.stream().filter(score -> score >= pass).count();
    }
    
    private long failCount(){
        return scores.size() - passCount();
    }
}

public class Grade{
    private String name;
    private int upper;
    private int lower;
    
    public boolean include(int score){
        return score >= lower && score <= upper;
    }
}

public class GradeLecture extends Lecture{
    private List<Grade> grades;
    
    @Override
    public String evaluate(){
        return super.evaluate() +"," + gradesStatistics();
    }
    
    private String gradesStatistics(){
        return grades.stream()
                .map(grade -> format(grade))
                .collect(joining(" "));
    }
    
    private String format(Grade grade){
        return String.formate("%s:%d", grade.getName(), gradeCount(grade));
    }
    
    private long gradeCount(Grade grade){
        return getScores().stream()
                .filter(grade::include)
                .count();
    }
}

```
- 부모 클래스와 자식 클래스에 동일한 시그니처를 가진 메서드가 존재할 경우 자식 클래스의 메서드 우선순위가 더 높다.
- 자식 클래스 안에 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것을 메서드 오버라이딩이라고 부른다.
- 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것을 메서드 오버로딩이라고 부른다.

### 데이터 관점의 상속

- 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는것으로 볼 수 있다.
  - 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 되는 것

### 행동 관점의 상속

- 행동 관점의 상속은 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미
- 부모 클래스에서 구현한 메서드를 자식 클래스의 인스턴스에서 수행?
  - 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색
- 객체의 경우 서로 다른 상태를 저장할 수 있도록 각 인스턴스별로 독립적인 메모리를 할당받아야 하지만 메서드의 경우에는
동일한 클래스의 인스턴스끼리 공유가 가능하기 때문에 클래스는 한 번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖게 하는 것이 경제적
- 이 포인터를 이용하면 클래스의 상속 계층을 따라 부모 클래스의 정의로 이동하는 것이 가능
  - 메시지를 수신한 객체는 class 포인터로 연결된 자신의 클래스에서 적절한 메서드가 존재하는지를 찾고 존재하지 않으면 클래스의
  parent 포인터를 따라 부모 클래스를 차례대로 훑어 가면서 적절한 메서드가 존재하는지를 검색한다.

----------------

## 업캐스팅과 동적 바인딩

### 같은 메시지, 다른 메서드

- 코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다.
- 이러한 것이 가능한 이유는 업캐스팅과 동적 바인딩이라는 매커니즘이 작용하기 때문이다.
  - 업캐스팅
    - 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.
  - 동적 바인딩
    - 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다.
    - 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문이다.

### 업캐스팅

- 상속을 이용하면 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 이넡페이스에 합쳐지기 때문에 부모 클래스의 인스턴스에게
전송할 수 있는 메시지는 자식 클래스의 인스턴스에게 전송할 수 있다.
- 컴파일러는 명시적인 타입 변환 없이도 자식 클래스가 부모 클래스를 대체할 수 있게 허용한다.
- 반대로 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 명시적인 타입 캐스팅이 필요한데 이를 다운캐스팅이라고 부른다.
- 컴파일러의 관점에서 자식 클래스는 아무런 제약 없이 부모 클래스를 대체할 수 있기 때문에 부모 클래스와 협력하는 클라이언트는 다양한 자식 클래스의 인스턴스와도
협력이 가능하다.

### 동적 바인딩

- 컴파일타임에 호출할 함수를 결정하는 방식을 정적, 초기, 컴파일타임 바인딩이라고 부른다.
- 실행될 메서드를 런타임에 결정하는 방식을 동적, 지연 바인딩이라고 부른다.

---------------

## 동적 메서드 탐색과 다형성

- 객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다.
  - 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다. 존재하면 메서드를 실행하고 탐색을 종료한다.
  - 메서드를 찾지 못했다면 부모 클래스에서 탐색을 계속한다. 이 과정은 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.
  - 상속 계층의 가장 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.
- 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정한다.
  - 자바에서는 this
- 시스템은 class 포인터와 parent 포인터와 함께 self 참조를 조합해서 메서드를 탐색한다
- 동적 메서드 탐색의 두 가지 원리
  - 자동적인 메시지 위임
    - 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상속 계층을 따라 부모 클래스에게 처리를 위임
    - 클래스 사이의 위임은 프로그래머의 개입 없이 상속 계층을 따라 자동으로 이뤄짐
  - 동적인 문맥 사용
    - 메시지를 수신했을 때 실제로 어떤 메서드를 실행할지를 결정하는 것은 컴파일 시점이 아닌 실행 시점
    - 메서드를 탐색하는 경로는 self 참조를 이용해서 결정

### 자동적인 메시지 위임

- 적절한 메서드를 찾을 때까지 상속 계층을 따라 부모 클래스로 처리가 위임됨
- 이러한 관점에서 상속 계층을 정의하는 것은 메서드 탐색 경로를 정의하는 것과 동일
- 메서드 오버라이딩은 자식 클래스의 메서드가 동일한 시그니처를 가진 부모 클래스의 메서드보다 먼저 탐색되기 때문에 벌어지는 현상

### 동적인 문맥

- 동일한 코드라고 하더라도 self 참조가 가리키는 객체가 무엇인지에 따라 메서드 탐색을 위한 상속 계층의 범위가 동적으로 변한다.
- self 참조가 가리키는 객체의 타입을 변경함으로써 객체가 실행될 문맥을 동적으로 바꿀 수 있다.

#### self 전송

```java
public class Lecture{
    public String stats(){
        return String.format("Title: %s, Evaluation Method: %s", title, getEvaluationMethod());
    }
    
    public String getEvaluationMethod(){
        return "Pass or Fail";
    }
}
```
- 현재 클래스의 메서드를 호출하는 것이 아니라 현재 객체에게 메시지를 전송하는 것
  - self 참조가 가리키는 객체
  - 처음에 stats 메시지를 수신했던 객체
```java
public class GradeLecture extends Lecture{
    @Override
    public String getEvaluationMethod(){
        return "Grade";
    }
}
```
- GradeLecture.stats()를 하면 self 는 GradeLecture이 되므로 Lecture의 getEvaluationMethod가 아니라 GradeLecture의 getEvaluationMethod
가 실행됨.
  - 메시지 탐색의 시작은 self이기 때문
- self 전송은 깊은 상속 계층과 계층 중간중간에 함정처럼 숨겨져 있는 메서드 오버라이딩과 만나면 극단적으로 이해하기 어려운 코드가 만들어짐

### self 대 super

- self의 특성과 대비되는 것이 super 참조
- self는 메서드 탐색의 시작 위치가 메시지를 받은 객체, super은 메서드 탐색의 시작 위치가 부모 클래스
  - 따라서 super에 의해 호출되는 메서드는 부모 클래스가 아닌 더 상위에 위치한 조상 클래스의 메서드일 수도 있음.
- self 전송이 메시지를 수신하는 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정한다면 super 전송은 항상 메시지를 전송하는 클래스의
부모 클래스에서부터 시작됨.