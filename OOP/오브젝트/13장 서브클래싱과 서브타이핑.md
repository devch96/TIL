# 서브클래싱과 서브타이핑

- 상속의 용도
  - 타입 계층
    - 부모 클래스는 자식 클래스의 일반화(generalization)
    - 자식 클래스는 부모 클래스의 특수화(specialization)
  - 코드 재사용
    - 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있음
    - 재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 높음
- 타입 계층을 목표로 상속을 사용하면 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있게 된다.
- 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다.
- 타입 사이의 관계를 고려하지 않은 채 단순히 코드를 재사용하기 위해 상속을 사용해서는 안 된다.

-----------

## 타입

### 개념 관점의 타입

- 개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다.
  - 객체들에 적용하는 개념이나 아이디어
  - 자바, 루비, 자바스크립트, C를 프로그래밍 언어라고 부를 때 우리는 이것들을 프로그래밍 언어라는 타입으로 분류하는 것
- 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스(instance)라고 부른다.
  - 자바, 루비, 자바스크립트, C는 프로그래밍 언어의 인스턴스다.
  - 일반적으로 타입의 인스턴스를 객체라고 부른다.

### 프로그래밍 언어 관점의 타입

- 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다
- 프로그래밍 언어에서 타입의 목적
  - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다
    - 자바에서 '+' 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없다.
  - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다
    - 자바에서 a + b 라는 연산이 있을 때 a,b의 타입이 int라면 두 수를 더하고 String이라면 두 문자열을 합친다.
    - a와 b에 부여된 타입이 '+' 연산자의 문맥을 정의한다.

### 객체지향 패러다임 관점의 타입

- 객체지향 프로그래밍 관점에서 타입은 객체의 퍼블릭 인터페이스가 객체의 타입을 결정하기에 동일한 퍼블릭 인터페이스를 제공하는 객체들은
동일한 타입으로 분류된다.
  - 동일 상태 다른 행동 : 다른 타입
  - 다른 상태 동일 행동 : 동일 타입

----------------

## 타입 계층

- 타입은 객체들의 집합이기에 수학에서의 집합과 마찬가지로 다른 타입을 포함하는 것이 가능하다.
- 다른 타입을 포함하는 타입은 포함되는 타입보다 좀 더 일반화된 의미를 표현할 수 있다.
- 포함되는 타입은 좀 더 특수하고 구체적이다.
- 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입(supertype)이라고 부르고 더 특수한 타입을 서브타입(subtype)이라고 부른다.

### 객체지향 프로그래밍과 타입 계층

- 객체의 타입을 결정하는 것은 퍼블릭 인터페이스다.
- 따라서 일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준이 퍼블릭 인터페이스다.
- 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입이다.

--------------------

## 서브클래싱과 서브타이핑

### 언제 상속을 사용해야 하는가?

- 두 질문에 모두 '예'라고 답할 수 있는 경우에만 상속을 사용
  - 상속 관계가 is-a 관계를 모델링하는가?
    - 일반적으로 "[자식 클래스]는 [부모 클래스]다" 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
    - 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.
    - 이를 자식 클래스와 부모 클래스 사이의 행동 호환성이라고 부른다.

### is-a 관계

- 새와 펭귄의 예
  - 펭귄은 새다
  - 새는 날 수 있다.
```java
public class Bird{
    public void fly(){
        ...
    }
}

public class Penguin extends Bird{
    ...
}
```
- 펭귄은 분명 새지만 날 수 없는 새다.
- 따라서 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
- 슈퍼타입과 서브타입 관계에서는 is-a 보다 행동 호환성이 더 중요하다

### 행동 호환성

- 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.
- 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이다.
  - 클라이언트가 두 타입을 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.
  - 클라이언트가 두 타입이 동일하게 행동하지 않을 것이라고 기대한다면 두 타입을 타입 계층으로 묶어서는 안된다.

### 클라이언트의 기대에 따라 계층 분리하기

- 행동 호환성을 만족시키지 않는 상속 계층을 그대로 유지한 채 클라이언트의 기대를 충족시킬 수 있는 방법을 찾기란 쉽지 않다.
- 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙이라고 부른다.

### 서브클래싱과 서브타이핑

- 상속을 사용하는 두 가지 목적에 이름을 붙였다.
  - 서브클래싱
    - 코드를 재사용할 목적으로 상속을 사용하는 경우
    - 구현 상속 또는 클래스 상속이라고 부르기도 한다
  - 서브타이핑
    - 타입 계층을 구성하기 위해 상속을 사용하는 경우
    - 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.
    - 인터페이스 상속이라고 부르기도 한다

-----------

## 리스코프 치환 원칙

- 상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키기 위해서 다음의 조건을 만족시켜야 한다.
  - S형의 각 객체 o1에 대해 T형의 객체 o2가 하나 있고, T에 의해 정의된 모든 프로그램 P에서 T가 S로 치환될 때, P의 동작이 변하지 않으면
  S는 T의 서브타입이다.
- 리스코프 치환 원칙은 자식 클래스가 부모 클래스와 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된
상속 관계만을 서브타이핑이라고 불러야 한다.
  - 클라이언트가 부모 클래스인 Vector에 대해 기대하는 행동을 Stack에 대해서는 기대할 수 없기 때문에 행동 호환성을 만족 시키지 않으므로
  Stack과 Vector는 리스코프 치환 원칙을 위반하는 전형적인 예다.

### 정사각형과 직사각형

- 정사각형은 직사각형이다 라는 이야기를 당연하게 생각하지만 정사각형은 직사각형이 아닐 수 있다.
- 정사각형과 직사각형의 상속 관계는 리스코프 치환 원칙을 위반하는 고전적인 사례 중 하나이다.

```java
public class Rectangle{
    private int x;
    private int y;
    private int width;
    private int height;
    
    // constructor
    
    // getter setter
    
    public getArea(){
        return width * height;
    }
}

public class Square extends Rectangle{
    public Square(int x, int y, int size){
        super(x,y,size,size);
    }
    
    @Override
    public void setWidth(int width){
        super.setWidth(width);
        super.setHeight(width);
    }
    
    @Override
    public void setHeight(int height){
        super.setWidth(height);
        super.setHeight(height);
    }
}
```
- Square는 Rectangle의 자식 클래스이기 때문에 Rectangle이 사용되는 모든 곳에서 Rectangle로 업캐스팅될 수 있다.
  - 문제는 여기서 발생
  - Rectangle과 협력하는 클라이언트는 직사각형의 너비와 높이가 다르다고 가정할 것.
```java
public void resize(Rectangle rectangle, int width, int height){
    rectangle.setWidth(width);
    rectangle.setHeight(height);
}
```
- resize 메서드는 Rectangle이 세운 가정에 기반하기 때문에 직사각형의 너비와 높이를 독립적으로 변경할 수 있다고 가정하지만 Square를 전달할 경우 이 가정은 
무너지고 맘
- resize 메서드의 관점에서 Rectangle 대신 Square를 사용할 수 없기 때문에 Square는 Rectangle이 아니다.
- Square는 Rectangle의 구현을 재사용하고 있을 뿐.

### 클라이언트와 대체 가능성

- Rectangle을 사용하는 클라이언트는 Rectangle의 너비와 높이가 다를 수 있다는 가정하에 코드를 개발하기에 Square로 대체할 경우
세워진 가정을 위반할 확률이 높다.
- 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.
  - Square를 Rectangle의 자식 클래스로 만드는 것은 Rectangle에 대해 클라이언트가 세운 가정을 뒤흔드는 것

### is-a 관계 다시 살펴보기

- 클라이언트 관점에서 자식 클래스의 행동이 부모 클래스의 행동과 호환되지 않고 그로 인해 대체가 불가능하다면 어휘적으로 is a 라고 말할 수 있다고 하더라도
그 관계를 is a 관계라고 할 수 없다.
- is a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다.

### 리스코프 치환 원칙은 유연한 설계의 기반이다

- 리스코프 치환 원칙을 따르는 설계는 유연할뿐만 아니라 확장성이 높다
  - 클라이언트 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면 클라이언트의 코드르 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게
  된다는 것.

### 타입 계층과 리스코프 치환 원칙

- 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법 중 하나일 뿐이다.
- 구현 방법과 무관하게 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용된다면 서브타이핑 관계라고 말할 수 있다.

-------------

## 계약에 의한 설계와 서브타이핑

- 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 계약에 의한 설계라고 부른다.
- 계약에 의한 설계는 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 사전조건과 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는
사후조건, 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 클래스 불변식의 세 가지 요소로 구성된다.
- 계약에 의한 설계에 따르면 협력하는 클라이언트와 슈퍼타입의 인스턴스 사이에는 어떤 계약이 맺어져 있고, 리스코프 치환 원칙은 서브타입이 그것의
슈퍼타입을 대체할 수 있어야 하고 클라이언트가 차이점을 인식하지 못한 채 슈퍼타입의 인터페이스를 이용해 서브타입과 협력할 수 있어야 한다고 말한다.
