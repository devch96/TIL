# 알고리즘 캡슐화하기(탬플릿 메소드 패턴)

## 커피와 홍차 만들기

- 커피와 홍자 만드는 방법은 비슷함.
- 커피
  1. 물을 끓인다.
  2. 끓는 물에 커피를 우려낸다.
  3. 커피를 컵에 따른다.
  4. 설탕과 우유를 추가한다.
- 홍차
  1. 물을 끓인다.
  2. 끓는 물에 찻잎을 우려낸다.
  3. 홍차를 컵에 따른다.
  4. 레몬을 추가한다.

## Coffee 클래스와 Tea 클래스 만들기

```java
public class Coffee{
    void prepareRecipe(){
        boilWater();
        brewCoffeGrinds();
        pourInCup();
        addSugarAndMilk();
    }
    
    ...
}

public class Tea{
    void prepareRecipe(){
        boilWater();
        steepTeaBag();
        pourInCup();
        addLemon();
    }
    
    ...
}
```

- 코드가 중복된다면 디자인 수정을 고려하라.
- 두 클래스의 공통된 부분을 추상화해서 베이스 클래스로 만든다.

## prepareRecipe() 메소드 추상화하기

```java
public abstract class CaffeineBeverage{
    final void prepareRecipe(){
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }
    
    abstract void brew();
    
    abstract void addCondiments();
    
    ...
}
```

## 템플릿 메소드 패턴 알아보기

- Coffee와 Tea 클래스에 템플릿 메소드 패턴을 적용했다고 할 수 있다.
- prepareRecipe()이 템플릿 메소드다.(메소드이면서 어떠한 알고리즘의 템플릿(틀) 역할. 여기서의 알고리즘은 카페인 음료 제작)
- 템플릿 내에서 알고리즘의 각 단계는 메소드로 표현된다.
- 어떤 메소드는 해당 클래스에서 처리되기도 하고 서브클래스에서 처리되는 메소드도 있다.
- 템플릿 메소드는 알고리즘의 각 단계를 정의하며, 서브클래스에서 일부 단계를 구현할 수 있도록 유도한다.

## 템플릿 메소드 패턴의 장점

- CaffeineBeverage 클래스에서 작업을 처리한다. 알고리즘을 독점한다.
- CaffeineBeverage로인해 서브클래스에서 코드를 재사용할 수 있다.
- 알고리즘이 모여있으므로 수정이 편리하다.
- 다른 음료도 쉽게 추가할 수 있다.
- 일부 구현만 서브클래스에 의존할 뿐 알고리즘 지식이 집중되어 있다.

## 템플릿 메소드 패턴의 정의

- 템플릿 메소드 패턴(Template Method Pattern)은 알고리즘의 골격을 정의한다. 템플릿 메소드를 사용하면 알고리즘의 일부 단계를 서브클래스에서 구현할 수 있으며
 알고리즘의 구조는 그대로 유지하면서 알고리즘의 특정 단계를 서브클래스에서 재정의할 수도 있다.

## 템플릿 메소드 속 후크 알아보기

- 후크(hook)는 추상 클래스에서 선언되지만 기본적인 내용만 구현되어 있거나 아무 코드도 들어있지 않은 메소드이다.
- 이러면 서브클래스는 다양한 위치에서 알고리즘에 끼어들 수 있다. 또한 무시하고 넘어갈 수도 있다.

## 후크 활용하기

```java
public abstract class CaffeineBeverage{
    final void prepareRecipe(){
        boilWater();
        brew();
        pourInCup();
        if(customerWantsCondiments()){
            addCondiments();
        }
    }
    
    abstract void brew();
    
    abstract void addCondiments();
    
    boolean customerWantsCondiments(){ // hook 서브클래스에서 필요할때 오버라이드 가능.
        return true;
    }
    
    ...
}
```

## 템플릿을 만들 때 추상 메소드 VS 후크

- 서브클래스가 알고리즘의 특정 단계를 제공해야 한다면 추상 메소드.
- 알고리즘의 특정 단계가 선택적으로 적용된다면 후크.

## 할리우드 원칙

- 할리우드 원칙(Hollywood Principle): 먼저 연락하지 마세요. 저희가 연락 드리겠습니다.
- 할리우드 원칙을 활용하면 의존성 부패(dependency rot)를 방지할 수 있다.
- 의존성 부패란 의존성이 복잡하게 꼬여있는 상황을 말한다.
- 의존성이 부패하면 시스템 디자인이 어떤 식으로 되어있는지 알 수 없다.
- 할리우드 원칙을 사용하면 저수준 구성 요소가 시스템에 접속할 수는 있지만, 언제 , 어떻게 그 구성요소를 
사용할지는 고수준 구성 요소가 결정한다.

## 할리우드 원칙과 템플릿 메소드 패턴

- 템플릿 메소드 패턴을 사용해 디자인하면 서브클래스에게 할리우드 원칙을 적용한 것이다.
- CaffeineBeverage는 고수준 구성 요소이며 음료를 만드는 방법의 알고리즘을 장악하고 있고, 메소드 구현이 필요한 상황에만 서브클래스를 불러낸다.

## 정리

- 템플릿 메소드는 알고리즘의 단계를 정의하며 일부 단계를 서브 클래스에서 구현하도록 할 수 있다.
- 템플릿 메소드 패턴은 코드 재사용에 큰 도움이 된다.
- 템플릿 메소드가 들어있는 추상 클래스는 구상 메소드, 추상 메소드, 후크를 정의할 수 있다.
- 추상 메소드는 서브클래스에서 구현한다.
- 후크는 추상 클래스에 들어있는 메소드로 아무 일도 하지 않거나 기본 행동만을 정의한다. 서브클래스에서 오버라이드 할 수 있다.
- 할리우드 원칙에 의하면 저수준 모듈을 언제 어떻게 호출할지는 고수준 모듈에서 결정하는 것이 좋다.
- 템플릿 메소드 패턴은 실전에서도 꽤 자주 쓰이지만 반드시 '교과서적인'방식으로 적용되진 않는다.
- 전략 패턴과 템플릿 메소드 패턴은 모두 알고리즘을 캡슐화하는 패턴이지만 전략 패턴은 상속을, 템플릿 메소드 패턴은 구성을 사용한다.
- 팩토리 메소드 패턴은 특화된 템플릿 메소드 패턴이다.

