# 디자인 패턴의 세계로 떠나기(전략 패턴)

## 오리 시뮬레이션 게임, SimUduck

- 상속을 이용해서 Duck 밑에 자식들 클래스로 MallardDuck, RedheadDuck.
- 새로운 fly() 메소드를 추가하기 위해 부모 클래스에 fly() 메소드 추가.
- 날지 않는 오리를 추가하려니 fly() 메소드를 오버라이드해서 아무 동작도 안하게 함.
- 가짜 오리를 추가하려니 fly를 포함한 다른 메소드들 또한 아무것도 하지 않도록 오버라이드 해야함.
- Duck의 행동을 상속할 때 단점이 될 수 있는 요소를 고르시오.
  - 서브클래스에서 코드가 중복된다. (O)
  - 실행 시에 특징을 바꾸기 힘들다. (O)
  - 오리가 춤추게 만들 수 없다. (X)
  - 모든 오리의 행동을 알기 힘들다. (O)
  - 오리가 날면서 동시에 꽥꽥거릴 수 없다. (X)
  - 코드를 변경했을 때 다른 오리들에게 원치 않은 영향을 끼칠 수 있다. (O)

## 인터페이스 설계하기

- 규격이 계속 바뀌는 상황에서 상속은 옳은 방법이 아님.
- 모든 오리가 날거나(fly), 꽥꽥(Quack) 거리진 않으니 인터페이스를 만들고 구현.
- 하지만 코드를 재사용하는 방법이 아니기 때문에 코드 관리에 커다란 문제가 생김.

## 해결 방법 고민하기

- 소프트웨어를 고칠 때 기존 코드에 미치는 영향을 최소한으로 줄이면서 작업할 수 있는 방법.
- 코드 작업을 다시 하는 시간을 줄여 더 좋은 프로그램을 만드는 데 많은 시간을 투자할 수 있음.

## 소프트웨어 개발 불변의 진리

- 소프트웨어 개발에서 절대로 바뀌지 않는 진리는 `변화`.
- 아무리 디자인을 잘한 어플리케이션이라도 시간이 지남에 따라 변화하고 성장해야 함.
- 따라서 우리는 변화하기 좋은, 편리한 어플리케이션을 만들 필요가 있음.

## 문제를 명확하게 파악하기

- 서브클래스마다 슈퍼클래스에 정의되어있는 행동이 바뀔 수 있는데도 한 가지 행동만 하도록 하는 상속은 좋지 않음.
- 인터페이스는 괜찮아 보이나 구현된 코드가 없으므로 코드를 재사용할 수 없다는 문제가 있음.
- 한 가지 행동을 바꿀 때마다 그 행동이 정의되어 있는 서로 다른 서브클래스들을 전부 찾아서 코드를 일일이 고쳐야 하고,
그 과정에서 새로운 버그가 생길 가능성도 있음.
- 디자인 원칙
  - 어플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
- 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 `캡슐화`하면, 코드를 변경하는 과정에서
의도치 않게 발생하는 일을 줄이면서 시스템의 유연성을 향상시킬 수 있음.

## 바뀌는 부분과 그렇지 않은 부분 분리하기

- Duck 에서 fly()와 quack()을 제외하면 자주 달라지거나 바뀌지 않음.
- 변화하는 부분과 그대로 있는 부분을 분리하려면 Duck 과는 별개로 2개의 클래스 집합을 만들어야 함.
  - fly와 관련된 부분.
  - quack과 관련된 부분.

## 오리의 행동을 디자인하는 방법

- 클래스 집합은 최대한 유연하게 만들어야 함.
- 또한 오리와 관련된 행동이기 때문에 Duck의 인스턴스에 행동을 할당할 수 있어야 함.
- 디자인 원칙
  - 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
- 각 행동을 인터페이스로 표현하고 인터페이스를 사용해서 행동을 구현.
- 인터페이스에 맞춰서 프로그래밍한다 라는 말은 상위 형식에 맞춰서 프로그래밍한다 라는 말.
- 상위 형식에 맞춰서 프로그래밍하라 는 원칙은 변수를 선언할 때 보통 추상 클래스나 인터페이스 같은 상위 형식으로
선언해야 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체에 넣을 수 있다 라는 말이다.
```java
Dog d = new Dog();
d.bark();

Aniaml aniaml = new Dog();
aniaml.makeSound();

a = getAnimal();
a.makeSound();
```
- 변수 d를 Dog 형식(Animal을 확장한 구상 클래스)로 선언하면 구체적인 구현에 맞춰서 코딩해야함.
  - 구현이 바뀌면 코드도 바뀔 위험이 있음.
- 인터페이스와 상위 형식에 맞춰서 프로그래밍한다면 Dog.bark()가 바뀌어도 문제없이 돌아감.
- 더 바람직한 방법은 상위 형식의 인스턴스를 만드는 과정을 코드로 만들지 말고 구체적으로 구현된 객체를 실행 시에 대입하는 것.

## 오리의 행동을 구현하는 방법

- 인터페이스에 맞춰서 프로그래밍
- 날 수 있는 클래스는 FlyBehavior 인터페이스를 구현. 그리고 그 인터페이스는 날개가 달린 오리의 동작과, 날 수 없는 오리의 동작을 구현.
- 이런 식으로 디자인하면 다른 형식의 객체에서도 나느 행동과 꽥꽥거리는 행동을 재사용할 수 있음.
- 기존의 행동 클래스를 수정하거나 날아다니는 행동을 사용하는 Duck 클래스를 건드리지 않고도 새로운 행동을 추가할 수 있음.

## 오리 행동 통합하기

- 나는 행동과 꽥꽥거리는 행동을 Duck 클래스에서 정의한 메소드를 써서 구현하지 않고, 다른 클래스에 위임.
```java
public abstract class Duck{
    FlyBehavior flyBehavior;
    QuackBehavior quackBehavior;
    
    ...
    public void performQuack(){
        quackBehavior.quack();
    }
}
```
- 인터페이스 형식의 인스턴스 변수를 추가하고 각 오리 객체에서 실행 시 변수에 특정 행동 형식의 레퍼런스를 다형적으로 설정함.
```java
public class MallardDuck extends Duck{
    public MallardDuck(){
        quackBehavior = new Quack();
        flyBehavior = new FlyWithWigns();
    }
}
```

## 두 클래스를 합치는 방법

- "A에는 B가 있다"
- 오리에는 나는행동과 꽥꽥거리는 행동이 있다.
- 이런 식으로 두 클래스를 합치는 것을 '`구성(Composition)`을 이용한다.' 라고 한다.
- 오리 클래스에서 행동을 상속받는 대신, 올바른 행동 객체로 구성되어 행동을 부여받는것.
- 디자인 원칙
  - 상속보다는 구성을 활용한다.
- 구성을 활용해서 시스템을 만들면 유연성을 크게 향상시킬 수 있다.
- 알고리즘군을 별도의 클래스 집합으로 캡슐화할 수 있으며 구성 요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면
실행 시에 행동을 바꿀 수도 있다.

## 첫 번째 디자인 패턴: 전략 패턴

- 전략 패턴은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해줌.
- 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있음.
- SimUDuck 어플리에키션을 바꾸는 데 전략 패턴을 사용했음.

## 패턴과 전문 용어

- 패턴으로 소통하면 이상어로 구구절절 말할 때보다 훨씬 효율적인 의사소통을 할 수 있음.
- 소프트웨어 시스템을 이야기할 때 패턴을 사용하면 객체와 클래스를 구현하는 것과 관련된 자질구레한 내용에 시간을 버릴 필요가 없어서
디자인 수준에서 초점을 맞출 수 있음.


## 정리

- 객체지향 디자인이라면 재사용성, 확장성, 관리의 용이성을 갖출 줄 알아야 한다.
- 패턴은 훌륭한 객체지향 디자인 품질을 갖추고 있는 시스템을 만드는 방법을 제공한다.