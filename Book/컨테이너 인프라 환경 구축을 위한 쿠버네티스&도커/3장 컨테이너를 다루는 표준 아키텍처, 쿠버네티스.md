# 컨테이너를 다루는 표준 아키텍처, 쿠버네티스

- 2장에서는 베이그런트를 통해 테스트 환경을 코드로 자동 구현.
- 3장에서는 코드를 응용해 컨테이너 인프라 테스트 환경을 구축.
- 컨테이너 인프라 환경이란 리눅스 운영 체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경.
- 컨테이너 인프라 환경을 구성하면 눈송이 서버(여러 사람이 만져서 설정의 일관성이 떨어진 서버)를 방지하는 데 효과적.
- 가상화 환경에서는 각각의 가상 머신이 모두 독립적인 운영 체제 커널을 가지고 있어야 하기 때문에 그만큼 자원을 더 소모해야 하고 성능이 떨어질 수 밖에
없지만 컨테이너 인프라 환경은 운영 체제 커널 하나에 컨테이너 여러 개가 격리된 형태로 실행되기 때문에 자원을 효율적으로 사용할 수 있고 속도도 훨씬 빠름.

## 쿠버네티스 이해하기

- 쿠버네티스는 컨테이너 오케스트레이션을 위한 솔루션이다.
- 오케스트레이션(Orchestration)이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록
서비스를 제공하는 것을 의미한다.
- 다수의 컨테이너를 유기적으로 연결, 실행, 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 만들어주는 것이
컨테이너 오케스트레이션이다.

### 왜 쿠버네티스일까

- 도커 스웜(Docker Swarm): 간단하게 설치할 수 있고 사용하기도 용이. 기능이 다양하지 않아 대규모 환경에 적용하려면 사용자 환경을 변경해야함.
    소규모 환경에선 유용하지만 대규모 환경에서는 잘 사용하지 않음.
- 메소스(Mesos): 아파치의 오픈 소스 프로젝트. 기능을 충분히 활용하려면 분산 관리 시스템과 연동해야 함.
- 노매드(Nomad): 베이그런트를 만든 해시코프(HashiCorp)사의 컨테이너 오케스트레이션. 기능이 부족하고 간단한 기능만 필요한 환경에서 사용.
- 쿠버네티스: 시작하는데 어려움이 있지만 쉽게 사용할 수 있도록 도와주는 툴들이 있어서 설치가 쉬워지는 추세. 지속적으로 계속 발전되고 있음.
  거의 모든 벤더와 오픈 소스 진영 모두에서 쿠버네티스를 지원하고 그에 맞게 통합 개발하고 있음.

### 쿠버네티스 구성 방법

1. 퍼블릭 클라우드 업체에서 제공하는 관리형 쿠버네티스(EKS, AKS, GKE)등을 사용.
2. 수세의 Rancher, 레드햇의 OpenShift
3. 사용하는 시스템에 쿠버네티스 클러스터를 자동으로 구성해주는 솔루션.(kubeadm, kops, KRIB, kubespray)

### 쿠버네티스 구성하기

- kubeadm으로 구성.
- 쿠버네티스가 설치되는 서버 노드는 가상 머신을 이용해 실제 온프레미스에 가깝게 구성.
- 설치되는 과정을 베이그런트로 자동화해 필요하면 쿠버네티스 테스트 환경을 재구성할 수 있게 함.

### 파드 배포를 중심으로 쿠버네티스 구성 요소 살펴보기

- 마스터 노드
  - kubectl: 쿠버네티스 클러스터에 명령을 내리는 역할. 다른 구성 요소들과는 다르게 바이너리로 배포되기 때문에 마스터 노드에 있을 필요는 없음.
  - API 서버: 쿠버네티스 클러스터의 중심 역할을 하는 통로. 상태 값을 저장하는 etcd와 통신하지만 그 밖의 요소들 또한
  API 서버를 중심에 두고 통신하므로 API서버의 역할이 중요.
  - etcd: 구성 요소들의 상태 값이 모두 저장되는 곳. 회사의 관리자가 모든 보고 내용을 기록하는 노트라고 생각하면 편함. etcd 외의 다른 구성요소는
  상태 값을 관리하지 않음. etcd의 정보만 백업돼 있다면 긴급한 장애 상황에서도 쿠버네티스 클러스러 복구 가능. 
  - 컨트롤러 매니저: 쿠버네티스 클러스터의 오브젝트 상태를 관리함. 워커 노드에서 통신이 되지 않는 경우, 상태 체크와 복구는 컨트롤러 매니저에
  속한 노드 컨트롤러에서 이뤄짐.
  - 스케쥴러: 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지 결정하고 할당함.
  파드를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리하는 역할을 담당함.
- 워커 노드
  - kubelet: 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링.
  - 컨테이너 런타임(CRI): 파드를 이루는 컨테이너의 실행을 담당. 파드 안에서 다양한 종류의 컨테이너가 문제 없이
  작동하게 만드는 표준 인터페이스
  - 파드(Pod): 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위. 웹 서버 역할을 할 수도 있고 로그나 데이터를 분석할 수도 있음.
  파드는 언제라도 죽을 수 있는 존재. 파드는 언제라도 죽을 수 있다고 가정하고 설계됐기 때문에 쿠버네티스는 여러 대안을 디자인 함.
- 선택 가능한 구성 요소
  - 네트워크 플러그인: 쿠버네티스 클러스터의 통신을 위해서 네트워크 플러그인을 선택하고 구성해야 함. 일반적으로 CNI로 구성함.
  - CoreDNS: 클라우드 네이티브 컴퓨팅 재단에서 보증하는 프로젝트로 빠르고 유연한 DNS 서버. IP보다 도메인 네임을 편리하게 관리해주는 CoreDNS
  를 사용하는 것이 일반적.

### 파드의 생명주기로 쿠버네티스 구성 요소 살펴보기

1. kubectl을 통해 API 서버에 파드 생성 요청
2. API 서버에 전달된 내용이 있으면 API 서버는 etcd에 전달된 내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지.
3. API 서버에 파드 생성이 요청된 것을 컨트롤러 매니저가 인지하면 컨트롤러 매니저가 파드를 생성. 어떤 워커 노드에 파드를 적용할지는 결정되지 않은 상태로
파드만 생성.
4. API 서버에 파드가 생성됐다는 정보를 스케줄러가 인지. 스케줄러는 생성된 파드를 어떤 워커 노드에 적용할지 조건을 고려해 결정하고 워커 노드에 
파드를 띄우도록 요청.
5. API 서버에 전달된 정보대로 지정한 워커 노드에 파드가 속해있는지 스케줄러가 kubelet으로 확인.
6. kubelet에서 컨테이너 런타임으로 파드 생성을 요청.
7. 파드 생성.
8. 파드가 사용 가능한 상태가 됨.

- 쿠버네티스는 작업을 순서대로 진행하는 워크플로(workflow) 구조가 아니라 선언적인(declarative) 시스템 구조를 갖고 있음.
- API 서버에 추구하는 상태를 선언하면 다른 요소들이 API 서버에 와서 현재 상태와 비교하고 그에 맞게 상태를 변경하려고 함.
- API는 현재 상태 값을 가지고 있는데 이것을 보존해서 etcd가 필요.

### 쿠버네티스 구성 요소의 기능 검증하기

- kubectl
  - kubectl은 꼭 마스터 노드에 위치할 필요가 없음.
  - 쿠버네티스 클러스터의 외부에서 쿠버네티스 클러스터에 명령을 내릴 수도 있음.
  - kubectl은 API 서버를 통해 쿠버네티스에 명령을 내리기 때문에 API 서버의 접속 정보만 있다면 어느 곳에서든 쿠버네티스 클러스터에 
  명령을 내릴 수 있음.
- kubelet
  - kubelet은 쿠버네티스에서 파드의 생성과 상태 관리 및 복구 등을 담당하는 매우 중요한 구성 요소.
  - 마스터 노드에서 kubectl create -f ~~ (f 는 filename) 파드의 구성 내용을 파일로 읽어 들여 1개의 파드를 임의의 워커 노드에 배포하는 것.
  - kubectl get pod(pod 배포 확인)
  - kubectl get pods -o wide(파드가 배포된 워커 노드 확인)
  - 배포된 노드에서 kubelet을 정지할 경우 파드가 제거되지 않음
  - kubelet에 문제가 생기면 파드가 제대로 관리되지 않음.
- kube-proxy
  - kubelet이 파드의 상태를 관리한다면 kube-proxy는 파드의 통신을 담당.
  - kube-proxy에 문제가 생기면 파드가 정상적으로 작동 중이여도 파드의 정보를 받아오지 못함.

## 쿠버네티스 기본 사용법 배우기

### 파드를 생성하는 방법

- 쿠버네티스를 사용한다는 것은 결국 사용자에게 효과적으로 파드를 제공한다는 뜻.
- kubectl run 명령을 실행하면 쉽게 파드를 생성할 수 있음.
- kubectl run nginx-pod --image=nginx ( run 다음의 nginx는 파드의 이름, --image 는 생성할 이미지의 이름)
- kubectl create로 파드를 생성하려면 deployment를 추가해서 실행해야함.
- run과 create deployment로 파드 생성의 차이
  - run: 단일 파드 1개만 생성되고 관리됨.
  - create deployment: 디플로이먼트라는 관리 그룹 내에서 파드가 생성됨.

### 오브젝트란

- 파드와 디블로이먼트는 스펙(spec)과 상태(status) 등의 값을 가지고 있다.
- 이러한 값을 가지고 있는 파드와 디플로이먼트를 개별 속성을 포함해 부르는 단위를 오브젝트(Object)라고 한다.
- 쿠버네티스는 여러 유형의 오브젝트를 제공한다.

#### 기본 오브젝트

- 파드(Pod)
  - 쿠버네티스에서 실행되는 최소 단위.
  - 웹 서비스를 구동하는 데 필요한 최소 단위.
  - 독립적인 공간과 사용 가능한 IP를 가지고 있음.
  - 하나의 파드는 1개 이상의 컨테이너를 갖고 있기 때문에 여러 기능을 묶어 하나의 목적으로 사용할 수 있음.
  - 범용으로 사용할 때는 1개의 파드에 1개의 컨테이너를 적용.
- 네임스페이스(Namespaces)
  - 쿠버네티스 클러스터에서 사용되는 리소스들을 구분해 관리하는 그룹.
- 볼륨(Volume)
  - 파드가 생성될 때 파드에서 사용할 수 있는 디렉터리를 제공.
  - 파드는 영속되는 개념이 아니라 제공되는 디렉터리도 임시로 사용.
- 서비스(Service)
  - 파드는 클러스터 내에서 유동적이기 때문에 접속 정보가 고정일 수 없음.
  - 파드 접속을 안정적으로 유지하도록 서비스를 통해 내/외부로 연결됨.
  - 서비스는 새로 파드가 생성될 때 부여되는 새로운 IP를 기존에 제공하던 기능과 연결해 줌.

#### 디플로이먼트

- 기본 오브젝트만으로도 쿠버네티스를 사용할 수 있지만 한계가 있음.
- 좀 더 효율적으로 작동하도록 기능들을 조합하고 추가해 구현한 것이 디플로이먼트.
- API 서버와 컨트롤러 매니저는 단순히 파드가 생성되는 것을 감시하는 것이 아니라 디플로이먼트처럼 레플리카셋을 포함하는 오브젝트의 생성을 감시.

### 레플리카셋으로 파드 수 관리하기

- 많은 사용자를 대상으로 웹 서비스를 하려면 다수의 파드가 필요한데 이를 하나씩 생성하려면 매우 비효율적.
- 다수의 파드를 만드는 레플리카셋 오브젝트를 제공.
- 레플리카셋은 파드 수를 보장하는 기능만 제공하기 때문에 롤링 업데이트 기능 등이 추가된 디플로이먼트를 사용해 파드 수를 관리하기를 권장.
- kubectl run 으로 만든 파드는 레플리카되지 않음.

### 스펙을 지정해 오브젝트 생성하기

- kubectl create deployment를 하면서 동시에 여러개를 만드는 방법은?
- create에선 replicas 옵션을 사용할 수 없고, scale은 이미 만들어진 디플로이먼트에서만 사용 가능.
- 이런 설정을 작성하려면 필요한 내용을 파일로 작성해야 하는데 이 파일을 오브젝트 스펙이라고 함.
- 오브젝트 스펙은 일반적으로 yaml 문법으로 작성.
```yaml
apiVersion: apps/v1 # API 버전
kind: Deployment # 오브젝트 종류
metadata:
  name: echo-hname
  labels:
    app: nginx
spec:
  replicas: 3 # 몇 개의 파드를 생성할지 결정
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: echo-hname
        image: sysnet4admin/echo-hname # 사용되는 이미지
```
- API 버전을 확인하려면 kubectl api-versions
- spec을 변경하고 다시 생성하면 에러.

### apply로 오브젝트 생성하고 관리하기

- run은 파드를 간단하게 생성하는 매우 편리한 방법이지만 단일 파드만 생성할 수 있음.
- create로 디플로이먼트를 생성하면 파일의 변경 사항을 바로 적용할 수 없다는 단점이 있음.
- 쿠버네티스는 apply라는 명령어를 제공.
- 변경 사항이 발생할 가능성이 있는 오브젝트는 처음부터 apply로 생성하는 것이 좋음.

### 파드의 컨테이너 자동 복구 방법

- 쿠버네티스는 모든 부분이 자동 복구되도록 설계됬다.
- 파드의 자동 복구 기술을 셀프 힐링이라고 하는데, 제대로 작동하지 않는 컨테이너를 다시 시작하거나 교체해 파드가 정상적으로 작동하게 한다.

### 파드의 동작 보증 기능

- 쿠버네티스는 파드 자체에 문제가 발생하면 파드를 자동 복구해서 파드가 항상 동작하도록 보장하는 기능도 있다.
- 디플로이먼트에 속한 파드는 컨트롤러에서 레플리카셋이랑 차이를 발견하면 상태를 변경해준다.
- 디플로이먼트로 생성하는 것이 파드의 동작을 보장하기 위한 조건이다(컨트롤러의 감시대상이 되는 것)
- 디플로이먼트에 속한 파드를 삭제하는 것은 상위 디플로이먼트를 삭제해야 한다.(kubectl delete deployment ~)

### 노드 자원 보호하기

- 쿠버네티스는 파드를 안정적으로 작동하도록 관리함.
- 노드는 쿠버네티스 스케줄러에서 파드를 할당받고 처리하는 역할.
- 최근 몇 차례 문제가 생긴 노드에 파드를 할당하면 문제가 생길 가능성이 높음. 이럴 경우 영향도가 적은 파드를 할당해 일정 기간 모니터링해야함.
- 쿠버네티스는 모든 노드에 균등하게 파드를 할당하려고 하기에 문제가 생길 가능성이 있는 노드라는 것을 알려주어야함.
- kubectl cordon (node 이름)
- cordon 명령을 하면 해당 노드에 파드가 할당되지 않게 스케줄되지 않는 상태로 변경됨.(SchedulingDisabled)
- uncordon으로 설정 해제할 수 있음.


### 노드 유지보수하기

- 정기 또는 비정기적인 유지보수를 위해 노드를 꺼야 하는 상황일 발생.
- 쿠버네티스는 drain 기능을 제공.
- drain은 지정된 노드의 파드를 전부 다른 곳으로 이동시켜 해당 노드를 유지보수할 수 있게 한다.
- 파드의 이동이란 쿠버네티스에서는 삭제 후 재생성이다.
- 하지만 DaemonSet은 각 노드에 1개만 존재하는 파드라서 drain을 못하므로 drain (노드 이름) --ignore-daemonsets 으로 해야한다.
- 유지보수가 끝나면 노드를 다시 uncordon 한다.

### 파드 업데이트하고 복구하기

- 파드를 운영하다 보면 컨테이너에 새로운 기능을 추가하거나 치명적인 버그가 발생해 버전을 업데이트해야 할 때가 있다.
- 업데이트 하는 도중 문제가 발생해 다시 기존 버전으로 복구해야 하는 일도 발생한다.

#### 파드 업데이트하기

- 파드를 배포할때 --record 옵션을 주면 배포한 정보의 히스토리를 기록한다.
  - kubectl apply -f (~/_Book_k8sInfra/ch3/3.2.10/rollout-nginx.yaml) --record
- record기록은 rollout history 명령으로 확인한다.
  - kubectl rollout history deployment rollout-nginx
- set image로 컨테이너 버전을 업데이트하면 파드들의 이름과 IP 가 변경된다. 파드들을 삭제하고 재생성하는 것이다. 이때
시스템의 영향을 최소화하기위해 한번에 지우는 것이 아닌 순차적으로 지운다. 업데이트 기본값은 전체의 1/4(25%)이며 최솟값은 1개이다.

#### 업데이트 실패 시 파드 복구하기

- rollout undo로 명령 실행을 취소해 마지막 단계에서 전 단계로 상태를 되돌림.
  - kubectl rollout undo deployment (rollout-nginx)
- revision 3이 실패해서 2로 복구를 하면 rollout history를 실행했을때 2가 삭제되고 4로 변경됨.

#### 특정 시점으로 파드 복구하기

- rollout undo는 직전 상태로의 복구임.
- --to-revision을 사용하면 됨.
  - kubectl rollout undo deployment (rollout-nginx) --to-revision=1

## 쿠버네티스 연결을 담당하는 서비스

- 외부 사용자가 파드를 이용하는 방법을 알아보자.
- 쿠버네티스 외부에서 쿠버네티스 클러스터에 접속하는 방법을 서비스(Service)라고 한다.

### 가장 간단하게 연결하는 노드포트

- 외부에서 쿠버네티스 클러스터의 내부에 접속하는 가장 쉬운 방법은 노드포트(NodePort) 서비스를 이용하는 것.
- 노드포트 서비스를 설정하면 모든 워커 노드의 특정 포트(노드포트)를 열고 여기로 오는 모든 요청을 노드포트 서비스로 전달함.
- 노드포트 서비스는 해당 업무를 처리할 수 있는 파드로 요청을 전달.

#### 노드포트 서비스로 외부에서 접속하기

- kubectl create로 노드포트 서비스 생성(spec에 kind: Service)
- 노드포트 서비스로 생성한 서비스 확인
  - kubectl get services
- 쿠버네티스 클러스터의 워커 노드 IP 확인
  - kubectl get nodes -o wide
- 노드에서 열어논 포트로 접속하면 파드이름이 표시됨.


#### 부하 분산 테스트하기

- 파드의 갯수가 늘어나면 로드밸런서 기능이 작동됨.
- 추가된 파드를 외부에서 추적해 접속하는것은 노드포트의 오브젝트 스펙에 적힌 (np-pods) 와 디플로이먼트의 이름을 확인해
동일하면 같은 파드라고 간주하기 때문이다.

#### expose로 노드포트 서비스 생성하기

- 오브젝트 스펙 파일로만 생성하는것이 아닌 expose 명령어로도 생성할 수 있다.
  - kubectl expose deployment np-pods(디플로이먼트 이름) --type=NodePort --name=np-svc-v2(서비스 이름) --port=80 (서비스가 파드로 보내줄 연결 포트)
- 노드포트 포트번호는 expose를 사용하면 지정할 수 없음. 30000~32767 사이
  - kubectl get service 로 확인

### 사용 목적별로 연결하는 인그레스

- 노드포트 서비스는 포트르 중복 사용할 수 없어서 1개의 노드포트에 1개의 디플로이먼트만 적용 됨.
- 여러개의 디플로이먼트가 있을땐 쿠버네티스는 인그레스(Ingress)를 사용함
- 인그레스는 고유한 주소를 제공해 사용 목적에 따라 다른 응답을 제공할 수 있고 트래픽에 대한 L4/L7 로드밸런서와 보안 인증서를 처리하는 기능을 제공.
- 인그레스를 사용하려면 인그레스 컨트롤러가 필요.
- 인그레스 컨트롤러는 파드와 직접 통신할 수 없어서 노드포트 또는 로드밸런서 서비스와 연동되어야 함.
- 인그레스 컨트롤러의 궁극적인 목적은 사용자가 접속하는 경로에 따라 다른 결괏값을 제공하는 것.
- NGINX 인그레스 컨트롤러는 default 네임스페이스가 아닌 ingress-nginx 네임스페이스에 속함
  - kubectl get pods -n ingress-nginx
  - kubectl get services -n ingress-nginx
- 인그레스 설정 파일이 제대로 등록됐는지 확인
  - kubectl get ingress
- 인그레스에 적용된 내용을 yaml 형식으로 출력
  - kubectl get ingress -o yaml
- 인그레스 컨트롤러를 외부에 노출 시킨 후 파드도 expose 명령으로 노출해야 함. 외부와 통신하기 위해 클러스터 내부에서만 사용하는 파드를 클러스터
외부에 노출할 수 있는 구역으로 옮기는 것.

### 클라우드에서 쉽게 구성 가능한 로드밸런서

- 쿠버네티스는 로드밸런서(LoadBalancer)라는 서비스 타입을 제공함.
- 로드밸런서를 사용하려면 로드밸런서를 이미 구현해 둔 서비스업체의 도움을 받아 쿠버네티스 클러스터 외부에 구현해야 함.
- 클라우드에서 제공하는 쿠버네티스를 사용하고 있다면 다음과 같이 선언.
  - kubectl expose deployment ex-lb --type=LoadBalancer --name=ex-svc
  - 쿠버네티스 클러스터에 로드밸런서 서비스가 생성돼 외부와 통신할 수 있는 IP(EXTERNAL-IP)가 부여되고 외부와 통신하며 부하도 분산됨.

### 온프레미스에서 로드밸런서를 제공하는 MetalLB

- 온프레미스에서 로드밸런서를 사용하려면 내부에 로드밸런서 서비스를 받아주는 구성이 필요한데 이를 지원하는 것이 MetalLB
- MetalLB는 쿠버네티스에서도 로드밸런서를 사용할 수 있게 고안된 프로젝트
- L2/L3 네트워크로 로드밸런서를 구현.

1. 파드 생성
2. 오브젝트 스펙으로 MetalLB 구성(독립적인 네임스페이스 생성)
3. 구성확인
   - kubectl get pods -n metallib-system -o wide
4. MetalLb 설정 적용 (오브젝트는 ConfigMap 사용)
5. ConfigMap 확인 
   - kubectl get configmap -n metallb-system
6. 디플로이먼트를 로드밸런서 서비스로 노출
   - kubectl expose deployment lb-hname-pods --type=LoadBalancer --name=lb-hname-svc --port=80
   - kubectl expose deployment lb-ip-pods --type=LoadBalancer --name=lb-ip-svc --port=80
7. 로드밸런서 서비스별로 CLUSTER-IP와 EXTERNAL-IP 확인. ConfigMap을 통해 부여한 IP가 EXTERNAL_IP로 감

### 부하에 따라 자동으로 파드 수를 조절하는 HPA

- 사용자가 갑자기 늘어난다면 파드가 더 이상 감당할 수 없어 서비스 불가라는 결과를 초래할 수 있음.
- 쿠버네티스는 이런 경우를 대비해 부하량에 따라 디플로이먼트의 파드 수를 유동적으로 관리하는 기능을 제공
- 이 기능을 HPA(Horizontal Pod Autoscaler)라고 한다.
- HPA가 작동하려면 파드의 자원이 어느 정도 사용되는지 파악해야함.
  - kubectl top pods(부하 확인 용도)
- HPA가 자원을 요청할 때 메트릭 서버(Metrics-Server)를 통해 계측값을 전달받음.
- 매트릭 서버도 오브젝트 스펙 파일로 설치할 수 있음.
  - (https://github.com/kubernetes-sigs/metrics-server)
- 실습에선 TLS 인증 무시와 kubelet이 내부 주소를 우선 사용하게 변경.
- scale 기준 값이 설정돼있지 않아서 파드 증설 시점을 알 수가 없음. 부하가 걸리기 전에 scale이 실행되게 디플로이먼트에 기준 값을 기록해야 함.
Deployment를 새로 배포하기보단 edit명령으로 수정함
  - kubectl edit deployment hpa-hname-pods
  - spec의 resource에 request: cpu: "10m" limits: cpu: "50m" 추가.
  - m은 milliunits의 약어로 1000m은 1개의 CPU 즉 10m는 0.01 사용을 기준으로 파드를 증설하게 설정한 것.
- 파드에 autoscale을 설정해서 특정 조건이 만족되는 경우 자동으로 scale 명령이 수행되도록 함
  - kubectl autoscale deployment hpa-hname-pods --min=1 --max=30 --cpu-percent=50
  - min은 최소 파드 수
  - max는 최대 파드 수
  - cpu 사용량이 50%를 넘게 되면 autoscale
- HPA를 통해 늘어나느 파드 수 계산 법
  - pod 가 CPU(29m)의 부하를 받고 있는데 10m을 처리할 수 있고, cpu 부하량이 50%를 넘으면 스케일하므로
  29/(10*0.5) 의 올림 = 6

## 알아두면 쓸모 있는 쿠버네티스 오브젝트

- 디플로이먼트 외에도 용도에 따라 사용할 수 있는 다양한 오브젝트가 있다.
- 데몬셋, 컨피그맵, PV, PVC, 스테이트 풀셋 등

### 데몬셋

- 데몬셋(DaemonSet)은 디플로이먼트의 replicas가 노드 수만큼 정해져 있는 형태. 노드 하나당 파드 한 개만을 생성.
- 노드의 단일 접속 지점으로 노드 외부와 통신하는 역할. 따라서 파드가 1개 이상 필요하지 않음.

### 컨피그맵

- 컨피그맵(ConfigMap) 은 설정(config)을 목적으로 사용하는 오브젝트. 

### PV와 PVC

- 파드는 언제든지 생성되고 지워짐.
- 파드에서 생성한 내용을 기록하고 보관하거나 모든 파드가 동일한 설정 값을 유지하고 관리하기 위해 공유된 볼륨으로부터 공통된
설정을 가지고 올 수 있도록 설계해야 할 때도 있음.
- 쿠버네티스는 필요할 때 PVC(PersistentVolumeClaim)을 요청해 사용한다.
- PVC를 사용하려면 PV(PersistentVolume)로 볼륨을 선언해야 한다.

### 스테이트풀셋

- Redis, 주키퍼, 카산드라, 몽고DB등 마스터-슬레이브 구조 시스템에서는 파드가 만들어지는 이름과 순서를 예측해야 할 때가 있다.
- 이럴 땐 스테이트풀셋(StatefulSet)을 사용한다.
- 스테이트풀셋은 volumnClaimTemplates 기능을 사용해 PVC를 자동으로 생성할 수 있고,
파드가 순서대로 생성되기 때문에 고정된 이름, 볼륨, 설정 등을 가질 수 있다.
- 스테이트풀셋은 expose를 지원하지 않는다. 해결하려면 파일로 로드밸런서 서비스를 작성, 실행해야 한다.
