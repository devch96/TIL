# 메모리와 디스크의 핵심: 순차 논리

- 조합 논리는 흐름을 따름
  - 입력에 의해서만 출력이 결정됨
- 조합 논리만으로는 흐름의 일부분을 떼어내서 기억해둘 수 없음
  - 현재 처리 중인 수가 어떤 수인지 기억할 수 없다면 1부터 100까지 모든 정수의 합계를 구하는 것은 불가능
- 순차 논리라는 말은 순서라는 말에서 비롯된 용어
  - 순서는 시간적으로 어떤 값 뒤에 오는 다른 값
- 조합 논리는 입력의 현재 상태만을 다루지만 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려함

## 시간 표현과 기억

- 컴퓨터의 경우 전자공학을 사용하기 때문에 주기적인 전기 신호가 필요함

### 발진자

- 인버터의 출력을 입력에 연결하고 시간을 측정
  - 되먹임(feedback)
  - 마치 마이크와 스피커를 가까이 위치 시킬 때 생기는 현상
  - 출력이 0과 1 사이를 진동함
- 하지만 이 전파는 전파 지연에 따라 결정되며  온도에 따라 달라지는 경향이 있으므로 정확치 않음

### 클록

- 발진자는 컴퓨터에 클록(시간을 셀 수 있게 해주는 신호)을 제공함
- 클록은 회로의 페이스(pace)를 결정함
  - 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정됨
- 오버클로킹한다는 말은 통계적으로 부품을 부품이 고장 나지 않을 범위 안에서 클록을 빠르게 공급하는 도박

### 래치

- OR 게이트의 출력을 입력에 묶는 방식의 되먹임을 사용하면 정보를 기억할 수 있음
  - 이 회로는 값을 반전시키지 않기 때문에
- 회로의 out이 0부터 시작한다고 가정했을 때 in이 1이 되면 out도 1이됨. 이 출력이 게이트의 입력에 연결되어 있기 때문에 이제부터는 out이 1로 유지됨
in이 0이 돼도 출력은 그대로 1로 유지됨
  - 자신의 과거 상태를 기억함
  - 하지만 이 회로를 out이 다시 0으로 만들 방법이 없기 때문에 추가 작업이 필요함
    - 되먹임을 끊고 회로를 재설정할 방법이 필요

## 메모리 조직과 주소 지정

- 비트 하나를 기억할 때 프리플롭이 유용하고 레지스터를 사용하면 쉽게 여러 비트를 저장할 수 있다는 사실
- 더 많은 정보를 저장하려면 레지스터를 많이 쌓아두어야 함
  - 어떤 레지스터를 사용해야 할까?
- 레지스터에 번호를 부여함
  - 이 번호를 주소라고함
- 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 경우 트라이스테이트 출력이라는 기본 요소가 필요

### 임의 접근 메모리

- 임의 접근 메모리(Random Access Memeory, RAM)
- 정적 RAM 즉 SRAM은 비싸지만 아주 빠름
- 동적 RAM 즉 DRAM은 트랜지스터를 1개만 사용해 뚜껑을 덮음

### 읽기 전용 메모리

- 읽기 전용 메모리(Read-Only Memory, ROM)
  - 한 번만 쓸 수 있는 메모리가 맞음
- 한 번 쓰고 나면 여러 번 읽을 수 있음
  - 전자레인지 같은 프로그램을 내장해야 하는 장치는 ROM

## 블록 장치

- 대량 저장창치로 알려진 디스크 드라이브는 엄청나게 많은 데이터를 저장하기 아주 좋은 장치
- 디스크 드라이브는 회전판과 비슷한 자화된 핀에 비트를 저장함
  - 중식당에서 식탁 회전판을 손으로 돌리듯 디스크 드라이브에서는 디스크 헤드가 손 역할
- 디스크 드라이브는 상대적으로 느림
  - 방금 헤드를 지나간 데이터가 필요한 경우 그 데이터를 읽을 수 있으려면 회전판이 거의 1바퀴 돌 때까지 기다려야 하기 때문
  - 기계 부품이 시간이 지나면서 낡아짐
- 디스크는 바이트 단위로 주소를 지정해 읽는 대신 블록 단위로 주소를 지정해 읽음
  - 블록은 섹터
  - 디스크에서 읽고 쓰기가 가능한 가장 작은 단위
  - 최근에는 4096바이트
  - 디스크에서 한 바이트만 바꾸고 싶으면 전체 블록을 읽고 원하는 바이트를 바꾼 다음 전체 블록을 다시 써야 함

## 플래시 메모리와 SSD

- 플래시 메모리에 데이터를 기록하기 위해서는 0을 채워 넣어야 함
  - 0을 1로 바꿀수는 있지만 전체를 지우지 않고 원하는 비트만 0으로 되돌릴 수 없음
- 따라서 읽을 때는 임의 접근 장치이고 쓸 때는 블록 접근 장치
- SSD는 고체 상태 드라이브
- 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같음

## 오류 감지와 정정

- 우주 방사선이 메모리에 닿아서 비트가 잘못될지 모름
- 원본 데이터의 완벽한 복사본을 저장하지 않고도 데이터 오류가 발생했는지 알고 싶음
  - 복사본을 만들어도 어떤게 올바른 버전인지 모름
- 패리티를 사용하면 단 1비트만 데이터가 잘못된 경우를 감지할 수 있음
  - 데이터에서 1로 설정된 비트의 개수를 세고, 그 개수가 짝수인지 홀수인지 나타내는 1비트를 데이터에 덧붙이는 것
  - 모든 비트에 XOR을 취하면 쉽게 이런 비트를 만들 수 있음
- 정적인 데이터 블록을 검증하는 단순한 방법은 체크섬
  - 데이터의 각 지점(바이트 등)을 n 비트값으로 더하고, n 비트를 넘어가는 값은 무시
- 해쉬 코두, 순환 중복 검사 등

## 하드웨어와 소프트웨어 비교

- 소프트웨어가 하드웨어보다 훨씬 더 만들기 쉬움
- 펌웨어라는 말은 ROM에 담긴 소프트웨어를 가리키는 용어지만 요즘은 플래시 메모리 혹은 RAM 상에서도 존재
