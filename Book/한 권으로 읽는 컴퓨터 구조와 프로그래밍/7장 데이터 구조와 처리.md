# 데이터 구조와 처리

- 메모리 시스템의 특성을 염두에 두고 데이터를 조직적으로 잘 정리하면 더 나은 성능을 얻을 수 있다
- 데이터 구조 중 상당수는 여러 유형의 메모리를 더 효율적으로 사용하기 위해 조재한다
  - 어떤 연산을 더 빨리 작동하게 개선하려면 공간/시간 트레이드 오프가 발생하는 경우가 자주 있다
- 참조 지역성은 필요한 데이터를 메모리에서 서로 근처에 유지하라, 금방 사용할 데이터라면 더 가까운 곳에 저장하라라는 말이다

## 기본 데이터 타입

- 프로그래밍 언어는 다양한 기본 데이터 타입(primitive data type)을 제공한다
  - 이런 타입에는 크기(size, 비트 수)와 해석(interpretation, 부호가 있는지, 없는지, 문자인지, 포인터인지, 불리언인지 등) 이라는 두 가지 측면이 존재한다
- 포인터는 단지 컴퓨터 아키텍처에 따라 결정되는 크기의 부호가 없는 정수에 불과하며, 정수값이 아니라 메모리 주소로 해석된다
  - 집 주소와 비슷
  - 집 자체는 아니지만 집을 찾을 때 주소를 쓸 수 있는 것처럼
  - NULL은 일반적으로 제대로 된 주소로 인정하지 않는다
- 포인터는 C가 인기를 끌면서 유명세를 탐. 일부 언어는 잘못된 포인터 사용으로 인한 오류를 막기 위해 참조라는 더 추상적인 개념을 구현하기도 함
- 칩 기술의 발전으로 컴뷰터가 비트 전환이 많이 됨
  - 포인터를 무신경하게 사용
  - 컴퓨터 아키텍처의 발전은 디버깅하기 어려운 방식으로 잘못되는 경우도 생김

## 배열

- 배열은 마치 아파트와 같음
  - 동에는 주소가 있고, 한 아파트 동 안에는 각 집의 번호(호수)가 있음
  - 호수는 인덱스, 각각의 집은 원소
  - 배열 원소의 타입이 모두 같아야 함
- 배열을 바라보는 다른 관점
  - 상대 주소 지정
  - 각 원소의 0번째 원소의 주소인 기저 주소로부터 얼마나 멀ㄹ ㅣ떨어져 있는지를 나타내는 오프셋
  - 원소1은 원소0으로부터 2바이트 떨어져 있음
    - 각 원소가 2바이트
    - 64비트로 이루어진 배열이라면 원소1 은 원소0으로부터 8바이트 떨어져 있음
- 다차원 배열은 참조지역성을 생각해야 함
  - 4x3 2차원 아파트 건물
  - 전단지를 돌릴 때 0층 0호, 1층 0호, 2층 0호... ,0층 1호, 1층 1호 ... 이런방식
  - 0층 0호, 0층 1호 .... 이런 방식
  - 2번째 방식(한 층을 먼저 다 돌리고 다음 층으로 이동하는 방식)은 첫 번째 방법보다 지역성이 좋고 힘이 덜듬
- 열 인덱스가 1 바뀌면(0,0 에서 0,1로) 인접한 메모리 위치에 있는 원소로 이동하지만 행 인덱스가 1 바뀌면(0,0 에서 1,0) 인접한 행으로 이동해야 하기 때문에
배열의 열 개수만큼 떨어져 있는 메모리 위치에 있는 원소로 이동해야 한다
  - 주소 공간상에서는 열 인덱스가 바뀔 때보다 행 인덱스가 바뀔 때 더 많은 이동이 일어남
- 이러한 접근 방법은 더 높은 차원으로 확대 적용할 수 있음
  - 5동, 4층, 3호라면
  - 주소 공간에서 인접한 동은 인접한 층(행) 보다 더 멀고, 인접한 호수(열) 보다는 더더욱 멈

## 비트맵

- 비트맵은 비트의 배열이다
- 비트맵에 대해 수행할 수 있는 기본 연산은 비트 설정(set, 1로 만들기), 비트 지우기(clear, 0으로 만들기), 비트가 1인지 검사하기, 비트가 0인지 검사하기
4가지
- 정수 나눗셈을 통해 특정 비트가 들어 있는 바이트를 찾을 수 있다
  - 17번째 비트면 17/8 = 2 (0, 1, 2) 세번째 바이트
  - 3비트 오른쪽으로 시프트함으로써 빠르게 계산할 수 있음(나누기 2^3)
- 비트 위치에 대한 마스크를 만들어야 함
  - 마스크는 들여다볼 수 있는 구멍이 있는 비트 패턴
  - 비트 번호와 0x07을 AND해서 하위 3비트를 얻음
    - 17이 비트 번호이면 00010001 AND 00000111 = 00000001
    - 앞에서 얻은 1만큼 1을 왼쪽으로 시프트하면 마스크를 얻음
    - 1을 1비트 왼쪽으로 시프트하면 00000010이 되고 이 값이 17번 비트를 찾기 위해 세 번째(2번) 바이트에서 어디를 봐야 하는지 알려줌
- 배열 인덱스와 비트 마스크를 사용하면 다음 연산을 쉽게 수행할 수 있다
  - 비트 설정: 비트들(index) = 비트들(index) OR 마스크
  - 비트 지우기: 비트들(index) = 비트들(index) AND (NOT 마스크)
  - 비트가 1인지 검사: (비트들(index) AND 마스크) != 0
  - 비트가 0인지 검사: (비트들(index) AND 마스크) == 0
- 자원이 사용 가능하거나 사용 중인지 여부를 나타낼 때도 비트맵을 유용하게 사용할 수 있다

## 문자열

- 여러 문자로 이뤄진 시퀀스를 문자열이라고 함
- 배열과 마찬가지로 문자열을 연산할 때도 그 길이를 알아야 함
  - 문자열 안에 길이를 저장하는 방법
  - 첫 번째 바이트에 문자열 길이를 넣을 수 있지만 문자열 길이가 255자로 제한됨
- C 문자열은 길이를 저장하지 않고 문자 배열에 들어 있는 문자열 데이터의 끝에 바이트를 하나 추가하고 NUL을 넣음

## 복합 데이터 타입

- 현대적인 대부분의 언어는 원하는 대로 데이터 타입(스위트)를 만들 수 있는 방법을 제공함
  - 구조체(structure)라고 함
- 구조체는 예상보다 메모리를 더 많이 차지하는 경우가 있음
  - 프로그래밍 언어는 멤버 순서가 바뀌면 문제가 될 수 있기 땜누에 프로그래머가 지정한 멤버 순서를 지킴
  - 언어는 메모리 정렬도 지켜야 하기 때문에 4번째와 5번째 바이트에 위치시키면 경계에 걸치기 때문에 배치를 바꿔야 함
  - 프로그래밍 언어 도구는 패딩을 필요한 만큼 추가해 이 문제를 해결함
  - 패딩을 사용하는 대신 멤버 순서를 바꾸면 메모리를 절약할 수 있음

## 단일 연결 리스트

- 배열은 실제 데이터만 저장하며 데이터 관리를 위한 부가 정보를 따로 요구하지는 않음
- 데이터양이 정해져 있지 않은 경우에는 배열이 적합하지 않음
  - 배열을 충분히 크게 만들지 않으면 데이터가 늘어났을 때 새로 더 큰 배열을 만들고, 기존 배열의 내용을 새 배열로 복사해야 하기 때문
  - 필요 이상으로 크게 배열을 잡아놓으면 메모리를 너무 낭비하게 됨
  - 목록의 중간에 원소를 추가하거나 목록 중간에 있는 원소를 삭제하려면 추가나 삭제하려는 원소 뒤의 모든 원소를 다시 복사해야 한다는 단점도 있음
- 연결 리스트는 목록에 들어갈 원소 개수를 모르는 경우 배열보다 더 잘 작동함
  - next는 리스트의 다음 원소 주소를 저장하는 포인터
  - 리스트에서 맨 앞은 헤드라고 함
  - 리스트의 마지막은 테일이라고 함

## 동적 메모리 할당

- 어디서 새 노드를 위한 메모리를 얻을 수 있지?
- 프로그램 데이터 공간의 구성에서 정적으로 할당된 데이터 영역 다음에 프로그램 런타임 라이브러리가 설정해주는 힙 영역
  - 별도의 메모리 관리 유닛이 없는 컴퓨터라면 이 힙 영역이 프로그램에서 사용할 수 있는 모든 데이터 메모리
- 배열 등의 변수가 사용하는 메모리는 정적
  - 할당된 주소는 바뀌지 않음
- 리스트 노드와 같은 조냊는 동적
  - 동적인 대상에 사용할 메모리를 힙에서 얻음
- 경험이 적은 프로그래머는 할당하지 않은 메모리를 해제하는 실수를 자주 저지르고 이미 해제된 메모리를 계속 사용하는 실수도 종종 저지름

## 더 효율적인 메모리 할당

- 노드에 문자열을 가리키는 포인터가 포함된 연결 리스트
  - 노드에 사용할 메모리는 물론 문자열에 사용할 메모리도 할당해야 함
- 노드와 문자열을 동시에 할당하면 부가 비용을 줄일 수 있음
- 노드를 할당한 후 문자열을 할당하는 대신 노드와 문자열의 크기를 합하고 메모리 경계를 지키기 위해 필요한 패딩을 추가한 크기의 공간을 할당할 수 있음

## 가비지 컬렉션

- 동적 메모리를 명시적으로 관리하면서 포인터를 잘못 쓰면 두 가지 문제가 생김
  - 포인터는 단지 메모리 주소를 나타내는 숫자
    - 포인터를 사용해 존재하지 않는 메모리에 접근하거나 프로세서의 메모리 경계에 맞지 않는 주소에 접근하면 예외가 발생함
- 자바나 자바스크립트 같은 언어에는 포인터가 없지만 직접 malloc이나 free를 하지 않으면서도 동적 메모리 할당을 지원함
  - 가비지 컬렉션이 있기 때문
- 자바 같은 언어는 포인터 대신 참조를 사용함
  - 참조는 포인터를 추상화해서 거의 비슷한 기능을 제공하지만 실제 메모리 주소를 노출하지는 않음
- 가비지 컬렉션을 사용하는 언어에는 데이터 요소를 만들어내면서 이 요소가 사용할 메모리도 할당하는 new 연산자를 제공하는 경우가 있음
- 데이터 요소를 삭제하는 경우에 대응하는 연산자는 없음
- 언어의 런타임 환경이 변수 사용을 추적해서 더 이상 사용하지 않는 메모리를 자동으로 해제해줌
- 가비지 컬렉션의 트레이드 오프
  - 프로그래머가 가비지 컬렉션 시스템을 제어할 수 없다는 점
  - 프로그램이 아주 중요한 일을 하는 도중에 가비지 컬렉션 시스템이 작동돼 문제가 생기는 경우도 있음
  - 불필요한 참조가 남는 경우가 있기 때문에 프로그램이 메모리를 더 많이 사용하는 경향이 있음

## 이중 연결 리스트

- 단일 연결 리스트의 delete 함수에서는 포인터를 제대로 변경하기 위해 삭제하려는 원소의 바로 앞 원소를 찾아가야만 함
  - 느림
- 메모리를 더 사용하면서 이런 문제를 해결해줄 수 있음
  - 이중 연결 리스트
- 다음 원소에 대한 포인터뿐만 아니라 이전 원소에 대한 포인터도 들어 있음
  - 노드당 부가 비용은 2배가 되지만 delete시 노드를 앞에서 방문할 필요가 없음
  - 공간/시간의 트레이드 오프

## 계층적인 데이터 구조

- 선형적인 데이터 구조
  - 리스트
  - n 번 노드를 순회하는 건 실용적이지 않음
- 가장 간단한 계층적 데이터 구조는 2진 트리
  - 노드가 최대 2개의 다른 노드와 연결될 수 있기 때문
- 2진 트리에서 어떤 대상을 검색하는 연산은 트리 깊이에 의해 정의되는 함수
  - n 번만 원소를 비교하면 됨
  - 연결된 리스트에선 n, 균형 잡힌 트리에서는 logn

## 대용량 저장장치

- 디스크의 기본 단위는 블록이고 연속적인 블록을 클러스터라고 부름
- 클러스터는 한 트랙 안에 있는 연속적인 섹터로 이뤄지므로 데이터를 한 클러스터에만 저장할 수있다면 좋음
  - 아주 높은 성능이 필요한 이런 식으로 데이터를 저장하는 경우도 있음
- 데이터는 사용 가능한 섹터가 있으면 위치와 관계없이 저장하고 운영체제의 장치 드라이버가 데이터가 연속적으로 저장된 것 같은 착각을 불러 일으킴
- 연결 리스트는 순회에 시간이 너무 오래 걸리기 때문에 어떤 디스크 블록이 사용 가능하고 어떤 블록이 사용 중인지를 알아내기 위한 좋은 해법이 아님
  - 8TiB 디스크에는 블록이 거의 20억개, 최악의 경우 250개의 블록을 읽기 위해서는 1초, 전체를 읽으려면 15년 실용적이지 않음
- 데이터를 메모리상에서 관리할 때는 포인터를 통해 메모리를 참조하더라도 충분
  - 메모리는 일시적이고 데이터는 장기적으로 저장할 때는 디스크를 사용하므로 영구적인 어떤 존잭 ㅏ필요함
  - 파일 이름
  - 디스크에 저장할 방법과 파일 이름과 파일의 데이터가 저장된 디스크 블록을 연결해줄 방법 필요
- UNIX에서 나옴
- 블록 중 일부를 아이노드로 따로 지정함
  - 아이노드는 디스크 블록에 대한 인덱스와 노드를 합친 단어
  - 아이노드는 인덱스 노드
  - 파일에 대한 여러 가지 정보가 들어감
- 아이노드에는 보통 직접 블록 포인터가 12개 있음
  - 직접 블록을 통해서 4096 * 12, 49152 바이트까지 데이터를 보관할 수 있음
  - 더 커지면 간접 블록을 사용함
    - 32비트를 사용하면 한 블록(4KiB)에는 4바이트짜리 인덱스가 1024개 있으므로 4MiB까지 지원 가능함
    - 더 커지려면 2중 간접 블록을 통해 4GiB, 3중 블록까지해 4PiB

## 데이터베이스

- 데이터베이스는 B 트리라는 데이터 구조를 활용한 시스템
  - 균형트리이지만 2진 트리는 아님
- B 트리는 균형 2진 트리보다는 공간을 덜 효율적으로 사용하지만 성능이 좋고 디스크에 데이터를 저장할 때 균형 2진 트리보다 더 성능이 좋음
- B 트리 노드에는 2진 트리보다 더 많은 가지(자식)이 있음
  - 가지의 수는 디스크 블록 하나를 정확히 꽉 채울 수 있는 숫자로 결정됨
- 공간만 차지하는 사용하지 않는 자식 링크가 있지만 어차피 디스크에서 데이터를 읽어올 때는 한 블록을 한 덩어리로 읽어오기 때문에 상관없다

## 인덱스

- 정렬된 데이터에 접근하면 효율적
- 인덱스의 경우 유지보수를 해야 한다는 트레이드오프가 있음
  - 데이터가 바뀔 때마다 모든 인덱스를 갱신해야 함
  - 변경보다 검색이 더 자주 벌어지기 때문에 지불할만한 비용임

## 객체 지향의 함정

- 객체 지향 프로그래밍은 훌륭한 방법론이지만 주의 깊게 사용하지 않으면 성능 문제가 발생할 수 있음
- 어떤 객체에 필요한 모든 데이터와 함수는 한 데이터 구조 안에 모여있음
- 객체는 전역적으로 알려진 함수 대신에 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 함
- 객체 내의 데이터가 데이터만 저장하는 데이터 구조처럼 꽉 짜여 있지는 않음
  - 성능이 결정적으로 중요할 때는 전통적인 배열을 사용해야 함

## 정렬

- 정렬해야 할 이유가 많음
  - 원하는 목록을 얻으려고
  - 정렬된 형태로 데이터를 저장하면 메모리 접근 횟수를 줄임으로써 검색을 빨리 끝낼 수 있기 때문
- 정렬 대상이 포인터 크기보다 크다면 데이터를 직접 정렬하는 대신 데이터를 가리키는 포인터를 재배열하는 방식으로 정렬해서 데이터 자체가 여기저기로 움직이지
않게 해야 함

## 해시

- 검색에 사용할 키(검색 시 동일성을 판정하는 기준)에 대해 균일하게 벽에 흩뿌려주는 해시 함수를 적용
- 해시 함수의 결괏값을 사용해 키에 대응하는 데이터를 메모리에 저장할 수 있음
  - 해시 함수는 메모리 크기보다 작은 범위의 값을 만들어내야 함
- 해시 함수의 결과를 배열 인덱스로 활용하는 방법을 해시 테이블이라고 함
  - 배열의 각 원소를 버킷이라고 함
- 좋은 해시 함수는 계산하기 쉬워야 하고 키를 골고루 버킷에 뿌려줘야 함
- 해시 함수의 값이 같을 수 있다(비둘기집 원리)
  - 이런 경우를 해시 충돌이라 함
- 해시 체인을 사용해 문제를 해결할 수 있다
  - 연결 리스트를 통해 해결할 수 있음