# 컴퓨터 내부의 언어 체계

----------

## 언어란 무엇인가

- 언어는 편의를 제공하기 위한 지름길
- 모든 언어(구어, 문어, 등등)의 뜻은 기호의 집합으로 인코딩됨
- 언어가 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 문맥을 공유해서 같은 기호에 같은 뜻을 부여할 수 있어야 함

## 문자 언어

- 문자 언어는 기호를 나열한 것
  - 맛집일 경우 ㅁ,ㅏ,ㅅ,ㅈ,ㅣ,ㅂ
- 기호나 조합은 무궁무진한 가능성이 있음
- 언어의 순서도 중요함
  - dog와 god은 다른 의미
- 문자 언어의 틀 세 가지 구성요소
  - 기호가 들어갈 상자
  - 상자에 들어갈 기호
  - 상자의 순서

## 비트

- 언어의 틀인 상자이다.
- 자연어에서는 이 상자를 문자(character)라고 부르고 컴퓨터에서는 비트(bit)라고 부른다
  - 비트는 2진법을 사용한다는 뜻의 binary(바이너리)와 숫자를 뜻하는(digit)이 합쳐진 말

## 논리 연산

- 비트 사용법 중 하나는 예/아니오 질문에 대한 답을 표현하는 것
  - 예를 참(true)라고 부르고 아니요를 거짓(false)라고 부름
- 어디인가? 와 같은 질문은 한 비트만으로 표현할 수 없음
- 자연어에서 예/아니오와 같은 구절을 엮어서 한 문장으로 만드는 경우가 있음
  - 밖에 비가 내리고 있거나 춥다면 코트를 입어라
- 다른 비트들이 표현하는 애용으로부터 새로운 비트를 만들어내는 이런 동작을 논리 연산(login operation)이라고 함

### 불리언 대수

- 대수란 수에 대한 연산 규칙의 집합
- 불리언 대수도 비트에 대해 사용할 수 있는 연산 규칙의 집합
  - 일반 대수와 마찬가지로 결합 법칙, 교환 법칙, 분배 법칙을 불리언 대수에 적용할 수 있음
- NOT
  - 논리적 반대
  - 거짓인 비트에 NOT을 하면 참
- AND
  - 둘 이상의 비트에 작용
  - 2비트 연산인 경우 첫 번째 비트가 참이고 두 번째 비트도 참인 경우에만 결과가 참
  - 2비트 이상일 경우 모든 비트가 참이면 참
- OR
  - 둘 이상의 비트에 적용
  - 2비트 연산인 경우 첫 번째 비트가 참이거나 두 번째 비트가 참이면 참
  - 2비트 이상일 경우 어느 한 비트라도 참이면 참
- XOR
  - 배타적OR
  - 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 참
  - 두 값중 어느 하나가 참이면 참이지만 둘 다 참이면 거짓

### 드모르간의 법칙

- 불리언 대수에 적용할 수 있는 법칙
- a AND b 라는 연산은 NOT(NOT a OR NOT b)
- NOT을 충분히 사용하면 AND 연산을 OR 연산으로 대신할 수 있는 것
- NOT NOT 춥다 OR NOT NOT 비가 온다로 OR을 사용해야 할 것을 춥다 && 비가온다 로 할수있다

## 정수를 비트로 표현하는 방법

### 양의 정수 표현

- 10 진수 체계에서는 10가지 기호인 숫자를 상자에 담을 수 있음
  - 오른쪽에서 왼쪽으로 상자가 쌓여가며, 각기 상자마다 다른 이름이 붙여져 있음
  - 일의 자리, 십의 자리 ...
  - 각 이름은 10의 거듭제곱에 해당됨
- 비트는 기호가 1과 0 두가지밖에 없음 따라서 각 상자는 자신의 오른쪽에 있는 상자의 자릿수에 2를 곲한 값의 자리를 표현함
- 2진수에서 가장 오른쪽의 비트를 가장 작은 유효 비트라 하고, 가장 왼쪽의 비트를 가장 큰 유효 비트라고 함
  - 가장 오른쪽의 비트를 변경하면 2진수의 값이 가장 작게 변경되고, 가장 왼쪽의 비트를 변경하면 2진수의 값이 가장 크게 변하기 때문

### 2진수 덧셈

- 논리 연산을 사용하여 표현할 수 있음
- 두 비트를 서로 더한 결과는 두 비트를 XOR 한 값과 같고, 올림은 두 비트를 AND 한 값과 같음
- 덧셈 결과가 우리가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어나면 오버플로가 발생함
  - 4비트 덧셈에서 1001(9)와 1000(8)을 더한 결과는 10001(17)이지만 왼쪽에 사용할 수 있는 비트가 없기 때문에
  0001(1)이 됨

## 음수 표현

- 4비트로는 0부터 15까지 16가지의 숫자를 표현할 수 있다
- 하지만 16가지의 숫자가 꼭 0부터 15까지는 아니다

### 부호와 크기

- 음수와 양수를 구별하기 위해 흔히 부호를 사용함
- 부호는 양, 음이 있음
  - 비트 하나를 써서 표현할 수 있음
- 가장 왼쪽 비트를 부호에 사용하고 나머지를 표현함
- 따라서 4비트면 0부터 15도 할 수 있지만 -7부터 7사이의 수를 표현할 수 있음
- 한 비트를 부호에 사용하고 나머지 비트를 수의 크기 즉 0부터의 거리(절댓값)을 표현하기 위해 사용하는 이런 방법을 부호와 크기 표현법이라고 함
  - 두 가지 이유로 널리 쓰이지 못하고 있음
    - 비트들을 구성하려면 비용이 드는데 0을 표현하는 방법이 두 가지라서 비용이 낭비됨
    - XOR과 AND를 통한 덧셈 계산을 사용할 수 없음

### 1의 보수

- 음수를 표현하는 또 다른 방법으로는 양수의 모든 비트를 뒤집는 방법
  - 1의 보수 표현법
- 부호와 크기 표현법과 비슷하게 비트들을 부호 비트와 나머지로 나누고, NOT 연산을 통해 보수를 얻음
- 0을 두 가지 방식으로 표현하는 문제와 덧셈을 쉽게 할 수 없는 문제가 있음

### 2의 보수

- +1에 더했을 때 0이나오는 비트 패턴을 찾고 이 패턴을 -1이라 부르자
  - 4비트 수의 경우 +1은 0001, 1111을 0001에 더하면 0000이 됨
- 2의 보수 표현법이라고 하며 부호가 있는 정수를 표현할 때 가장 널리 쓰이는 방법
- 어떤 수의 비트를 뒤집고(각 비트의 NOT) 1을 추가하면 음수를 얻을 수 있음
  - +1, 즉 0001의 비트를 뒤집으면 1110, 1을 더하면 1111이 되며 이 값이 -1을 표현함
  - +2는 0010이고 비트를 뒤집으면 1101, 1을 더하면 1110이며 이 값이 -2를 표현함
  - +3은 0011이고 비트를 뒤집으면 1100, 1을 더하면 1101이며 이 값이 -3을 표현함
  - +7은 0111이고 비트를 뒤집으면 1000, 1을 더하면 1001이며 이 값이 -7을 표현함
- 2의 보수에는 0의 중복 표현 문제가 없다
  - 0은 0000이고 비트를 뒤집으면 1111, 1을 더하면 [1]0000인데 5비트이므로 우리가 사용할 수 있는 4비트보다 크기때문에
  1을 올림 비트로 생각하고 무시한다. 결과는 0000인데 이 값은 처음 0과 같다

## 실수를 표현하는 방법

- 10진법의 실수에는 10진 소수점이 포함됨
- 밑이 2인 경우(2진법)실수를 표기하기 위해 2진 소수점을 표현할 방법이 필요함

### 고정소수점 표현법

- 2진수를 사용해 소수를 표현하기 위해 2진 소수점의 위치를 임의로 정하는 방법이 있음
  - 예를들어 4비트가 있다면 그중 2비트는 2진 소수점의 오른쪽에 있는 분수를 표현(4가지 분수값)하고 2비트는 왼쪽에 있는 숫자들을 표현(네 가지 정숫값)
  - 00 00 이면 정수 0 분수 0 값 0
  - 00 01 이면 정수 0 분수 1/4 값 1/4
  - 00 10 이면 정수 0 분수 2/4 값 1/2
  - 00 11 이면 정수 0 분수 3/4 값 3/4
  - 01 00 이면 정수 1 분수 0 값 1
  - 01 01 이면 정수 1 분수 1/4 값 1 + 1/4
- 소수점의 위치가 항상 일정하기 때문에 고정소수점 표현법이라 부름
- 이런 접근 방법이 잘 작동하기는 하지만 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많기 때문에 범용 컴퓨터에서 이런 방식을
사용하는 경우는 드뭄
  - 디지털 신호 처리 장치 등 특별한 목적에 쓰이는 일부 컴퓨터는 고정소수점 수를 쓰기도 함

### 부동소수점 표현법

- 더 넓은 범위의 값을 2진수로 표현한다는 문제를 해결하기 위해 과학적 표기법을 2진수에 적용함
  - 과학적 표기법은 수를 해석하는 새로운 방법을 도입해서 큰 범위의 수를 표현
- 과학적 표기법에서는 10진 소수점 왼쪽이 한 자리뿐인 소수(가수 라고함)에 10을 몇 번(지수 라고함) 거듭제곱한 값을 곱하는 방식으로
소수를 표현한다
  - 0.0012 대신 1.2 * 10^-3이며 이 값은 1.2 * 0.001 이므로 0.0012와 같다
  - 2진법으로 표기할 때는 10이 아닌 2를 밑으로 한다는 점만 다를 뿐
- 단순히 가수 부분만 보면 항상 2진 소수점의 위치가 같아 보이기 때문에 부동소수점 표현이라고 부르는게 어색할지 모르지만
가수가 1.2로 같다고 해도 지수가 무엇인가에 따라 소수점 왼쪽 숫자의 자리가 1/10일수도 있고 1일수도 있고 100,000일수도 있다는 점을 생각하면
소수점 위치는 정해져 있지 않다고 말할 수 있음
- 부동소수점 표현법은 지수와 기수를 분리함으로써 수를 표현할 때 필요한 0을 모두 저장하지 않고도 큰 수나 작은 수를 표현할 수 있음
  - 0.0, 00 은 0
  - 0.0, 01 은 0
  - 0.0, 10 은 0
  - 0.0, 11 은 0
  - 0.1, 00 은 0.5(1/2 * 2^0)
  - 0.1, 01 은 1.0(1.2 * 2^1)
  - 1.0, 01 은 2.0(1 * 2^1)
- 비트 조합 중에 낭비되는 부분이 많음(0을 표현하는 방법 4가지, 등등)
- 비트 패턴이 가능한 모든 수를 표현하지 못함
  - 지수가 커질수록 가수의 한 패턴과 다른 패턴 사이의 값 차이가 커짐

### IEEE 부동소수점 수 표준

- 부동소수점 수 시스템은 약간 이상하긴 하지만 컴퓨터에서 계산을 수행할 때 실수를 표현하는 표준 방법
  - 가수와 지수에 대해 각각 부호 비트를 사용함
    - 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져있음
  - 낭비되는 비트 조합을 최소화하고 반올림을 쉽게 하기 위한 여러 가지 트릭이 사용됨
    - 정규화
- 정규화는 가수를 조정해서 맨 앞(맨 왼쪽)에 0이 없게 만드는 것
  - 이런 식이라면 지수도 조정해야 함
  - 기본 정밀도 부동소수점 수
- 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략, 가수에 1비트를 더 사용할 수 있음
  - 2배 정밀도 부동소수점 수
- 기본 정밀도 수는 32비트를 사용
- 2배 정밀도 수는 64비트 사용

## 2진 코드화한 10진수 시스템

- BCD, binary-coded decimal
- 4비트를 사용해 10진 숫자를 하나 표현함
  - 12를 2진수로 하면 1100 이지만 BCD로 표현하면 0001 0010
    - 0001은 십의 자리에 있는 1, 0010은 일의 자리에 있는 2를 표현
- 더 이상 주류에 남아 있지 않음
  - 컴퓨터와 상호작용하는 장치 중에서 디스플레이나 가속도 센서 등이 BCD를 사용하는 경우가 있음
- 2진수를 효율적으로 활용하지 못하기 때문에 주류에 남아 있지 않음
  - 비트 낭비가 심함

## 2진수를 다루는 쉬운 방법

- 2진수는 눈이 아픔

### 8진 표현법

- 2진수 비트들을 3개씩 그룹으로 묶는 아이디어
- 100101110001010100
- 100 / 101 / 110 / 001 / 010 / 100
  - 456124 8진 표현법

### 16진 표현법

- 8진 표현법이 아직도 쓰이기는 하지만 과거처럼 널리 쓰이지는 않음
- 요즘은 컴퓨터 내부가 8비트의 배수를 사용해 만들어지기 때문
  - 8의 배수는 4(16진수 한 자리의 비트 수)로 균일하게 나누어지지만 3(8진수 한자리 비트수)으로는 균일하게 나눠지지 않음
- 16진수는 10을 표현할 숫자부터 시작해서 15에 이르기까지 여섯 가지 숫자가 더 필요함
  - abcdef(ABCDEF)
- 11010011111111000001
- 1101/0011/1111/1100/0001
  - d3fc1

### 프로그래밍 언어의 진법 표기법

- 0으로 시작하는 숫자는 8진 숫자
  - 017은 8진수 이며 값은 10진수로 15
- 1부터 9사이의 숫자로 시작하는 숫자는 10진수
  - 123은 10진수
- 0x가 앞에 붙은 숫자는 16진수
  - 0x12f는 16진수이며 값은 10진수 303
- 이 방법은 0이 8진수인지 10진수인지 구분할 수 없지만 어차피 0은 8진수나 10진수에서 똑같이 0을 가리키기 때문에 중요하지 않음
- 2진수 표현을 제공하는 프로그래밍 언어는 거의 없지만 0b라는 접두사를 사용해 2진수를 표현함

## 비트 그룹 이름

- 비트는 너무 작아서 기본 단위로 사용하기에는 유용성이 떨어짐
  - 비트를 좀 더 큰 덩어리로 조직화해야 함
- 여러 시도가 있었지만 시간이 지남에 따라 세계적으로 8비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 이를 바이트라고 부름
- 비트의 묶음
  - 니블(nibble)
    - 4비트
  - 바이트(byte)
    - 8비트
  - 하프 워드(half word)
    - 16비트
  - 워드(word)
    - 32비트
  - 더블 워드(double word)
    - 64비트
- 워드(word)는 각 컴퓨터가 설계상 자연스럽게 사용할 수 있는 비트 묶음의 크기를 가리키는 말로 쓰임
- 큰 수를 가리키기 위한 표준 용어가 존재한다
  - 메가바이트, 킬로바이트, 기가바이트, 테라바이트
  - 하지만 메가, 킬로 이런것들은 다 10진수인데 킬로바이트는 1024 즉 2^10을 뜻한다
- 따라서 1킬로바이트는 1000, 1키비바이트는 1024, 메비, 기비, 테비가 새로 생겼다
- 1 킬로바이트는 1000바이트, 1 메가바이트는 1000 킬로바이트
- 1 키비바이트는 1024, 2^10 바이트, 1 메비바이트는 2^20 바이트

## 텍스트 표현

### 아스키 코드

- 수와 마찬가지로 텍스트를 표현하는 방법의 경우에도 몇 가지 아이디어가 서로 경쟁함
- 1963년부터 승자는 정보 교환을 위한 미국 표준 코드(ASCII, American Standard Code for Information Interchange)
- 아스키는 키보드에 있는 모든 기호에 대해 7비트 수 값을 할당함
  - 65는 대문자 A
  - 65 -> 1000001
- 아스키 코드 표에는 문자가 아닌 장치를 제어하기 위해 쓰이는 제어 문자도 있음

### 다른 표준의 진화

- 영어를 표현하는 데 필요한 모든 문자를 아스키가 포함하고 있어 상당 기간 표준 역할을 했지만 그 밖의 언어를 지원해야 할 필요가 점차 늘어남
- 비트 가격이 떨어짐에 따라 유니코드(Unicode)라는 새로운 표준이 생김
  - 문자에 16비트 코드를 부여함
- 그 후 21비트까지 확장됐음

### 유니코드 변환 형식 8비트

- 컴퓨터는 7비트값을 처리하도록 설계되지 않았기 때문에 8비트를 사용해 아스키 문자를 저장함
- 유니코드는 문자 코드에 따라 각기 다른 인코딩을 사용해 이런 문제를 해결함
  - 인코딩은 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴
- 유니코드 변환 형식 8비트(UTF-8)라는 인코딩 방법이 하위 호환성과 효율성 때문에 가장 널리 쓰이고 있음
  - 모든 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩할 때는 추가 공간이 필요하지 않음
  - 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩함

## 문자를 사용한 수 표현

- UTF-8은 문자(예:A)를 표현하는 비트들로부터 나온 숫자들을 표현하는 숫자들을 표현하기 위해 숫자(0x41)들을 사용함

### 출력 가능하게 변경한 인코딩

- QP 인코딩
- 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법

### 베이스64 인코딩

- QP인코딩은 1바이트를 표현하기 위해 3바이트를 사용하기 때문에 아주 비효율적
- 3바이트 데이터를 4문자로 표현함
- 3바이트 데이터의 24비트를 네 가지 6비트 덩어리로 나누고, 각 덩어리의 6비트값에 출력 가능한 문자를 할당해 표현함
- 모든 3바이트 조합을 4바이트 조합으로 변환할 수 있음
  - 우너본 데이터 길이가 3바이트의 배수라는 보장은 없음
  - 패딩문자를 도입해 이런 문제를 해결
    - 원본 데이터가 2바이트 남으면 끝에 =, 1바이트 남으면 끝에 ==을 붙임

### URL 인코딩

- URL 인코딩은 퍼센트 인코딩이라고 부르는데 %뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩함
  - / (슬래쉬 문자)는 URL에서 특별한 의미를 가짐. 이 문자의 아스키 코드는 47, 16진수로는 2F 따라서 /를 URL에 사용하되 /가 표현하는 특별한 의미를 뜻하고 싶지는
  않은 경우 /를 %2F라는 문자열로 대신함

## 색을 표현하는 방법

- 컴퓨터 모니터는 빨간색, 녹색, 파란색 광선을 섞어서 색을 만들어내며 이런 색 표현법을 RGB 색 모델이라 함