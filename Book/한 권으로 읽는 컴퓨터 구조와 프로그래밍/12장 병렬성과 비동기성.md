# 병렬성과 비동기성

- 원래는 작업을 수행할 수 있는 컴퓨터(CPU)가 하나뿐이어서 그냥 여러 작업을 동시에 수행할 수 있는 척만 함
- 지금은 멀티코어 프로세서가 대세이고, 컴퓨터는 실제로 한 번에 둘 이상의 일을 하고 있음
- 처리 순서가 중요한 경우가 있음
  - 공동 계좌에서 한 사람이 75만원을 인출하려하고, 동시에 다른 사람도 50만원을 인출하려고 함
    - 이런 경우를 경합 조건(race condition)이라고 함
    - 둘 중 한 사람에게만 돈을 지급해야 초과 인출을 막을 수 있음
  - 근본적으로 일부 연산에 대해서는 멀티태스킹을 막아야 함
  - 멀티태스킹의 이점을 잃지 않고 경합 조건을 해결하고 락을 사용하기는 어려움

## 경합 조건이란 무엇인가

- 2개(또는 그 이상)의 프로그램이 같은 자원에 동시에 접근하고, 자원 사용 순서에 따라 결과가 달라지는 경우

## 공유 자원

- 거의 대부분의 자원은 공유될 수 있다.
  - 메모리, 입출력 장치 등

## 프로세스와 스레드

- 운영체제는 프로세스(process)를 관리한다
  - 프로세스는 사용자 공간(user space)에서 실행되는 프로그램
- 멀티코어 시스템에서는 여러 프로그램이 병렬로 실행될 수 있다
  - 동시성은 겉보기에 여러 프로그램(또는 프로세스나 작업)이 실행되는 것처럼 보이는 것
  - 병렬성은 실제로도 여러 프로그램이 동시에 실행되는 것
  - 동시성 프로그램은 다 병렬적인 것은 아니지만 병렬성 프로그램은 모두 동시성 프로그램
- 프로그램이 병렬로 실행된다고 경합 조건이 발생하는 것은 아니고 병렬로 실행되는 프로그램이 자원을 공유해야 경합 조건이 발생함
- 프로세스는 핸들러를 인터럽트할 수 있게 만들어야 한다
  - 핸들러가 실행하는 중간에 잠시 실행을 중단하면서 상태를 저장하고, 나중에 그 위치로 돌아와 실행을 재개할 수 있다
  - 그럴려면 저장한 상태가 필요한데 그것은 스택
  - 하지만 프로세스는 스택이 하나 뿐
  - 따라서 스레드를 사용
- 스레드는 정적인 데이터와 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분
- 각 스레드는 자신이 CPU 레지스터를 완전히 소유한다고 가정함
- 따라서 한 스레드에서 다른 스레드로 실행이 넘어갈 때는 스레드 스케줄러가 CPU 레지스터를 저장해야 함
  - 운영체제가 프로세스에서 다른 프로세스로 문맥을 전환(컨텍스트 스위칭)할 때 일어나는 일과 비슷
- 스레드는 프로세스보다 저장할 컨텍스트의 크기가 작기 때문에 프로세스 컨텍스트 스위칭보다 더 빠름
  - 스레드를 경량 프로세스라고 부르기도 함
- 어떤 경우든 스레드가 올바른 해법이라는 말은 아님
  - 스레드를 남용하면 여러 가지 나쁜 경험을 야기할 수 있음
- 스레드는 데이터를 공유하기 때문에 여러가지 문제가 발생할 수 있음

## 락

- 처리해야 할 문제는 공유 자원이 아님
- 실제로 처리해야 할 문제는 여러 작은 연산으로 이뤄진 작업을 어떻게 원자적으로 만들 수 있을까하는 문제
  - 중요한 부분을 상호 배제 메커니즘을 통해 원자적으로 처리하게 만들어야 함

### 트랜잭션과 작업 크기

- 트랜잭션에 들어 있는 모든 연산은 모두 다 성공하거나 모두 다 실패한다
- 각 연산을 독립적으로 수행하는 대신 한꺼번에 묶어서 처리한다
- 분명한 가이드라인은 어떤 대상을 잠그는 시간을 최소화하라는 것
  - 락이 걸려 있는 시간이 길면 동시성이 줄어듬
- 분명해 보이지 않은 가이드라인으로는 락이 걸린 작업의 크기를 최소화하는 것
  - 잔고를 변경할 때마다 전체 은행을 잠근다면 좋은 해법이 아님
  - 해당 계좌만 잠그는 것이 좋음

### 락 대기

- 프로그램이 락을 기다리는 동안 그 어떤 유용한 일도 할 수 없다면 락을 세밀하게 만들어도 아무 이득이 없음
  - 다중성이라는 말을 멀티태스킹 전체 측면에서 살펴봐야 함
- 락을 성공적으로 얻을 때까지 락 획득을 반복 시도하거나 락을 요청하는 존재가 락 획득 요청을 락을 관리하는 쪽에 등록하고, 요청이 받아들여졌을 때
통지 받을 수 있음

### 교착 상태

- 프로그램 #1 은 성공적으로 락 A를 얻고, 프로그램 #2는 성공적으로 락 B를 얻음
- 다음으로 프로그램 #1은 락 B를 얻으려 시도하지만 프로그램 #2가 락 B를 갖고 있기 때문에 얻을 수 없음
- 반대의 상황도 마찬가지
- 이러한 상황을 교착 상태(deadlock)이라고 함

#### 교착 상태의 원인

- 다음 네 가지 조건을 동시에 만족하는 경우에만 발생함
  - 상호 배제(mutual exclusion)
    - 공유 자원을 함께 쓸 수 없어서 어느 한 프로세스가 독점적으로 사용해야만 함
  - 점유 대기(hold and wait)
    - 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청함
  - 비선점(no preemption)
    - 프로세스가 할당받은 자원을 강제로 뺏을 수 없음
  - 순환 대기(circular wait)
    - 각 프로세스가 서로 순환적으로 다른 프로세스가 갖고 있는 자원을 요구함

#### 교착 상태 방지 방법

- 자원을 상호 배제하지 않고 언제든 공유할 수 있는 자원으로 만든다
- 어느 자원을 점유한 다음에 다른 자원을 요구하지 않고 한꺼번에 자원을 요구한다
- 선점형으로 바꾼다
- 자원마다 우선순위를 부여해서 모든 프로세스가 다 서로 정해진 순서대로만 자원을 요구한다

### 단기 락 구현

- 검사 후 설정(test and set) 명령어 제공
  - 원자적 명령어
  - 어떤 메모리 위치에 들어 있는 값을 1로 설정하고, 원래 그 위치에 들어 있던 값을 돌려줌
    - 처음 이 메모리에는 0이 들어 있어야 함
  - 둘 이상의 프로세스가 이 명령어를 사용하면 그중 한 프로세스의 검사 후 설정 명령어는 0을 반환하지만 나머지 프로세스의 검사 후 설정 명령어는
  1을 반환함.
    - 명령이 원자적 명령이기 때문에 어떤 프로세스가 0을 반환받았다면 이 프로세스에 의해 메모리 내용이 1로 바뀌고 나머지 프로세스는 1을 반환받을 수 없음
- 비교 후 바꾸기(compare and swap) 명령어 제공
  - 검사 후 설정과 비슷하지만 한 값만 설정하는 대신 명령어를 호출하는 쪽에서 예전 값과 새 값을 모두 제공함
  - 예전 값이 메모리 위치에 들어 있는 현재 값과 일치하면 메모리의 값을 새로운 값으로 바꾸고 프로세스는 락을 얻음

### 장기 락 구현

- 장기간 락은 메모리보다 좀 더 영구적인 저장소에 저장돼야 함
  - 파일을 사용해 구현

## 브라우저 자바스크립트

- 자바스크립트는 단일 스레드로 돌아감
  - 어떻게 단일 스레드에서 동시성이 문제가 됨?
- 자바스크립트의 원래 목표는 더 빠르게 사용자 피드백을 제공하고 인터넷 트래픽을 줄이는 것
  - 신용카드번호를 입력 받는 필드
    - 자바스크립트가 없을 때는 입력한 데이터를 서버로 보내고 검증
    - 입력을 잘못한 경우 서버까지 요청을 보내야 함
  - 자바스크립트는 이 경우 알아서 할 수 있음
- 자바스크립트가 사용자 이벤트에 응답하는 짧은 프로그램을 실행하기 위해 만들어졌기 때문에
자바스크립트 구현은 이벤트 루프 모델을 사용함
  - 실행할 작업을 이벤트 큐에서 꺼냄
  - 이벤트 코드를 실행
  - 이벤트 도착을 기다림
  - 실행할 작업을 이벤트 큐에 추가함

## 비동기 함수와 프로미스

- 프로미스는 비동기 연산을 처리하는 라이브러리가 프로미스를 사용하면 제대로 작동할 가능성이 더 커진다는 점

```javascript
let promise = new Promise(function(resolve, reject) {
    작업 수행
    if(작업 성공 시)
        resolve(성공 시 돌려줘야 할 값);
    else
        reject(실패 시 돌려줘야 할 값);
})
```
- 프로미스에 비동기 연산을 수행하는 함수를 넘김
  - 이 함수는 두 함수를 인자로 받음
    - 비동기 연산이 성공적으로 종료하면 호출해야 하는 함수
    - 비동기 연산이 실패하면 호출해야 하는 함수
- 프로미스에 넘기는 함수는 비동기 연산을 수행하고, 수행 성공이나 실패에 따라 resolve나 reject를 호출하면 자바스크립트가 이를 이벤트 큐에 넣어줌
- 프로미스는 메서드 채이닝이 가능

```javascript
promise.then(
    function(value) {
        resolve에 전달된 값을 value로 받아서 비동기 연산 성공 시 해야 할 일을 처리
    },
    function(value) {
        reject에 전달된 값을 value로 받아서 비동기 연산 실패 시 해야 할 일을 처리
    }
);
```

- 프로미스를 사용하면 내포의 깊이를 줄일 수 있지만 좀 더 따라 읽기 편한 코드를 원한다면 다른 방법을 사용해야 한다
  - async와 await

