# 파티션

- 파티션 기능은 테이블을 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리해서 관리할 수 있게 해준다.
  - 주로 대용량의 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적으로 사용한다.
  - 무조건 성능이 빨라지는 만병 통치약은 아니다.

----------

## 개요

### 파티션을 사용하는 이유

- 테이블의 데이터가 많아진다고해서 무조건 파티션을 적용하는 것이 효율적인 것은 아니다.
- 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등이
파티션이 필요한 대표적인 예다.

#### 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

- 인덱스는 SELECT 뿐 아니라 UPDATE나 DELETE 쿼리르 위해 필요한 때도 많다.
  - UPDATE, DELETE를 하려면 일단 검색해야 하기 때문
- 하지만 인덱스의 크기가 커지면 SELECT 뿐 아니라 INSERT나 UPDATE, DELETE 작업도 함께 느려진다.
  - 특히 한 테이블의 인덱스 크기가 물리적으로 MySQL이 사용 가능한 메모리 공간보다 크다면 심각
  - 데이터는 물리적인 메모리보다 큰 것이 일반적이겠지만 인덱스의 워킹 셋이 크다면 쿼리 처리가 상당히 느려짐
    - 워킹 셋
      - 데이터가 100만 건이 있어도 주로 사용되는 건 최신 20~30%만 사용됨
      - 활발하게 사용되는 데이터를 워킹 셋이라고 표현함
- 파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 만들어 준다.

#### 데이터의 물리적인 저장소를 분리

- 데이터 파일이나 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 백업이나 관리 작업이 어려워짐.
  - 테이블의 데이터나 인덱스를 파일 단위로 관리하는 MySQL에서 더 치명적 문제가 될 수 있음

#### 이력 데이터의 효율적인 관리

- 로그는 단기간에 대량으로 누적됨과 동시에 일정 기간이 지나면 쓸모가 없어짐
  - 별도로 아카이빙하거나 백업한 후 삭제해버리는 것이 일반적
  - 다른 데이터에 비해 라이프 사이클이 짧음
- 로그 테이블에서 불필요해진 데이터를 백업하거나 삭제하는 작업은 일반 테이블에서는 상당히 고부하의 작업
- 파티션 테이블로 관리하면 불필요한 데이터 삭제 작업은 단순히 파티션을 추가하거나 삭제하는 방식으로 빠르게 해결 가능
  - 해당 연도 파티션, 해당 월 파티션 등

### MySQL 파티션의 내부 처리

#### 파티션 테이블의 레코드 INSERT

```mysql
CREATE TABLE tb_article(
    article_id INT NOT NULL,
    reg_date DATETIME NOT NULL,
    PRIMARY KEY (article_id, reg_date)
) PARTITION BY RANGE (YEAR(reg_date)) (
    PARTITION p2009 VALUES LESS THAN (2010),
    PARTITION p2010 VALUES LESS THAN (2011),
    PARTITION p2011 VALUES LESS THAN (2012),
    PARTITION p9999 VALUES LESS THAN MAXVALUE ,
);
```

- INSERT 쿼리가 실행되면 MySQL 서버는 INSERT되는 칼럼의 값 중에서 파티션 키 칼럼의 값을 이용해 파티션 표현식을 평가하고,
레코드가 저장될 적절한 파티션을 결정한다.

#### 파티션 테이블의 UPDATE

- UPDATE 쿼리의 WHERE 조건에 파티션 키 칼럼이 조건으로 존재한다면 그 값을 이용해 레코드가 저장된 파티션에서 빠르게 대상 레코드를 검색할 수 있지만
WHERE 조건에 파티션 키 칼럼의 조건이 명시되지 않았다면 모든 파티션을 검색해야 한다.
  - 파티션 키 외의 칼럼만 변경될 때는 일반 테이블과 마찬가지로 칼럼 값만 변경한다
  - 파티션 키 칼럼이 변경될 때는 기존 레코드가 저장된 파티션에서 해당 레코드를 삭제하고, 파티션 키 칼럼의 표현식을 평가하고
  레코드를 이동시킬 새로운 파티션을 결정해서 레코드를 새로 저장한다.

#### 파티션 테이블의 검색

- 파티션 테이블을 검색할 때 성능에 크게 미치는 조건
  - WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
  - WHERE 절의 조건이 인덱스를 효율적으로 사용(인덱스 레인지 스캔)할 수 있는가?
  - 파티션 선택 가능 + 인덱스 효율적 사용 가능
    - 쿼리가 가장 효율적으로 처리
    - 파티션의 개수와 관계없이 검색을 위해 꼭 필요한 파티션의 인덱스만 레인지 스캔
  - 파티션 선택 불가 + 인덱스 효율적 사용 가능
    - 모든 파티션을 대상으로 검색.
    - 각 파티션에 대해서는 인덱스 레인지 스캔을 할 수 있기 때문에 최종적으로 모든 파티션의 개수만큼
    인덱스 레인지 스캔을 수행해서 검색하게 됨
  - 파티션 선택 가능 + 인덱스 효율적 사용 불가
    - 검색을 위한 파티션만 읽지만 인덱스를 사용할 수 없기 때문에 풀 테이블 스캔
  - 파티션 선택 불가 + 인덱스 효율적 사용 불가
    - 모든 파티션의 풀테이블 스캔

#### 파티션 테이블의 인덱스 스캔과 정렬

- MySQL의 파티션 테이블에서 인덱스는 전부 로컬 인덱스
  - 모든 인덱스틑 파티션 단위로 생성
  - 파티션과 관계없이 테이블 전체 단위로 통합된 인덱스는 지원 X
- MySQL 서버는 여러 파티션에 대해 인덱스 스캔을 수행할 때 각 파티션으로부터 조건에 일치하는 레코드를
정렬된 순서로 읽으면서 우선순위 큐에 임시로 저장하고, 우선순위 큐에서 다시 필요한 순서(인덱스의 정렬 순서)대로 데이터를 가져간다.

#### 파티션 프루닝

- 옵티마이저에 의해 안읽어도 된다고 판단되면 불필요한 파티션에는 접근하지 않는다.
  - 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 파티션 프루닝이라고 한다.

----------------

## 주의사항

### 파티션의 제약사항

- 스토어드 루틴이나 UDF, 사용자 변수 등을 파티션 표현식에 사용할 수 없다.
- 파티션 표현식은 일반적으로 칼럼 그 자체 또는 MySQL 내장 함수를 사용할 수 있는데, 일부 함수들은 파티션 생성은 가능하지만
프루닝을 지원하지 않을 수도 있다.
- 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함해야 한다.
- 파티션된 테이블의 인덱스는 모두 로컬 인덱스이며, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 가질 수 있다. 파티션 개별로 인덱스를 
변경하거나 추가할 수 없다.
- 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진만 가질 수 있다.
- 최대 8192개의 파티션을 가질 수 있다.
- 파티션 생성 이후 sql_mode 시스템 변수 변경은 파티션의 일관성을 깨뜨릴 수 있다.
- 파티션 테이블에서는 외래키를 사용할 수 없다.
- 파티션 테이블은 전문 검색 인덱스 생성이나 전문 검색 쿼리를 사용할 수 없다.
- 공간 데이터를 저장하는 칼럼 타입은 파티션 테이블에서 사용할 수 없다.
- 임시 테이블은 파티션 기능을 사용할 수 없다.

### 파티션 사용 시 주의사항

- 파티션의 목적이 작업의 범위를 좁히는 것인데, 유니크 인덱스는 중복 레코드에 대한 체크 작업때문에 범위가 좁혀지지 않는 점이다.

#### 파티션과 유니크 키(프라이머리 키 포함)

- 테이블에 유니크 인덱스(PK 포함)가 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 칼럼을 포함해야 한다.

#### 파티션과 open_files_limit 시스템 변수 설정

- MySQL에서는 파일 단위로 테이블을 관리하는데 동시에 오픈된 파일의 개수가 상당히 많아질 수 있다.
  - 이를 제한하기 위해 시스템 변수에 동시 오픈할 수 있는 적절한 파일의 개수를 설정할 수 있다.
- 파티션 되지 않은 일반 테이블은 테이블 1개당 2~3개 수준이지만 파티션 테이블에서는 (파티션 개수 * 2~3)개가 된다.
- 쿼리가 적절히 파티션 프루닝으로 최적화되어 파티션 가운데 몇개의 파티션만 접근해도 된다고 하더라도 모든 파티션의 데이터 파일을 오픈해야 한다.
- 파티션을 많이 사용하는 경우에는 open_files_limit 시스템 변수를 적절히 높은 값으로 다시 설정해 줄 필요가 있다.

-------------

## MySQL 파티션의 종류

### 레인지 파티션

- 파티션 키의 연속된 범위로 파티션을 정의하는 방법으로 가장 일반적으로 사용됨
- 다른 파티션 방법과 달리 MAXVALUE 키워드를 이용해 명시되지 않은 범위의 키 값이 담긴 레코드를 저장하는 파티션을 정의할 수 있음

#### 레인지 파티션의 용도

- 날짜를 기반으로 데이터가 누적되고 연도나 월, 또는 일 단위로 분석하고 삭제해야 할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 자주 실행될 때

- 대부분 이력을 저장하는 로그 테이블에 레인지 파티션을 적용함

#### 레인지 파티션 테이블 생성

- PARTITION BY RANGE 키워드로 레인지 파티션을 정의한다.
- PARTITION BY RANGE 뒤에 칼럼 또는 내장 함수를 이용해 파티션 키를 명시한다.
- VALUES LESS THAN으로 명시된 값보다 작은 값만 해당 파티션에 저장하게 설정한다.
  - LESS THAN 절에 명시된 값은 그 파티션에 포함되지 않음
- VALUES LESS THAN MAXVALUE로 명시되지 않은 레코드를 저장할 파티션을 지정한다
  - 선택사항이므로 지정하지 않아도 됨
  - 정의되지 않으면 명시되지 않은 레코드가 INSERT 될 때 에러가 발생함

#### 레인지 파티션의 분리와 병합

- LESS THAN MAXVALUE 파티션을 이미 가지고 있을 때 ALTER TABLE ... ADD PARTITION 명령으로 새로운 파티션을
추가하려고하면 에러가 발생한다.
  - 이 경우에는 ALTER TABLE ... REORGANIZE PARTITION 명령을 사용해야 한다.
  ```mysql
  ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
  REORGANIZE PARTITION p3 INTO(
      PARTITION p3 VALUES LESS THAN (2011),
      PARTITION p4 VALUES LESS THAN MAXVALUE 
  );
  ```
  - LESS TAHN MAXVALUE 파티션의 레코드를 모두 새로운 두 개의 파티션으로 복사하는 작업이 필요하다.
  - 시간이 오래 걸린다.
- 보통 미래에 사용될 파티션을 미리 2~3개 정도 더 만들어 두는 형태로 테이블을 생성하기도 한다.
- 배치 스크립트를 이용해 주기적으로 파티션 테이블의 여유 기간을 판단해서 파티션을 자동으로 추가하는 방법을 사용한다.

#### 파티션 삭제

- DROP PARTITION 키워드에 삭제하려는 파티션의 이름을 지정하면 된다.
- 특정 파티션을 삭제하는 작업은 아주 빠르게 처리되므로 날짜 단위로 파티션된 테이블에서 오래된 데이터를 삭제하는 용도로 자주 사용된다.
- 레인지 파티션을 사용하는 테이블에서는 항상 가장 오래된 파티션 순서로만 삭제할 수 있다.
  - 중간에 있는 파티션을 먼저 삭제할 수 없다.
- 레인지 파티션을 사용하는 테이블에서는 가장 마지막 파티션만 새로 추가할 수 있고, 가장 오래된 파티션만 삭제할 수 있다.
- 파티션이 재구성되는 동안은 테이블의 쓰기가 불가능해지므로 파티션 재구성 작업은 서비스 점검 시간대나 쿼리 처리가 많지 않은 시간대에
진행하는 것이 좋다.


### 리스트 파티션

- 리스트 파티션은 레인지 파티션과 많은 부분 흡사하지만 파티션 키 값 하나하나를 리스트로 나열한다는 것이 가장 큰 차이점이다.
  - MAXVALUE 파티션을 정의할 수 없다.

#### 리스트 파티션의 용도

- 다음과 같은 특성을 지닐 때는 리스트 파티션을 사용하는 것이 좋다.
  - 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
  - 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
  - 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때

#### 리스트 파티션 테이블 생성

```mysql
CREATE TABLE product(
    id INT NOT NULL ,
    name VARCHAR(30),
    category_id INT NOT NULL 
) PARTITION BY LIST (category_id) (
    PARTITION p_appliance VALUES IN (3),
    PARTITION p_computer VALUES IN (1,9),
    PARTITION p_sports VALUES IN (2,6,7),
    PARTITION p_etc VALUES IN (4,5,8,NULL),
)
```

- 정수 타입의 파티션 키뿐만 아니라 파티션 타입이 문자열 타입일 때도 리스트 파티션을 사용할 수 있다.

#### 리스트 파티션의 분리와 병합

- 파티션을 정의하는 부분에서 VALUES IN을 사용한다는 것 외에는 레인지 파티션의 추가 및 삭제, 병합 작업이 모두 같다.

#### 리스트 파티션 주의사항

- 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없다.
- 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있다.

### 해시 파티션

- MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법
  - MySQL에서 정의한 해시 함수는 복잡한 알고리즘이 아니라 파티션 표현식의 결괏값을 파티션의 개수로 나눈 나머지로
  저장될 파티션을 결정하는 방식
- 해시 파티션의 파티션 키는 항상 정수 타입의 칼럼이거나 정수를 반환하는 표현식만 사용될 수 있다.

#### 해시 파티션의 용도

- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때

#### 해시 파티션 테이블 생성

```mysql
CREATE TABLE employees (
  id INT NOT NULL ,
  first_name VARCHAR(30),
  last_name VARCHAR(30)
) PARTITION BY HASH ( id ) PARTITIONS 4(
    PARTITION p0 ENGINE =INNODB,
    PARTITION p1 ENGINE =INNODB,
    PARTITION p2 ENGINE =INNODB,
    PARTITION p3 ENGINE =INNODB
)
```

#### 해시 파티션의 분리와 병합

- 모든 파티션에 저장된 레코드를 재분배하는 작업이 필요하다.
  - 파티션의 분리와 병합으로 인해 파티션의 개수가 변한다는 것은 해시 알고리즘을 변경하는 것이므로 전체 파티션이 영향을 받는다

- 해시나 키 파티션은 파티션 단위로 레코드를 삭제하는 방법이 없다.
- 해시 파티션이나 키 파티션에서 특정 파티션을 두 개 이상으로 파티션을 분할하는 기능은 없다.
- 해시나 키 파티션은 2개 이상의 파티션을 하나의 파티션으로 통합하는 기능을 제공하지 않는다.

#### 해시 파티션 주의사항

- 특정 파티션만 삭제(DROP PARTITION)하는 것은 불가능하다.
- 새로운 파티션을 추가하는 작업은 단순히 파티션만 추가하는 것이 아니라 기존 모든 데이터의 재배치 작업이 필요하다.
- 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리하기 때문에 해시 파티션이 용도에 적합한 해결책인지 확인이 필요하다.

### 키 파티션

- 해시 파티션과 사용법과 특성이 거의 같다.
- 키 파티션에서는 정수 타입이나 정숫값을 반환하는 표현식뿐만 아니라 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있다.
  - 선정된 파티션 키의 값을 MD5() 함수를 이용해 해시 값을 계산하고 그 값을 MOD 연산해서 각 파티션에 분배

#### 키 파티션의 주의사항 및 특이사항

- 프라이머리 키나 유니크 키를 구성하는 칼럼 중 일부만으로도 파티션을 할 수 있다.
- 유니크 키를 파티션 키로 사용할 때 해당 유니크 키는 반드시 NOT NULL 이어야 한다.

### 리니어 해시 파티션/리니어 키 파티션

- 해시, 키 파티션은 새로운 파티션을 추가하거나 파티션을 통합해서 개수를 줄일 때 대상 파티션만이 아니라 테이블의 전체 파티션에 저장된
레코드의 재분배 작업이 필요하다.
- 이러한 단점을파티션 알고 위해 리니어 해시 파티션/리니어 키 파티션 알고리즘이 고안됨.

### 파티션 테이블의 쿼리 성능

- 테이블을 10개로 파티션해서 10개의 파티션 중에서 주로 1~3개 정도의 파티션만 읽고 쓴다면 파티션 기능이 성능 향상에 도움이 되지만,
10개로 파티션하고 10개ㅑ를 아주 균등하게 사용한다면 이는 성능 향상보다는 오버헤드만 심해지는 결과를 가져올 수 있다.
- 레인지 파티션 이외의 파티션을 적용할때는 파티션 프루닝을 더 많이 고민해보고 적용해야 한다.