# 옵티마이저와 힌트

- MySQL 서버로 요청된 쿼리는 내부적으로 그 결과를 만들어내는 다양한 방법 중 최적이고 최소의 비용이 소모될지 결정해야 하는데
대부분의 DBMS에서는 옵티마이저가 이 기능을 담당한다.
- MySQL에서는 EXPLAIN이라는 명령으로 쿼리의 실행 계획을 확인할 수 있다.

------------

## 개요

- 옵티마이저가 만들어 내는 실행 계획을 이해하는 것은 상당히 어려운 부분이지만 실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고
더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.

### 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

- 첫 번째 단계를 SQL 파싱이라고 하며 MySQL 서버의 SQL 파서라는 모듈로 처리한다.
  - SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다.
  - 이 단계에서 SQL 파스 트리가 만들어지는데 MySQL 서버는 SQL 문장 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.
- 두 번째 단계에서는 SQL 파스 트리를 참조하면서 다음과 같은 내용을 처리한다.
  - 불필요한 조건 제거 및 복잡한 연산의 단순화
  - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
  - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
  - 옵티마이저에서 처리
  - 쿼리의 실행 계획이 만들어짐

### 옵티마이저 종류

- 대부분의 DBMS가 선택하고 있는 비용 기반 최적화(Cost-based optimizer, CBO)
  - 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해
  실행 계획별 비용을 산출.
  - 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행
- 예전 초기 버전의 오라클 DBMS에서 사용했던 규칙 기반 최적화(Rule-based optimizer, RBO)
  - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 ㅏㅇ식
  - 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어 냄
  - 사용자의 데이터는 분포도가 매우 다양하기 때문에 오래전부터 많은 DBMS에서 거의 사용되지 않음.

-------------------

## 기본 데이터 처리

### 풀 테이블 스캔과 풀 인덱스 스캔

- MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 테이블 스캔이 더 빠른경우
    - 페이지 1개로 구성된 경우
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- InnoDB는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 최대 64개의 데이터 페이지까지 서서히 증가시키면서 버퍼 풀에 저장해둔다.

### 병렬 처리

- MySQL 8.0에서는 innodb_parallel_read_threads 라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경할 수 있다.
- 서버에 장착된 CPU의 코어 개수를 생각해서 설정해야 한다.

### ORDER BY 처리(Using filesort)

- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.
  - 인덱스 이용
    - 장점
      - INSERT,UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로
      읽기만 하면 되므로 매우 빠르다
    - 단점
      - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
      - 인덱스 때문에 디스크 공간이 더 많이 필요하다.
      - 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.
  - Filesort 이용
    - 장점
      - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다.
      - 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.
    - 단점
      - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.
- 실행 계획의 Extra 칼럼에 Using filesort 메시지가 표시되는지 여부로 판단할 수 있다.

#### 소트 버퍼

- MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.
  - 정렬이 필요한 경우에만 할당
  - 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 공간은 sort_buffer_size라는 시스템 변수값
  - 소트 버퍼 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납됨
- 정렬해야 할 레코드 건수가 소트 버퍼로 할당된 공간보다 크다면 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용함
  - 메모리의 소트 버퍼에서 정렬을 수행, 결과를 임시로 디스크에 기록
  - 다음 레코드를 가져와 다시 정렬해서 반복적으로 임시 저장
  - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 함
  - 이 병합 작업을 멀티 머지(Multi-merge)라고 한다
    - 수행된 멀티 머지 횟수는 Sort_merge_passes 상태 변수에 누적해서 집계됨
- 디스크의 쓰기와 읽기를 유발하여 레코드 건수가 많을수록 반복 작업의 횟수가 많아짐
- 소트 버퍼는 세션 메모리 영역이기 때문에 커넥션이 많으면 많을수록 소트 버퍼로 소비되는 메모리 공간이 커지기 때문에 운영체제는 메모리 부족 현상을 겪을 수도 있음.

#### 정렬 알고리즘

- 정렬을 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 옵티마이저 트레이스 기능으로 확인 가능함

```mysql
SET OPTIMIZER_TRACE="enabled=on",END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

SELECT * FROM employees ORDER BY last_name LIMIT 100000, 1;

SELECT * FROM information_schema.OPTIMIZER_TRACE
```

- 'filesort_summary' 섹션의 'sort_algorithm' 필드에 정렬 알고리즘이 표시되고, "sort_mode"필드에는 
정렬 방식이 표시된다.
- <sort_key, rowid>
  - 정렬 키와 레코드의 로우 아이디만 가져와서 정렬하는 방식
- <sort_key, additional_fields>
  - 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로 레코드의 칼럼들은 고정 사이즈로 메모리 저장
- <sort_key, packed_additional_fields>
  - 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로 레코드 칼럼들은 가변 사이즈로 메모리 저장

#### 정렬 처리 방법

- 쿼리의 ORDER BY가 사용되면 다음 3가지 처리 방법 중 하나로 정렬이 처리된다.(아래로 갈수록 처리 속도가 떨어짐)
  - 인덱스를 사용한 정렬
    - ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인일 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 함
    - WHERE절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 함.
    - B-TREE 계열 인덱스가 아니면 사용할 수 없음
  - 조인에서 드라이빙 테이블만 정렬
    - 조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY 절을 작성해야 함
  - 조인에서 조인 결과를 임시 테이블로 저장 후 정렬