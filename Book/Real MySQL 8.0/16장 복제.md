# 복제

- DB의 중요한 요소 중 두 가지는 확장성과 가용성
  - 대용량 트래픽을 안정적으로 처리하기 위해서는 DB 서버의 확장이 필수
  - 사용자가 안정적인 서비스를 이용할 수 있으려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 뒷받침
- 두 요소를 위해 가장 일반적으로 사용되는 기술이 복제

----------

## 개요

- 복제는 한 서버에서 다른 서버로 데이터가 동기화 되는 것
  - 원본 데이터를 가진 서버: 소스(Source) 서버
  - 복제된 데이터를 가지는 서버: 레플리카(Replica) 서버
- 소스 서버에서 데이터 및 스키마에 대한 변경이 최초로 발생하며, 레플리카 서버에서는 변경 내역을 소스 서버로부터 전달받아
자신이 가지고 있는 데이터에 반영함으로써 동기화 시킴
- 레플리카 서버를 구축하는 목적
  - 소스 서버에 문제가 생겼을 때를 대비
  - 스케일 아웃(Scale-out)
    - 복제를 사용해 DB 서버를 스케일 아웃할 수 있으며 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있음
  - 데이터 백업
    - 동일한 서버 내에서 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용하기 때문에 실행중인 쿼리들이
    영향을 받을 수 있으며, 심각한 경우에는 쿼리의 처리 속도가 느려서 서비스에 장애가 발생할 수 있음.
    - 주로 복제를 사용해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행함
  - 데이터 분석
    - 인사이트를 얻기 위해 분석용 쿼리를 실행하는데 이러한 쿼리들은 무겁고 복잡하여 서버의 리소스를 많이 사용해 장애 유발 가능성이 있음.
    - 복제를 사용해 여분의 레플리카 서버를 구축해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋음
  - 데이터의 지리적 분산
    - DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어남.
    - 사용자에게 빠른 응답 속도를 제공하려면 DB 서버에 대한 레플리카 서버를 새로 구축할 수 있음.

---------

## 복제 아키텍처

- MySQL 서버에서 발생하는 모든 변경 사항은 별도의 로그 파일에 순서대로 기록되는데, 이를 바이너리 로그(Binary Log)라고 한다.
  - 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구조 변경과 계정이나 권한의 변경 정보까지 모두 저장됨
  - 기록된 각 변경 정보들을 이벤트(Event)라고 함
- MySQL의 복제는 바이너리 로그를 기반으로 구현됨
  - 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤
  자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버 간의 데이터 동기화가 이뤄짐
- 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일을 릴레이 로그(Relay Log)라고 함.
- MySQL의 복제는 세 개의 스레드에 의해 작동하는데 하나는 소스 서버에 존재하며 나머지 두 개는 레플리카 서버에 존재한다.
  - 바이너리 로그 덤프 스레드
    - 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 바이너리 로그 정보를 요청한다.
    - 소스 서버에서는 레플리카 서버가 연결될 때 내부적으로 바이너리 로그 덤프 스레드를 생성해서 바이너리 로그의 내용을
    레플리카 서버로 전송한다.
    - 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다.
    - 소스 서버에서 SHOW PROCESSLIST 명령을 통해 확인할 수 있다.
  - 레플리케이션 I/O 스레드
    - 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성하고 복제가 멈추면 I/O 스레드는 종료된다.
    - 소스 서버의 바이너리 로그를 읽어서 파일로 쓰는 역할만 한다.
  - 레플리케이션 SQL 스레드
    - 레플리케이션 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.
- 복제가 시작되면 레플리카 서버는 총 세 가지 유형의 복제 관련 데이터를 생성하고 관리한다.
  - 릴레이 로그
    - 레플리케이션 I/O 스레드에 의해 작성되는 파일로, 소스 서버의 바이너리 로그에서 읽어온 이벤트 정보가 저장된다.
    - 릴레이 로그에 저장된 이벤트들은 레플리케이션 SQL 스레드에 의해 레플리카 서버에 적용된다.
  - 커넥션 메타데이터
    - 레플리케이션 I/O 스레드에서 소스 서버에 연결할 때 사용하는 DB 계정 정보 및 현재 읽고 있는 소스 서버의 바이너리 파일명과
    파일 내 위치 값 등이 담겨 있다.
    - mysql.slave_master_info 테이블에 저장된다.
  - 어플라이어 메타데이터
    - 레플리케이션 SQL 스레드에서 릴레이 로그에 저장된 소스 서버의 이벤트들을 레플리카 서버에 적용하는 컴포넌트를 어플라이어라고 한다.
    - 어플라이어 메타데이터는 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼 있는 릴레이 로그 파일명과 파일 내 위치 정보 등을 담고 있다.
    - mysql.slave_relay_log_info 테이블에 저장된다.

-----------

## 복제 타입

### 바이너리 로그 파일 위치 기반 복제

- MySQL에 복제 기능이 처음 도입됐을 때부터 제공된 방식
- 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치(Offset 또는 Position)fh
개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태
- 복제에 참여한 MySQL 서버들이 모두 고유한 server_id 값을 가지고 있어야 한다.
  - 서버의 시스템 변수 중 하나로 서버마다 원하는 값으로 설정할 수 있으며 기본값은 1
- 바이너리 로그 파일 위치 기반 복제에서는 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 server_id 값과 동일한 server_id 값을 가지는 경우
레플리카 서버에서 해당 이벤트를 적용하지 않고 무시하게 된다.
  - 자신의 서버에서 발생한 이벤트로 간주하기 때문

### 글로벌 트랜잭션 아이디(GTID) 기반 복제

- 바이너리 로그 파일 위치 기반 복제와는 다르게 소스 서버에서 발생한 각 이벤트들이 복제에 참여한 전체 MySQL 서버들에서
고유하도록 각 이벤트에 부여된 식별 값을 글로벌 트랜잭션 아이디라고 한다.

----------

## 복제 데이터 포맷

- 바이너리 로그에 이벤트가 어떤 포맷으로 기록되는지는 복제가 처리되는 과정에도 영향을 준다.
  - 레플리카 서버가 소스 서버의 바이너리 로그 이벤트를 내부적으로 가공하지 않고 가져온 그대로 실행해 자신의 데이터에
  적용하므로
- MySQL에서는 실행된 SQL문을 바이너리 로그에 기록하는 Statement 방식과 변경된 데이터 자체를 기록하는 Row 방식으로 두 종류의
바이너리 로그 포맷을 제공한다.
  - binlog_format 시스템 변수
    - 두 가지 종류 중 하나 혹은 혼합된 형태로 사용 가능

### Statement 기반 바이너리 로그 포맷

- MySQL에 바이너리 로그가 처음 도입됐을 때부터 존재해왔던 포맷
- 이벤트를 발생시긴 SQL문을 바이너리 로그에 기록하는 방식
- 하나의 SQL문은 여러 개의 데이터를 수정할 수 있는데, 이 경우 Row 방식보다 바이너리 로그 파일의
용량이 작아지는 이점이 있다.
- 바이너리 로그는 변경 내역이 전부 저장되는 파일이므로 감사 등의 목적으로도 활용할 수 있는데 SQL 문들을 확인할 수 있어서
감사에 더 용이하다.
- 비확정적(Non-Deterministic)으로 처리될 수 있는 쿼리가 실행된 경우 Statement 포맷에서 복제 시 소스 서버와 레플리카 서버 간에 데이터가 달라질 수 있다는 점이다.
  - DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT 사용
  - SELECT ... FOR UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAIT이나 SKIP LOCKED 옵션 사용
  - LOAD_FILE(), UUID(), UUID_SHORT(), USER(), FOUND_ROWS(), RAND(), VERSION() 등과 같은 함수를 사용하는 쿼리
  - 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저를 사용하는 쿼리
- Row 포맷으로 복제될 때마다 데이터에 락을 더 많이 건다.
- 트랜잭션 격리 수준이 반드시 REPEATABLE-READ 이상이어야 한다.
  - 이하의 격리 수준에서는 하나의 트랜잭션 내에서도 각 쿼리가 실행되는 시점마다 데이터 스냅샷이 달라지는데 이로 인해 복제 시
  소스 서버와 레플리카 서버의 데이터가 일치하지 않게 될 수 있다.

### Row 기반 바이너리 로그 포맷

- 5.1 버전부터 도입된 포맷
- 데이터 변경이 발생했을 때 변경된 값 자체가 바이너리 로그에 기록되는 방식
- 5.7.7 버전부터는 바이너리 로그의 기본 포맷으로 지정
- mysqlbinlog 프로그램을 사용해 SQL 문을 확인할 수 있다.
  - mysqlbinlog -v(--verbose)
    - 소스 서버에서 실행된 SQL 문을 그대로 보고 싶다면 binlog_rows_query_log_events 시스템 변수를 활성화한 후
    mysqlbinlog -vv(--verbose --verbose)
  - Base64 문자열로 인코딩된 변경 데이터를 포함하는데 결과 파일에서 제외하고 싶다면
    - --base64-output=DECODE-ROWS 옵션 함께 사용
- 모든 트랜잭션 격리 수준에 사용 가능함
- 사용자 계정 생성과 권한 부여 및 회수, 테이블과 뷰, 트리거 생성 등과 같은 DDL 문은 전부 Statement 포맷 형태로 바이너리 로그에 기록됨.

### Mixed 포맷

- 두 가지 바이너리 로그 포맷을 혼합
  - binlog_format 시스템 변수를 MIXED 값으로 지정
- 기본적으로 Statement 포맷을 사용하며, 실행된 쿼리와 스토리지 엔진의 종류에 따라 필요시 자동으로 Row 포맷으로 전환해 로그에 기록
- 쿼리의 경우 대부분 Statement 포맷으로 기록되나 실행된 쿼리가 Statement 포맷으로 기록되어 복제됐을 때 문제가 될 가능성이 있는
안전하지 못한 쿼리 형태라면 Row 포맷으로 변환되어 기록됨.
- 각 포맷의 장점만 취해서 사용할 수 있는것 같지만 자동으로 두 포맷을 번갈아 사용하는 것이므로 실제 사용자가 예상했던 것과 다르게 처리될 수 있음.

### Row 포맷의 용량 최적화

- Row 포맷을 사용할지 망설이는 대표적인 이유는 바이너리 로그 파일의 용량이 많이 커질 수 있다는 점

#### 바이너리 로그 Row 이미지

- MySQL에서는 Row 포맷의 바이너리 로그 파일 용량을 최소화하기 위해 저장되는 변경 데이터의 칼럼 구성을 제어하는 binlog_row_image 시스템 변수 제공
- 각 변경 데이터마다 변경 전 레코드와 변경 후 레코드가 함께 저장되는데 binlog_row_image 시스템 변수는 각 변경 전후 레코드들에 대해
테이블의 어떤 칼럼들을 기록할 것인지를 결정
- binlog_row_image 시스템 변수 옵션
  - full(디폴트)
    - 특정 칼럼에서만의 변경 여부와 관계없이 변경이 발생한 레코드의 모든 칼럼들의 값을 바이너리 로그에 기록하는 방식
    - INSERT 문장의 경우 새롭게 INSERT된 레코드의 모든 칼럼들만 바이너리 로그 파일에 기록
    - UPDATE의 경우 변경 전의 레코드와 변경 후의 레코드 모두 전체 칼럼들의 셋으로 바이너리 로그에 기록
    - DELETE 문장의 경우 변경 전의 레코드의 전체 칼럼들만 바이너리 로그에 기록
  - minimal
    - 변경 데이터에 대해 꼭 필요한 칼럼들의 값만 바이너리 로그에 기록
  - noblob
    - full 옵션을 설정한 것과 동일하게 작동하지만 BLOB이나 TEXT 칼럼에 대해 변경이 발생하지 않은 경우
    해당 칼럼들은 바이너리 로그 파일에 기록하지 않음.

#### 바이너리 로그 트랜잭션 압축

- 바이너리 로그 포맷을 Row로 사용 중인 상태에서 이미지를 조정했다고 하더라도 유입되는 DML 쿼리의 양이 많은 DBMS 서버에서는
바이너리 로그 파일의 크기가 커질 수 밖에 없다.
  - 이 경우 디스크 저장 공간과 네트워크 대역폭 사용량 절약을 위해 보관 주기를 더 짧게 설정하고, 원격 스토리지 서버에 저장할 때는
  별도의 툴로 바이너리 로그 파일들을 압축한 뒤 전송할 수 있다.
- 8.0.20 버전에서 Row 포맷으로 기록되는 트랜잭션에 대해 트랜잭션에서 변경한 데이터를 압축해서 바이너리 로그에 기록할 수 있게 하는 기능이 도입됐다.
- 압축된 트랜잭션 데이터는 레플리카 서버로 복제될 때도 압축된 상태를 유지하며, 레플리카 서버의 레플리케이션 I/O 스레드도 압축된 상태 그대로 릴레이 로그에
기록한다.
  - 소스 서버, 레플리카 서버 둘 다 8.0.20 이상 버전을 사용해야 한다.
- binlog_transaction_compression 시스템 변수를 통해 압축 기능을 활성화 할 수 있다.

-----------

## 복제 동기화 방식

- MySQL에서는 소스 서버와 레플리카 서버 간의 복제 동기화에 대해 두 가지 방식을 제공한다.
  - 비동기 복제
  - 반동기 복제

### 비동기 복제

- 소스 서버가 자신과 복제 연결된 레플리카 서버에서 변경 이벤트가 정상적으로 전달되어 적용됐는지를 확인하지 않는 방식
- 소스 서버에서 커밋된 트랜잭션은 바이너리 로그에 기록되며, 레플리카 서버에서는 주기적으로 신규 트랜잭션에 대한 바이너리 로그를 소스 서버에 요청한다.
  - 비동기 방식이기 때문에 실제로 적용됐는지 알지 못한다.
  - 소스 서버에 장애가 발생하면 누락된 트랜잭션이 존재할 수도 있다.
- 레플리카 서버를 소스 서버로 승격시키는 경우 사용자가 직접 누락된 트랜잭션이 있는지 체크해야 한다.
- 동기화 여부를 보장하지 않는다는 것이 가장 큰 단점이지만 트랜잭션 처리에 있어서 좀 더 빠른 성능을 보이고 레플리카 서버에 문제가 생기더라도
소스 서버는 아무런 영향도 받지 않는다는 장점이 있다.
  - 레플리카 서버에 무거운 쿼리가 실행되어 성능 저하가 있다고 하더라도 소스 서버와는 무관한 일이므로 분석 용도 등으로 사용하기에도 적합하다.

### 반동기 복제

- 비동기 복제보다 좀 더 향상된 데이터 무결성을 제공하는 복제 동기화 방식
- 소스 서버는 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 릴레이 로그에 기록 후 응답(ACK)을 보내면 그때 트랜잭션을 완전히 커밋시키고
클라이언트에 결과를 반홚나다.
  - 소스 서버에서 커밋되어 정상적으로 결과가 반환된 모든 트랜잭션들에 대해 적어도 하나의 레플리카 서버에는 해당 트랜잭션들이 전송됐음을 보장
  - 전송됐음을 보장한다는 것이지 실제로 적용되는 것까지 보장한다는 것은 아님
  - 그래서 반동기

-----------

## 복제 토폴로지

### 싱글 레플리카 복제 구성

- 하나의 소스 서버에 하나의 레플리카 서버만 연결돼 있는 복제 형태
- 가장 기본적이며 제일 많이 사용됨
- 애플리케이션 서버는 소스 서버에만 직접적으로 접근해 사용하고 레플리카 서버에는 접근하지 않으며, 레플리카 서버는 소스 서버에서 장애가 발생했을 때 사용될 수
있는 예비 서버 및 데이터 백업 수행을 위한 용도로 사용
  - 서비스와는 연관이 없는 배치 작업이나 어드민 툴에서 사용되는 쿼리들은 레플리카 서버에서 실행되도록 구현해도 무방

### 멀티 레플리카 복제 구성

- 하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태
- 서비스 초기에는 싱글 레플리카 복제 구성으로 MySQL 서버를 구축하나 트래픽이 크게 증가하면 소스 서버 한 대에서만 쿼리 요청을
하기에는 벅찰 수 있는데 대부분의 트래픽은 읽기 요청이 더 많으므로 멀티 레플리카 형태로 복제 구성을 전환해 읽기 요청 처리를 분산시킬 수 있다.

### 체인 복제 구성

- MySQL 복제에서 소스 서버는 레플리카 서버가 요청할 때마다 계속 바이너리 로그를 읽어서 전달해야 하는데 하나의 소스 서버에 연결된 레플리카 서버 수가 많다면
바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수 있다.
- 이럴 때 1:M:M 구조의 체인 복제 구성을 고려해볼 수 있다.

### 듀얼 소스 복제 구성

- 두 개의 MySQL 서버가 서로 소스 서버이자 레플리카 서버로 구성돼 있는 형태
- 두 서버 모두 쓰기가 가능하다는 것이 제일 큰 특징
  - ACTIVE-PASSIVE
    - 하나의 MySQL 서버에서만 쓰기 작업이 수행되는 형태
    - 싱글 레플리카 복제 구성과 동일해 보이지만 다른 예비 서버가 바로 쓰기 작업이 가능한 상태이기 때문에 ACTIVE 서버에서 문제 발생 시
    별도의 설정 변경 없이 전환할 수 있음.
  - ACTIVE-ACTIVE
    - 두 서버 모두에 쓰기 작업을 수행하는 형태로, 지리적으로 매우 떨어진 위치에서 유입되는 쓰기 요청도 원할하게 처리하기 위해
    주로 사용
    - 거리상 떨어져 있기 때문에 서로의 트랜잭션이 전달 완료되어 적용되기 전까지 일관되지 않은 데이터를 가질 수 있음을 유의해야 함
- 듀얼 소스 복제 구성을 사용할 때는 다음과 같은 부분에서 문제가 발생할 수 있으므로 주의해야 함
  - 동일한 데이터를 각 서버에서 변경
    - 동일한 데이터에 대한 변경 트랜잭션이 각 MySQL 서버에 동시점에 유입되는 경우 시점상 나중에 처리된
    트랜잭션의 내용이 최종적으로 반영되는데 예상하지 못한 방향으로 데이터가 처리될 수 있다.
  - 테이블에서 Auto-Increment 키 사용
    - 거의 동일한 시점에 새로운 데이터가 각 MySQL 서버로 유입됐을 때 같은 Auto-Increment 키 값을 갖게 될 수 있다.
    - 반드시 사용하고자 하는 경우에는 Auto-Increment 키 값이 충돌하지 않도록 각 MySQL 서버에서 auto_increment_offset 시스템 변수와
    auto_increment_increment 시스템 변수의 값을 적절히 설정한 후 사용해야 한다.

### 멀티 소스 복제 구성

- 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태
- 5.7.6 버전에 처음 도입
- 멀티 소스 복제 구성은 다음과 같은 목적으로 사용된다.
  - 여러 MySQL 서버에 존재하는 각기 다른 데이터를 하나의 MySQL 서버로 통합
  - 여러 MySQL 서버에 샤딩돼 있는 테이블의 데이터를 하나의 테이블로 통합
  - 여러 MySQL 서버의 데이터들을 모아 하나의 MySQL 서버에서 백업을 수행
- 