# 복제

- DB의 중요한 요소 중 두 가지는 확장성과 가용성
  - 대용량 트래픽을 안정적으로 처리하기 위해서는 DB 서버의 확장이 필수
  - 사용자가 안정적인 서비스를 이용할 수 있으려면 DBMS 서버를 포함한 하위 시스템들의 가용성이 뒷받침
- 두 요소를 위해 가장 일반적으로 사용되는 기술이 복제

----------

## 개요

- 복제는 한 서버에서 다른 서버로 데이터가 동기화 되는 것
  - 원본 데이터를 가진 서버: 소스(Source) 서버
  - 복제된 데이터를 가지는 서버: 레플리카(Replica) 서버
- 소스 서버에서 데이터 및 스키마에 대한 변경이 최초로 발생하며, 레플리카 서버에서는 변경 내역을 소스 서버로부터 전달받아
자신이 가지고 있는 데이터에 반영함으로써 동기화 시킴
- 레플리카 서버를 구축하는 목적
  - 소스 서버에 문제가 생겼을 때를 대비
  - 스케일 아웃(Scale-out)
    - 복제를 사용해 DB 서버를 스케일 아웃할 수 있으며 이를 통해 서비스를 좀 더 안정적으로 운영할 수 있음
  - 데이터 백업
    - 동일한 서버 내에서 백업이 실행되는 경우 백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용하기 때문에 실행중인 쿼리들이
    영향을 받을 수 있으며, 심각한 경우에는 쿼리의 처리 속도가 느려서 서비스에 장애가 발생할 수 있음.
    - 주로 복제를 사용해 레플리카 서버를 구축하고, 데이터 백업은 레플리카 서버에서 실행함
  - 데이터 분석
    - 인사이트를 얻기 위해 분석용 쿼리를 실행하는데 이러한 쿼리들은 무겁고 복잡하여 서버의 리소스를 많이 사용해 장애 유발 가능성이 있음.
    - 복제를 사용해 여분의 레플리카 서버를 구축해 분석용 쿼리만 전용으로 실행될 수 있는 환경을 만드는 것이 좋음
  - 데이터의 지리적 분산
    - DB 서버와 애플리케이션 서버가 서로 떨어져 있는 경우 두 서버 간의 통신 시간은 떨어진 거리만큼 비례해서 늘어남.
    - 사용자에게 빠른 응답 속도를 제공하려면 DB 서버에 대한 레플리카 서버를 새로 구축할 수 있음.

---------

## 복제 아키텍처

- MySQL 서버에서 발생하는 모든 변경 사항은 별도의 로그 파일에 순서대로 기록되는데, 이를 바이너리 로그(Binary Log)라고 한다.
  - 데이터의 변경 내역뿐만 아니라 데이터베이스나 테이블의 구조 변경과 계정이나 권한의 변경 정보까지 모두 저장됨
  - 기록된 각 변경 정보들을 이벤트(Event)라고 함
- MySQL의 복제는 바이너리 로그를 기반으로 구현됨
  - 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤
  자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버 간의 데이터 동기화가 이뤄짐
- 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일을 릴레이 로그(Relay Log)라고 함.
- MySQL의 복제는 세 개의 스레드에 의해 작동하는데 하나는 소스 서버에 존재하며 나머지 두 개는 레플리카 서버에 존재한다.
  - 바이너리 로그 덤프 스레드
    - 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 바이너리 로그 정보를 요청한다.
    - 소스 서버에서는 레플리카 서버가 연결될 때 내부적으로 바이너리 로그 덤프 스레드를 생성해서 바이너리 로그의 내용을
    레플리카 서버로 전송한다.
    - 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다.
    - 소스 서버에서 SHOW PROCESSLIST 명령을 통해 확인할 수 있다.
  - 레플리케이션 I/O 스레드
    - 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성하고 복제가 멈추면 I/O 스레드는 종료된다.
    - 소스 서버의 바이너리 로그를 읽어서 파일로 쓰는 역할만 한다.
  - 레플리케이션 SQL 스레드
    - 레플리케이션 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행한다.
- 복제가 시작되면 레플리카 서버는 총 세 가지 유형의 복제 관련 데이터를 생성하고 관리한다.
  - 릴레이 로그
    - 레플리케이션 I/O 스레드에 의해 작성되는 파일로, 소스 서버의 바이너리 로그에서 읽어온 이벤트 정보가 저장된다.
    - 릴레이 로그에 저장된 이벤트들은 레플리케이션 SQL 스레드에 의해 레플리카 서버에 적용된다.
  - 커넥션 메타데이터
    - 레플리케이션 I/O 스레드에서 소스 서버에 연결할 때 사용하는 DB 계정 정보 및 현재 읽고 있는 소스 서버의 바이너리 파일명과
    파일 내 위치 값 등이 담겨 있다.
    - mysql.slave_master_info 테이블에 저장된다.
  - 어플라이어 메타데이터
    - 레플리케이션 SQL 스레드에서 릴레이 로그에 저장된 소스 서버의 이벤트들을 레플리카 서버에 적용하는 컴포넌트를 어플라이어라고 한다.
    - 어플라이어 메타데이터는 최근 적용된 이벤트에 대해 해당 이벤트가 저장돼 있는 릴레이 로그 파일명과 파일 내 위치 정보 등을 담고 있다.
    - mysql.slave_relay_log_info 테이블에 저장된다.

-----------

## 복제 타입

### 바이너리 로그 파일 위치 기반 복제

- MySQL에 복제 기능이 처음 도입됐을 때부터 제공된 방식
- 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치(Offset 또는 Position)fh
개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 형태
- 복제에 참여한 MySQL 서버들이 모두 고유한 server_id 값을 가지고 있어야 한다.
  - 서버의 시스템 변수 중 하나로 서버마다 원하는 값으로 설정할 수 있으며 기본값은 1
- 바이너리 로그 파일 위치 기반 복제에서는 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버에 설정된 server_id 값과 동일한 server_id 값을 가지는 경우
레플리카 서버에서 해당 이벤트를 적용하지 않고 무시하게 된다.
  - 자신의 서버에서 발생한 이벤트로 간주하기 때문

### 글로벌 트랜잭션 아이디(GTID) 기반 복제

- 바이너리 로그 파일 위치 기반 복제와는 다르게 소스 서버에서 발생한 각 이벤트들이 복제에 참여한 전체 MySQL 서버들에서
고유하도록 각 이벤트에 부여된 식별 값을 글로벌 트랜잭션 아이디라고 한다.

----------

## 복제 데이터 포맷

- 바이너리 로그에 이벤트가 어떤 포맷으로 기록되는지는 복제가 처리되는 과정에도 영향을 준다.
  - 레플리카 서버가 소스 서버의 바이너리 로그 이벤트를 내부적으로 가공하지 않고 가져온 그대로 실행해 자신의 데이터에
  적용하므로
- MySQL에서는 실행된 SQL문을 바이너리 로그에 기록하는 Statement 방식과 변경된 데이터 자체를 기록하는 Row 방식으로 두 종류의
바이너리 로그 포맷을 제공한다.
  - binlog_format 시스템 변수
    - 두 가지 종류 중 하나 혹은 혼합된 형태로 사용 가능

### Statement 기반 바이너리 로그 포맷

- MySQL에 바이너리 로그가 처음 도입됐을 때부터 존재해왔던 포맷
- 이벤트를 발생시긴 SQL문을 바이너리 로그에 기록하는 방식
- 하나의 SQL문은 여러 개의 데이터를 수정할 수 있는데, 이 경우 Row 방식보다 바이너리 로그 파일의
용량이 작아지는 이점이 있다.
- 바이너리 로그는 변경 내역이 전부 저장되는 파일이므로 감사 등의 목적으로도 활용할 수 있는데 SQL 문들을 확인할 수 있어서
감사에 더 용이하다.
- 비확정적(Non-Deterministic)으로 처리될 수 있는 쿼리가 실행된 경우 Statement 포맷에서 복제 시 소스 서버와 레플리카 서버 간에 데이터가 달라질 수 있다는 점이다.
  - DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT 사용
  - SELECT ... FOR UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAIT이나 SKIP LOCKED 옵션 사용
  - LOAD_FILE(), UUID(), UUID_SHORT(), USER(), FOUND_ROWS(), RAND(), VERSION() 등과 같은 함수를 사용하는 쿼리
  - 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저를 사용하는 쿼리
- Row 포맷으로 복제될 때마다 데이터에 락을 더 많이 건다.
- 트랜잭션 격리 수준이 반드시 REPEATABLE-READ 이상이어야 한다.
  - 이하의 격리 수준에서는 하나의 트랜잭션 내에서도 각 쿼리가 실행되는 시점마다 데이터 스냅샷이 달라지는데 이로 인해 복제 시
  소스 서버와 레플리카 서버의 데이터가 일치하지 않게 될 수 있다.

### Row 기반 바이너리 로그 포맷

- 5.1 버전부터 도입된 포맷
- 데이터 변경이 발생했을 때 변경된 값 자체가 바이너리 로그에 기록되는 방식
- 5.7.7 버전부터는 바이너리 로그의 기본 포맷으로 지정
- mysqlbinlog 프로그램을 사용해 SQL 문을 확인할 수 있다.
  - mysqlbinlog -v(--verbose)
    - 소스 서버에서 실행된 SQL 문을 그대로 보고 싶다면 binlog_rows_query_log_events 시스템 변수를 활성화한 후
    mysqlbinlog -vv(--verbose --verbose)
  - Base64 문자열로 인코딩된 변경 데이터를 포함하는데 결과 파일에서 제외하고 싶다면
    - --base64-output=DECODE-ROWS 옵션 함께 사용
- 모든 트랜잭션 격리 수준에 사용 가능함
- 사용자 계정 생성과 권한 부여 및 회수, 테이블과 뷰, 트리거 생성 등과 같은 DDL 문은 전부 Statement 포맷 형태로 바이너리 로그에 기록됨.

### Mixed 포맷

- 두 가지 바이너리 로그 포맷을 혼합
  - binlog_format 시스템 변수를 MIXED 값으로 지정
- 기본적으로 Statement 포맷을 사용하며, 실행된 쿼리와 스토리지 엔진의 종류에 따라 필요시 자동으로 Row 포맷으로 전환해 로그에 기록
- 쿼리의 경우 대부분 Statement 포맷으로 기록되나 실행된 쿼리가 Statement 포맷으로 기록되어 복제됐을 때 문제가 될 가능성이 있는
안전하지 못한 쿼리 형태라면 Row 포맷으로 변환되어 기록됨.
- 각 포맷의 장점만 취해서 사용할 수 있는것 같지만 자동으로 두 포맷을 번갈아 사용하는 것이므로 실제 사용자가 예상했던 것과 다르게 처리될 수 있음.

### Row 포맷의 용량 최적화

- Row 포맷을 사용할지 망설이는 대표적인 이유는 바이너리 로그 파일의 용량이 많이 커질 수 있다는 점

#### 바이너리 로그 Row 이미지

- MySQL에서는 Row 포맷의 바이너리 로그 파일 용량을 최소화하기 위해 저장되는 변경 데이터의 칼럼 구성을 제어하는 binlog_row_image 시스템 변수 제공
- 각 변경 데이터마다 변경 전 레코드와 변경 후 레코드가 함께 저장되는데 binlog_row_image 시스템 변수는 각 변경 전후 레코드들에 대해
테이블의 어떤 칼럼들을 기록할 것인지를 결정
- binlog_row_image 시스템 변수 옵션
  - full(디폴트)
    - 특정 칼럼에서만의 변경 여부와 관계없이 변경이 발생한 레코드의 모든 칼럼들의 값을 바이너리 로그에 기록하는 방식
    - INSERT 문장의 경우 새롭게 INSERT된 레코드의 모든 칼럼들만 바이너리 로그 파일에 기록
    - UPDATE의 경우 변경 전의 레코드와 변경 후의 레코드 모두 전체 칼럼들의 셋으로 바이너리 로그에 기록
    - DELETE 문장의 경우 변경 전의 레코드의 전체 칼럼들만 바이너리 로그에 기록
  - minimal
    - 변경 데이터에 대해 꼭 필요한 칼럼들의 값만 바이너리 로그에 기록
  - noblob
    - full 옵션을 설정한 것과 동일하게 작동하지만 BLOB이나 TEXT 칼럼에 대해 변경이 발생하지 않은 경우
    해당 칼럼들은 바이너리 로그 파일에 기록하지 않음.
- 