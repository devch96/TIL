# 쿼리 작성 및 최적화

- 데이터베이스나 테이블의 구조를 변경하기 위한 문장을 DDL(Data Definition Language)라고 한다.
- 테이블의 데이터를 조작(읽고, 쓰기)하기 위한 문장을 DML(Data Manipulation Language)라고 한다.
- 애플리케이션에서 데이터를 저장 또는 조회하기 위해 데이터베이스와 통신할 때 데이터베이스 서버로 전달되는 것은 SQL 뿐이다.
- SQL은 어떠한(What) 데이터를 요청하기 위한 언어이지, 어떻게(How) 데이터를 읽을지를 표현하는 언어는 아니다.
  - 쿼리가 빠르게 수행되게 하려면 데이터베이스 서버에서 쿼리가 어떻게 요청을 처리할지 예측할 수 있어야 한다.
- 애플리케이션 코드를 튜닝해서 성능을 2배 개선한다는 것은 쉽지 않지만 DBMS에서 몇십 배에서 몇백 배의 성능 향상이 이뤄지는 것은 흔한일이다.

--------------

## 쿼리 작성과 연관된 시스템 변수

### SQL 모드

- MySQL 서버의 sql_mode라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있다.
  - STRICT_ALL_TABLES & STRICT_TRANS_TABLES
    - INSERT나 UPDATE 문장으로 데이터를 변경하는 경우 칼럼의 타입과 저장되는 값의 타입이 다를 때 자동으로 타입 변경을 수행한다.
  - ANSI_QUOTES
    - 문자열 값(리터럴)을 표현하기 위해 홑따옴표와 쌍따옴표를 동시에 사용할 수 있다.
      - 오라클은 홑따옴표를 문자열 값, 쌍따옴표는 칼럼명이나 테이블명
    - sql_mode 시스템 변수에 이 설정을 하면 홑따옴표만 문자열 값 표기로 사용할 수 있고, 쌍따옴표는 칼럼명이나 테이블명과 같은
    식별자를 표기하는 데만 사용할 수 있다.
  - ONLY_FULL_GROUP_BY
    - MySQL 쿼리에서는 GROUP BY 절에 포함되지 않은 칼럼이더라도 집합 함수의 사용 없이 그대로 SELECT 절이나 HAVING 절에 사용할 수 있다.
    - 하지만 이 옵션을 설정하면 GROUP BY 절이 사용된 문장의 SELECT 절에는 GROUPB BY 절에 명시된 칼럼과 집계 함수만 사용할 수 있다.
    - MySQL 8.0 부터는 기본 값이다.
  - PIPE_AS_CONAT
    - MySQL에서 ||는 OR 연산자와 같은 의미로 사용되지만 이 옵션을 사용하면 문자열 연결 연산자로 사용할 수 있다.
  - PAD_CHAR_TO_FULL_LENGTH
    - MySQL에서는 CHAR 타입이라고 하더라도 VARCHAR와 같이 유효 문자열 뒤의 공백 문자는 제거되어 반환한다.
    - 이 옵션을 설정하면 뒤쪽의 공백이 제거되지 않고 반환된다.
  - NO_BACKSLASH_ESCAPES
    - 역슬래시를 문자의 이스케이프 용도로 사용하지 못한다.
  - IGNORE_SPACE
    - MySQL에서 스토어드 프로시저나 함수의 이름 뒤에 공백이 있으면 에러가 출력될 수도 있다.
    - MySQL에서는 스토어드 프로시저나 함수명과 괄호 사이에 있는 공백까지도 슽토어드 프로시저나 함수의 이름으로 간주하는 것이 기본 모드이고, 이 
    옵션을 설정하면 프로시저나 함수명과 괄호 사이의 공백은 무시한다.
    - 내장 함수에만 적용되며, 이 옵션이 활성화되면 내장 함수는 모두 예약어로 간주되어 테이블이나 칼럼의 이름으로 사용될 수 없다.
  - REAL_AS_FLOAT
    - 부동 소수점 타입은 FLOAT과 DOUBLE이 지원되는데 REAL 타입은 DOUBLE 타입의 동의어로 사용된다.
    - 이 옵션을 설정하면 REAL 타입이 FLOAT 타입의 동의어로 바뀐다.
  - NO_ZERO_IN_DATE & NO_ZERO_DATE
    - 이 두 옵션을 활성화하면 DATE 또는 DATETIME 타입의 칼럼에 00-00 과 같은 잘못된 날짜를 저장하는 것이 불가능해진다.
      - 실제 존재하지 않는 날짜를 저장 못하게 하려면 설정
    - ANSI
      - 여러가지 옵션을 조합해서 MySQL 서버가 최대한 SQL 표준에 맞게 동작하도록 만든다
    - TRADITIONAL
      - 엄격한 방법으로 SQL의 작동을 제어한다
      - STRICT_TRANS_TABLES, STRICT_ALL_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_ENGINE_SUBSITUTION
      의 조합으로 구성된 모드이다.

### 영문 대소문자 구분

- MySQL 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다.
  - 윈도우에 설치된 MySQL에서는 대소문자를 구분하지 않지만 유닉스 계열의 운영체제에서는 대소문자를 구분한다.
- MySQL 서버의 설정 파일에 lower_case_table_names 시스템 변수를 설정하면 운영체제와 관계없이 대소문자 구분의 영향을 받지 않게 한다.
- 설정 자체를 떠나서 가능하면 초기 DB나 테이블을 생성할 때 대문자 또는 소문자만으로 통일해서 사용하는 편이 좋다

### MySQL 예약어

- 생성하는 데이터베이스나 테이블, 칼럼의 이름을 예약어와 같은 키워드로 생성하면 칼럼이나 테이블을 SQL에서 사용하기 위해 백틱이나 쌍따옴표로 감싸야 한다.
  - SQL을 작성하는 개발자에게 문법이 틀리다라는 에러만 출력하므로 찾기 어려운 버그의 원인이 될 수 있다.
  - 예약어를 사용하지 말자

-------------

## MySQL 연산자와 내장 함수

- MySQL에서는 ANSI 표준 형태가 아닌 연산자가 많이 있는데 SQL의 가독성을 높이기위해 ANSI 표준 형태의 연산자를 사용하는 것을 권장한다.

### 리터럴 표기법 문자열

#### 문자열

- SQL 표준에서 문자열은 항상 홑따옴표(')를 사용해 표기하지만 MySQL에서는 쌍따옴표를 사용해 문자열을 표기할 수 있다.
- SQL 표준에서는 문자열 값에 홑따옴표가 포함돼 있을 때 홑따옴표를 두 번 연속해서 입력하면 되지만 MySQL에서는
문자열 값이 쌍따옴표를 가지고 있을 때는 쌍따옴표를 두 번 연속해서 사용할 수 있다.
- SQL에서 사용되는 식별자(테이블이나 칼럼명 등)가 키워드와 충돌할 때 오라클이나 PostgreSQL에서는 쌍따옴표나 대괄호로 감싸서 충돌을 막지만
MySQL에서는 백틱(`)으로 감싸서 사용한다.
  - MySQL 서버의 sql_mode 시스템 변수값에 ANSI_QUOTES를 설정하면 리터럴 표기에 
  쌍따옴표를 사용 못하고 테이블명이나 칼럼명의 충돌을 피하려면 백틱이 아니라 쌍따옴표로 감싸야 한다.

#### 숫자

- 숫자 값을 상수로 SQL에 사용할 때는 따옴표 없이 숫자 값을 입력하면 된다.
- 문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 칼럼이면 MySQL 서버가 문자열 값을 숫자 값으로 자동 변환한다.

```mysql
SELECT * FROM tab_test WHERE number_column='10001';
SELECT * FROM tab_test WHERE string_column=10001;
```
- MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행한다.
- 첫 번째 쿼리는 주어진 상숫값을 숫자로 변환한다.
  - 상숫값 하나만 변환하므로 성능과 관련된 문제가 발생하지 않는다.
- 두 번째 쿼리는 주어진 상숫값이 숫자 값인데, 비교되는 칼럼은 문자열 칼럼이다.
  - MySQL은 문자열 칼럼을 숫자로 변환해서 비교한다.
  - string_column에 있는 모든 문자열을 숫자로 변환해서 비교를 수행하므로 문제가 발생한다.

#### 날짜

- 다른 DBMS에서 날짜 타입을 비교하거나 INSERT 하려면 문자열을 DATE 타입으로 변환하는 코드가 필요하지만 MySQL에서는 정해진 형태의 날짜 포맷으로 표기하면
자동으로 DATE나 DATETIME 값으로 변환한다.
- 날짜 타입의 칼럼과 문자열 값을 비교하는 경우 MySQL 서버는 문자열 값을 DATE 타입으로 변환해서 비교한다.

#### 불리언

- BOOL이나 BOOLEAN 타입은 TINYINT 타입에 대한 동의어다.
- FALSE는 0, TRUE는 1을 의미한다.
- 불리언 타입은 ENUM 타입으로 관리하는 것이 좀 더 명확하고 실수할 가능성도 줄일 수 있다.

### MySQL 연산자

#### 동등(Equal) 비교(=, <=>) 

- 동등 비교는 다른 DBMS와 마찬가지로 = 를 사용한다.
- MySQL은 <=> 연산자도 제공한다.
  - =와 같으며 NULL 값에 대한 비교까지 수행한다.
  - NULL-Safe 비교 연산자
  - 양쪽 비교 대상 모두 NULL이라면 TRUE를 반환하고, 한쪽만 NULL이라면 FALSE를 반환한다.
  - NULL을 하나의 값으로 인식하고 비굫나ㅡㄴ 방법

#### 부정(Not-Equal) 비교(<>, !=)

- 어느 쪽을 사용하든 문제가 되지 않지만 혼용되면 가독성이 떨어지므로 통일해서 사용하는 방법을 권장한다.

#### NOT 연산자(!)

- TRUE 또는 FALSE 연산의 결과를 반대로(부정) 만드는 연산자로 "NOT"을 사용한다.
- !도 사용할 수 있다.

#### AND(&&)와 OR(||) 연산자

- MySQL에서는 AND와 OR 뿐만 아니라 &&와 ||의 사용도 허용한다.
- SQL의 가독성을 높이기 위해 다른 용도로 사용될 수 있는 && 연산자와 || 연산자는 사용을 자제하는 것이 좋다.

#### 나누기(/, DIV)와 나머지(%, MOD) 연산자

- 나누기 연산자는 일반적으로 "/" 연산자를 사용한다.
  - 나눈 몫의 정수 부분만 가져오려면 DIV 연산자 사용
- 나눈 결과 몫이 아닌 나머지는 "%" 또는 MOD 연산자를 사용한다.

#### REGEXP 연산자

- 문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자, RLIKE와 같다.
- REGEXP 연산자는 좌측에 비교 대상 문자열 값 또는 칼럼, 우측에 정규식을 사용하면 된다.

#### LIKE 연산자

- REGEXP 보다는 단순한 연산자이지만 더 많이 사용한다.
  - REGEXP는 인덱스를 사용하지 못하지만 LIKE는 사용가능하다.
- LIKE에서 사용할 수 있는 와일드카드 문자는 "%"와 "_"가 전부다.
  - %: 0 또는 1개 이상의 모든 문자에 일치
  - _: 정확히 1개의 문자에 일치
- LIKE 연산자는 와일드카드 문자가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔을 사용할 수 있지만 앞에 있다면 사용할 수 없다.

#### BETWEEN 연산자

- 크거나 같다와 작거나 같다 두개의 연산자를 하나로 합친 연산자이다.
- 다른 비교 조건과 결합해 하나의 인덱스를 사용할 때 주의해야 할 점이 있다.

```mysql
SELECT * FROM dept_emp WHERE dept_no='d003' AND emp_no=10001;
SELECT * FROM dept_emp WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no=10001;
SELECT * FROM dept_emp WHERE dept_no IN ('d003','d004','d005') AND emp_no=10001;
```

- dept_emp 테이블에는 (dept_no, emp_no) 칼럼으로 구성된 프라이머리 키가 존재
  - 첫 번째 쿼리는 dept_no와 emp_no 조건 모두 인덱스를 이용해 범위를 줄여주는 방법으로 사용할 수 있음.
  - 두 번째 쿼리는 dept_no가 d003 부터 d005 까지 다 봐야하기 때문에 emp_no=10001 조건은 비교 범위를 줄이는 역할을 하지 못함.
- BETWEEN은 크다 작다 비교를 하나로 묶어둔 것이고, IN 연산자는 동등 비교(=)와 비슷하기에 두 번째 쿼리는 인덱스를 다 읽지만,
세 번째 쿼리는 emp_no=10001 조건도 작업 범위를 줄이는 용도로 인덱스를 이용할 수 있다.

#### IN 연산자

- IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자
  - 범위로 검색하는 것이 아니기 때문에 일반적으로 빠르게 처리됨.
  - 상수가 사용된 경우: IN(?,?,?)
  - 서브쿼리가 사용된 경우: IN(SELECT .. FROM ..)
- IN 절에 상숫값이 단순 스칼라값이 아니라 튜플이 사용되어도 8.0 버전부터는 인덱스를 최적으로 사용할 수 있다.
- NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시되는데 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없기 때문이다.
  - 프라이머리 키와 비교될 때 가끔 쿼리 실행계획에 레인지 스캔이 표시되는 경우가 있는데 InnoDB 테이블에서 프라이머리 키가 클러스터링 키이기 때문일 뿐
  실제 IN과 같이 효율적으로 실행된다는 것을 의미하진 않는다.

### MySQL 내장 함수

- MySQL 함수는 기본으로 제공하는 내장 함수와 사용자가 직접 작성해서 추가할 수 있는 사용자 정의 함수(UDF, User Defined Function)으로 구분된다.
  - 사용자 정의 함수는 스토어드 프로그램으로 작성되는 프로시저나 스토어드 함수와는 다르다

#### NULL 값 비교 및 대체(IFNULL, ISNULL)

- IFNULL()은 칼럼이나 표현식의 값이 NULL인지 비교하고, NULL이면 다른 값으로 대체하는 용도로 사용한다.
  - 첫 번째 인자는 NULL인지 아닌지 비교하려는 칼럼이나 표현식
  - 두 번째 인자로는 첫 번째 인자의 값이 NULL일 경우 대체할 값이나 칼럼을 설정
- ISNULL()은 전달한 표현식이나 칼럼의 값이 NULL인지 아닌지 비교하는 함수

#### 현재 시각 조회(NOW, SYSDATE)

- 둘 다 현재의 시간을 반환하는 함수이지만 차이가 있다.
- 하나의 SQL에서 모든 NOW() 함수는 같은 값을 가지지만 SYSDATE() 함수는 호출되는 시점에 따라 결괏값이 달라진다.
- 따라서 SYSDATE() 함수는 두 가지 큰 잠재적인 문제가 있다.
  - SYSDATE() 함수가 사용된 SQL은 레플리카 서버에서 안정적으로 복제되지 못한다
  - SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못한다.
    - NOW()는 쿼리가 실행되는 시점에서 실행되고 값을 할당받아서 그 값을 SQL 문장의 모든 부분에서 사용하기 때문에
    인덱스를 스캔할 때도 유지되므로 비교 조건이 된다.
    - SYSDATE()는 상수가 아니기 때문에 매번 비교되는 레코드마다 함수를 실행해야 하기에 인덱스에 사용하지 못한다.
- MySQL 설정 파일에 sysdate-is-now 시스템 변수를 넣으면 SYSDATE() 함수도 NOW() 함수와 같이 함수의 호출 시점에 관계없이 하나의 SQL에서 같은 값을
갖게 된다.

#### 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)

- DATETIME 타입의 칼럼이나 값을 원하는 형태의 문자열로 변환해야 할 때는 DATE_FORMAT() 함수를 이용하면 된다.
  - %Y: 4자리 연도
  - %m: 2자리 숫자 표시의 월(01~12)
  - %d: 2자리 숫자 표시의 일자(01~31)
  - %H: 2자리 숫자 표시의 시(00~23)
  - %i: 2자리 숫자 표시의 분(00~59)
  - %s: 2자리 숫자 표시의 초(00~59)
- SQL에서 표준 형태(년-월-일 시:분:초)로 입력된 문자열은 필요한 경우 자동으로 DATETIME 타입으로 변환되어 처리된다.
- MySQL 서버가 문자열에 사용된 날짜 타입의 포맷을 알 수 없는 경우엔 명시적으로 날짜 타입으로 변환해야 하는데 그때 사용하는 함수가
STR_TO_DATE()이다.
  - 날짜의 각 부분을 명시하는 지정자는 DATE_FORMAT() 함수에서 사용했던 지정자와 동일하게 사용하면 된다.

#### 날짜와 시간의 연산(DATE_ADD, DATE_SUB)

- DATE_ADD() 함수로 더하거나 빼는 처리를 모두 할 수 있기 때문에 DATE_SUB()는 크게 필요하지 않다.
- 두 함수 모두 두 개의 인자를 필요로 하는데, 첫 번째 인자는 연산을 수행할 날짜이며 두 번째 인자는 더하거나 빼고자하는 월의 수나 일자의 수 등을 입력하면 된다.
  - 두 번째 인자는 INTERVAL n [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND,...] 형태로 입력해야 한다.
    - n은 더하거나 뺴고자 하는 차이 값, 그 뒤에 명시되는 단위

```mysql
SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS tomorrow;
SELECT DATE_ADD(NOW(), INTERVAL -1 DAY) AS yesterday;
```

#### 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)

- UNIX_TIMESTAMP() 함수는 '1970-01-01 00:00:00'으로부터 경과된 초의 수를 반환하는 함수이다.
  - 함수에 인자가 없으면 현재 날짜와 시간의 타임스탬프 값을, 인자로 특정 날짜를 전달하면 그 날짜의 타임스탬프를 반환
- FROM_UNIXTIME() 함수는 인자로 전달한 타임스탬프 값을 DATETIME 타입으로 변환하는 함수다.
- MySQL의 TIMESTAMP 타입은 4바이트 숫자 타입으로 저장되기 때문에 실제로 가질 수 있는 값의 범위는
'1970-01-01 00:00:01' ~ '2038-01-09 03:14:07' 까지의 날짜 값만 가능하다.

#### 문자열 처리(RPAD, LPAD/ RTRIM, LTRIM, TRIM)

- 