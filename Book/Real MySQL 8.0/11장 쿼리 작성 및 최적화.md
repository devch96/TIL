# 쿼리 작성 및 최적화

- 데이터베이스나 테이블의 구조를 변경하기 위한 문장을 DDL(Data Definition Language)라고 한다.
- 테이블의 데이터를 조작(읽고, 쓰기)하기 위한 문장을 DML(Data Manipulation Language)라고 한다.
- 애플리케이션에서 데이터를 저장 또는 조회하기 위해 데이터베이스와 통신할 때 데이터베이스 서버로 전달되는 것은 SQL 뿐이다.
- SQL은 어떠한(What) 데이터를 요청하기 위한 언어이지, 어떻게(How) 데이터를 읽을지를 표현하는 언어는 아니다.
  - 쿼리가 빠르게 수행되게 하려면 데이터베이스 서버에서 쿼리가 어떻게 요청을 처리할지 예측할 수 있어야 한다.
- 애플리케이션 코드를 튜닝해서 성능을 2배 개선한다는 것은 쉽지 않지만 DBMS에서 몇십 배에서 몇백 배의 성능 향상이 이뤄지는 것은 흔한일이다.

--------------

## 쿼리 작성과 연관된 시스템 변수

### SQL 모드

- MySQL 서버의 sql_mode라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있다.
  - STRICT_ALL_TABLES & STRICT_TRANS_TABLES
    - INSERT나 UPDATE 문장으로 데이터를 변경하는 경우 칼럼의 타입과 저장되는 값의 타입이 다를 때 자동으로 타입 변경을 수행한다.
  - ANSI_QUOTES
    - 문자열 값(리터럴)을 표현하기 위해 홑따옴표와 쌍따옴표를 동시에 사용할 수 있다.
      - 오라클은 홑따옴표를 문자열 값, 쌍따옴표는 칼럼명이나 테이블명
    - sql_mode 시스템 변수에 이 설정을 하면 홑따옴표만 문자열 값 표기로 사용할 수 있고, 쌍따옴표는 칼럼명이나 테이블명과 같은
    식별자를 표기하는 데만 사용할 수 있다.
  - ONLY_FULL_GROUP_BY
    - MySQL 쿼리에서는 GROUP BY 절에 포함되지 않은 칼럼이더라도 집합 함수의 사용 없이 그대로 SELECT 절이나 HAVING 절에 사용할 수 있다.
    - 하지만 이 옵션을 설정하면 GROUP BY 절이 사용된 문장의 SELECT 절에는 GROUPB BY 절에 명시된 칼럼과 집계 함수만 사용할 수 있다.
    - MySQL 8.0 부터는 기본 값이다.
  - PIPE_AS_CONAT
    - MySQL에서 ||는 OR 연산자와 같은 의미로 사용되지만 이 옵션을 사용하면 문자열 연결 연산자로 사용할 수 있다.
  - PAD_CHAR_TO_FULL_LENGTH
    - MySQL에서는 CHAR 타입이라고 하더라도 VARCHAR와 같이 유효 문자열 뒤의 공백 문자는 제거되어 반환한다.
    - 이 옵션을 설정하면 뒤쪽의 공백이 제거되지 않고 반환된다.
  - NO_BACKSLASH_ESCAPES
    - 역슬래시를 문자의 이스케이프 용도로 사용하지 못한다.
  - IGNORE_SPACE
    - MySQL에서 스토어드 프로시저나 함수의 이름 뒤에 공백이 있으면 에러가 출력될 수도 있다.
    - MySQL에서는 스토어드 프로시저나 함수명과 괄호 사이에 있는 공백까지도 슽토어드 프로시저나 함수의 이름으로 간주하는 것이 기본 모드이고, 이 
    옵션을 설정하면 프로시저나 함수명과 괄호 사이의 공백은 무시한다.
    - 내장 함수에만 적용되며, 이 옵션이 활성화되면 내장 함수는 모두 예약어로 간주되어 테이블이나 칼럼의 이름으로 사용될 수 없다.
  - REAL_AS_FLOAT
    - 부동 소수점 타입은 FLOAT과 DOUBLE이 지원되는데 REAL 타입은 DOUBLE 타입의 동의어로 사용된다.
    - 이 옵션을 설정하면 REAL 타입이 FLOAT 타입의 동의어로 바뀐다.
  - NO_ZERO_IN_DATE & NO_ZERO_DATE
    - 이 두 옵션을 활성화하면 DATE 또는 DATETIME 타입의 칼럼에 00-00 과 같은 잘못된 날짜를 저장하는 것이 불가능해진다.
      - 실제 존재하지 않는 날짜를 저장 못하게 하려면 설정
    - ANSI
      - 여러가지 옵션을 조합해서 MySQL 서버가 최대한 SQL 표준에 맞게 동작하도록 만든다
    - TRADITIONAL
      - 엄격한 방법으로 SQL의 작동을 제어한다
      - STRICT_TRANS_TABLES, STRICT_ALL_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_ENGINE_SUBSITUTION
      의 조합으로 구성된 모드이다.

### 영문 대소문자 구분

- MySQL 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다.
  - 윈도우에 설치된 MySQL에서는 대소문자를 구분하지 않지만 유닉스 계열의 운영체제에서는 대소문자를 구분한다.
- MySQL 서버의 설정 파일에 lower_case_table_names 시스템 변수를 설정하면 운영체제와 관계없이 대소문자 구분의 영향을 받지 않게 한다.
- 설정 자체를 떠나서 가능하면 초기 DB나 테이블을 생성할 때 대문자 또는 소문자만으로 통일해서 사용하는 편이 좋다

### MySQL 예약어

- 생성하는 데이터베이스나 테이블, 칼럼의 이름을 예약어와 같은 키워드로 생성하면 칼럼이나 테이블을 SQL에서 사용하기 위해 백틱이나 쌍따옴표로 감싸야 한다.
  - SQL을 작성하는 개발자에게 문법이 틀리다라는 에러만 출력하므로 찾기 어려운 버그의 원인이 될 수 있다.
  - 예약어를 사용하지 말자

-------------

## MySQL 연산자와 내장 함수

- MySQL에서는 ANSI 표준 형태가 아닌 연산자가 많이 있는데 SQL의 가독성을 높이기위해 ANSI 표준 형태의 연산자를 사용하는 것을 권장한다.

### 리터럴 표기법 문자열

#### 문자열

- SQL 표준에서 문자열은 항상 홑따옴표(')를 사용해 표기하지만 MySQL에서는 쌍따옴표를 사용해 문자열을 표기할 수 있다.
- SQL 표준에서는 문자열 값에 홑따옴표가 포함돼 있을 때 홑따옴표를 두 번 연속해서 입력하면 되지만 MySQL에서는
문자열 값이 쌍따옴표를 가지고 있을 때는 쌍따옴표를 두 번 연속해서 사용할 수 있다.
- SQL에서 사용되는 식별자(테이블이나 칼럼명 등)가 키워드와 충돌할 때 오라클이나 PostgreSQL에서는 쌍따옴표나 대괄호로 감싸서 충돌을 막지만
MySQL에서는 백틱(`)으로 감싸서 사용한다.
  - MySQL 서버의 sql_mode 시스템 변수값에 ANSI_QUOTES를 설정하면 리터럴 표기에 
  쌍따옴표를 사용 못하고 테이블명이나 칼럼명의 충돌을 피하려면 백틱이 아니라 쌍따옴표로 감싸야 한다.

#### 숫자

- 숫자 값을 상수로 SQL에 사용할 때는 따옴표 없이 숫자 값을 입력하면 된다.
- 문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 칼럼이면 MySQL 서버가 문자열 값을 숫자 값으로 자동 변환한다.

```mysql
SELECT * FROM tab_test WHERE number_column='10001';
SELECT * FROM tab_test WHERE string_column=10001;
```
- MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행한다.
- 첫 번째 쿼리는 주어진 상숫값을 숫자로 변환한다.
  - 상숫값 하나만 변환하므로 성능과 관련된 문제가 발생하지 않는다.
- 두 번째 쿼리는 주어진 상숫값이 숫자 값인데, 비교되는 칼럼은 문자열 칼럼이다.
  - MySQL은 문자열 칼럼을 숫자로 변환해서 비교한다.
  - string_column에 있는 모든 문자열을 숫자로 변환해서 비교를 수행하므로 문제가 발생한다.

#### 날짜

- 다른 DBMS에서 날짜 타입을 비교하거나 INSERT 하려면 문자열을 DATE 타입으로 변환하는 코드가 필요하지만 MySQL에서는 정해진 형태의 날짜 포맷으로 표기하면
자동으로 DATE나 DATETIME 값으로 변환한다.
- 날짜 타입의 칼럼과 문자열 값을 비교하는 경우 MySQL 서버는 문자열 값을 DATE 타입으로 변환해서 비교한다.

#### 불리언

- BOOL이나 BOOLEAN 타입은 TINYINT 타입에 대한 동의어다.
- FALSE는 0, TRUE는 1을 의미한다.
- 불리언 타입은 ENUM 타입으로 관리하는 것이 좀 더 명확하고 실수할 가능성도 줄일 수 있다.

### MySQL 연산자

#### 동등(Equal) 비교(=, <=>) 

- 동등 비교는 다른 DBMS와 마찬가지로 = 를 사용한다.
- MySQL은 <=> 연산자도 제공한다.
  - =와 같으며 NULL 값에 대한 비교까지 수행한다.
  - NULL-Safe 비교 연산자
  - 양쪽 비교 대상 모두 NULL이라면 TRUE를 반환하고, 한쪽만 NULL이라면 FALSE를 반환한다.
  - NULL을 하나의 값으로 인식하고 비굫나ㅡㄴ 방법

#### 부정(Not-Equal) 비교(<>, !=)

- 어느 쪽을 사용하든 문제가 되지 않지만 혼용되면 가독성이 떨어지므로 통일해서 사용하는 방법을 권장한다.

#### NOT 연산자(!)

- TRUE 또는 FALSE 연산의 결과를 반대로(부정) 만드는 연산자로 "NOT"을 사용한다.
- !도 사용할 수 있다.

#### AND(&&)와 OR(||) 연산자

- MySQL에서는 AND와 OR 뿐만 아니라 &&와 ||의 사용도 허용한다.
- SQL의 가독성을 높이기 위해 다른 용도로 사용될 수 있는 && 연산자와 || 연산자는 사용을 자제하는 것이 좋다.

#### 나누기(/, DIV)와 나머지(%, MOD) 연산자

- 나누기 연산자는 일반적으로 "/" 연산자를 사용한다.
  - 나눈 몫의 정수 부분만 가져오려면 DIV 연산자 사용
- 나눈 결과 몫이 아닌 나머지는 "%" 또는 MOD 연산자를 사용한다.

#### REGEXP 연산자

- 문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자, RLIKE와 같다.
- REGEXP 연산자는 좌측에 비교 대상 문자열 값 또는 칼럼, 우측에 정규식을 사용하면 된다.

#### LIKE 연산자

- REGEXP 보다는 단순한 연산자이지만 더 많이 사용한다.
  - REGEXP는 인덱스를 사용하지 못하지만 LIKE는 사용가능하다.
- LIKE에서 사용할 수 있는 와일드카드 문자는 "%"와 "_"가 전부다.
  - %: 0 또는 1개 이상의 모든 문자에 일치
  - _: 정확히 1개의 문자에 일치
- LIKE 연산자는 와일드카드 문자가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔을 사용할 수 있지만 앞에 있다면 사용할 수 없다.

#### BETWEEN 연산자

- 크거나 같다와 작거나 같다 두개의 연산자를 하나로 합친 연산자이다.
- 다른 비교 조건과 결합해 하나의 인덱스를 사용할 때 주의해야 할 점이 있다.

```mysql
SELECT * FROM dept_emp WHERE dept_no='d003' AND emp_no=10001;
SELECT * FROM dept_emp WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no=10001;
SELECT * FROM dept_emp WHERE dept_no IN ('d003','d004','d005') AND emp_no=10001;
```

- dept_emp 테이블에는 (dept_no, emp_no) 칼럼으로 구성된 프라이머리 키가 존재
  - 첫 번째 쿼리는 dept_no와 emp_no 조건 모두 인덱스를 이용해 범위를 줄여주는 방법으로 사용할 수 있음.
  - 두 번째 쿼리는 dept_no가 d003 부터 d005 까지 다 봐야하기 때문에 emp_no=10001 조건은 비교 범위를 줄이는 역할을 하지 못함.
- BETWEEN은 크다 작다 비교를 하나로 묶어둔 것이고, IN 연산자는 동등 비교(=)와 비슷하기에 두 번째 쿼리는 인덱스를 다 읽지만,
세 번째 쿼리는 emp_no=10001 조건도 작업 범위를 줄이는 용도로 인덱스를 이용할 수 있다.

#### IN 연산자

- IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자
  - 범위로 검색하는 것이 아니기 때문에 일반적으로 빠르게 처리됨.
  - 상수가 사용된 경우: IN(?,?,?)
  - 서브쿼리가 사용된 경우: IN(SELECT .. FROM ..)
- IN 절에 상숫값이 단순 스칼라값이 아니라 튜플이 사용되어도 8.0 버전부터는 인덱스를 최적으로 사용할 수 있다.
- NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시되는데 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없기 때문이다.
  - 프라이머리 키와 비교될 때 가끔 쿼리 실행계획에 레인지 스캔이 표시되는 경우가 있는데 InnoDB 테이블에서 프라이머리 키가 클러스터링 키이기 때문일 뿐
  실제 IN과 같이 효율적으로 실행된다는 것을 의미하진 않는다.

### MySQL 내장 함수

- MySQL 함수는 기본으로 제공하는 내장 함수와 사용자가 직접 작성해서 추가할 수 있는 사용자 정의 함수(UDF, User Defined Function)으로 구분된다.
  - 사용자 정의 함수는 스토어드 프로그램으로 작성되는 프로시저나 스토어드 함수와는 다르다

#### NULL 값 비교 및 대체(IFNULL, ISNULL)

- IFNULL()은 칼럼이나 표현식의 값이 NULL인지 비교하고, NULL이면 다른 값으로 대체하는 용도로 사용한다.
  - 첫 번째 인자는 NULL인지 아닌지 비교하려는 칼럼이나 표현식
  - 두 번째 인자로는 첫 번째 인자의 값이 NULL일 경우 대체할 값이나 칼럼을 설정
- ISNULL()은 전달한 표현식이나 칼럼의 값이 NULL인지 아닌지 비교하는 함수

#### 현재 시각 조회(NOW, SYSDATE)

- 둘 다 현재의 시간을 반환하는 함수이지만 차이가 있다.
- 하나의 SQL에서 모든 NOW() 함수는 같은 값을 가지지만 SYSDATE() 함수는 호출되는 시점에 따라 결괏값이 달라진다.
- 따라서 SYSDATE() 함수는 두 가지 큰 잠재적인 문제가 있다.
  - SYSDATE() 함수가 사용된 SQL은 레플리카 서버에서 안정적으로 복제되지 못한다
  - SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못한다.
    - NOW()는 쿼리가 실행되는 시점에서 실행되고 값을 할당받아서 그 값을 SQL 문장의 모든 부분에서 사용하기 때문에
    인덱스를 스캔할 때도 유지되므로 비교 조건이 된다.
    - SYSDATE()는 상수가 아니기 때문에 매번 비교되는 레코드마다 함수를 실행해야 하기에 인덱스에 사용하지 못한다.
- MySQL 설정 파일에 sysdate-is-now 시스템 변수를 넣으면 SYSDATE() 함수도 NOW() 함수와 같이 함수의 호출 시점에 관계없이 하나의 SQL에서 같은 값을
갖게 된다.

#### 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)

- DATETIME 타입의 칼럼이나 값을 원하는 형태의 문자열로 변환해야 할 때는 DATE_FORMAT() 함수를 이용하면 된다.
  - %Y: 4자리 연도
  - %m: 2자리 숫자 표시의 월(01~12)
  - %d: 2자리 숫자 표시의 일자(01~31)
  - %H: 2자리 숫자 표시의 시(00~23)
  - %i: 2자리 숫자 표시의 분(00~59)
  - %s: 2자리 숫자 표시의 초(00~59)
- SQL에서 표준 형태(년-월-일 시:분:초)로 입력된 문자열은 필요한 경우 자동으로 DATETIME 타입으로 변환되어 처리된다.
- MySQL 서버가 문자열에 사용된 날짜 타입의 포맷을 알 수 없는 경우엔 명시적으로 날짜 타입으로 변환해야 하는데 그때 사용하는 함수가
STR_TO_DATE()이다.
  - 날짜의 각 부분을 명시하는 지정자는 DATE_FORMAT() 함수에서 사용했던 지정자와 동일하게 사용하면 된다.

#### 날짜와 시간의 연산(DATE_ADD, DATE_SUB)

- DATE_ADD() 함수로 더하거나 빼는 처리를 모두 할 수 있기 때문에 DATE_SUB()는 크게 필요하지 않다.
- 두 함수 모두 두 개의 인자를 필요로 하는데, 첫 번째 인자는 연산을 수행할 날짜이며 두 번째 인자는 더하거나 빼고자하는 월의 수나 일자의 수 등을 입력하면 된다.
  - 두 번째 인자는 INTERVAL n [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND,...] 형태로 입력해야 한다.
    - n은 더하거나 뺴고자 하는 차이 값, 그 뒤에 명시되는 단위

```mysql
SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS tomorrow;
SELECT DATE_ADD(NOW(), INTERVAL -1 DAY) AS yesterday;
```

#### 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)

- UNIX_TIMESTAMP() 함수는 '1970-01-01 00:00:00'으로부터 경과된 초의 수를 반환하는 함수이다.
  - 함수에 인자가 없으면 현재 날짜와 시간의 타임스탬프 값을, 인자로 특정 날짜를 전달하면 그 날짜의 타임스탬프를 반환
- FROM_UNIXTIME() 함수는 인자로 전달한 타임스탬프 값을 DATETIME 타입으로 변환하는 함수다.
- MySQL의 TIMESTAMP 타입은 4바이트 숫자 타입으로 저장되기 때문에 실제로 가질 수 있는 값의 범위는
'1970-01-01 00:00:01' ~ '2038-01-09 03:14:07' 까지의 날짜 값만 가능하다.

#### 문자열 처리(RPAD, LPAD/ RTRIM, LTRIM, TRIM)

- RAPD()와 LPAD() 함수는 문자열의 좌측 또는 우측에 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수다
  - 3개의 인자가 필요하다
    - 첫 번째 인자는 패딩 처리를 할 문자열
    - 두 번째 인자는 몇 파이트까지 패딩할 것인지(패딩 적용 후 결과로 반환될 문자열의 최대 길이)
    - 세 번째 인자는 어떤 문자를 패딩할 것인지
- RTRIM() 함수와 LTRIM() 함수는 문자열의 우측 또는 좌측에 연속된 공백 문자(space, newline, tab 문자)를 제거하는 함수
- TRIM() 함수는 RTRIM과  LTRIM을 동시에 수행하는 함수

#### 문자열 결합(CONCAT)

- 여러 개의 문자열을 연결해서 하나의 문자열로 반환하는 함수, 인자의 개수는 제한이 없다.
- 숫자 값을 인자로 전달하면 문자열 타입으로 자동 변환한 후 연결
- 의도된 결과가 아닌 경우에는 명시적으로 CAST() 함수를 이용해 타입을 문자열로 변환하는 편이 안전하다.
- CONCAT_WS() 함수는 각 문자열을 연결할 때 구분자를 넣어준다.
  - CONCAT_WS(',' , 'GEORGI', 'CHRISTIAN')

#### GROUP BY 문자열 결합(GROUP_CONCAT)

- COUNT()나 MAX(), MIN(), AVG() 등과 같은 그룹 함수 중 하나.
- GROUP_CONCAT() 함수는 값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하다.
- GROUP_CONCAT() 함수는 지정한 칼럼의 값들을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다.
  - JDBC로 실행될 때는 메모리 버퍼를 초과하면 경고가 아닌 에러가 발생하기 때문에 지정된 버퍼 크기를 초과하지 않게 주의해야 한다.
  - group_concat_max_len 시스템 변수
    - 기본값이 1KB 밖에 안되기에 자주 사용한다면 늘려야 한다.

#### 값의 비교와 대체(CASE WHEN ... THEN ... END)

- CASE WHEN은 프로그래밍 언어에서 제공하는 SWITCH 구문과 같은 역할을 한다.
  - CASE로 시작하고 END로 끝나야 하며, WHEN... THEN... 은 필요한 만큼 반복해서 사용할 수 있다.

#### 타입의 변환(CASE, CONVERT)

- 프리페어 스테이트먼트를 제외하면 SQL은 텍스트 기반으로 작동하기 때문에 SQL에 포함된 모든 입력값은 문자열처럼 취급된다.
- CAST() 함수를 통해 변환할 수 있는 데이터 타입은 DATE, TIME, DATETIME, BINARY, CHAR, DECIMAL, SIGNED INTEGER, UNSIGNED INTEGER
이다.
- CAST() 함수는 하나의 인자를 받아들이며 그 하나의 인자는 다시 두 부분으로 나뉘어 첫 번째 부분에 타입을 변환할 값이나 표현식을,
두 번째 부분에는 변환하고자 하는 데이터 타입을 명시하면 된다.
  - CAST('1234' AS SIGNED INTEGER)
- CONVERT() 함수는 CAST() 함수와 같이 타입을 변환하는 용도와 문자열의 문자 집합을 변환하는 용도라는 두 가지로 사용할 수 있다.
  - CONVERT(1-2, UNSIGNED)
  - CONVERT('ABC' USING 'utf8mb4')

#### 이진값과 16진수 문자열(Hex String) 변환(HEX, UNHEX)

- HEX() 함수는 이진값을 16진수 문자열로 변환하는 함수, UNHEX() 함수는 16진수 문자열을 읽어 이진값으로 변환하는 함수
  - 여기서 이진값은 사람이 읽을 수 있는 형태의 문자열이나 숫자가 아니라 바이너리 값

#### 암호화 및 해시 함수(MD5, SHA, SHA2)

- SHA() 함수는 SHA-1 암호화 알고리즘을 사용하며 160비트 해시 값을 반환한다.
- SHA2() 함수는 224비트 부터 512 비트 암호화 알고리즘을 사용해 생성된 해시 값을 반환한다.
- MD5() 함수는 메시지 다이제스트 알고리즘을 사용해 128비트 해시 값을 반환한다.
- 이 함수들 모두 사용자의 비밀번호와 같은 암호화가 필요한 정보를 인코딩하는 데 사용.
- MD5() 함수의 경우 문자열의 길이를 줄이는 방식이므로 인덱스화 할때 유용
- INDEX ix_accessurl( (MD5(access_url)) )
- 검색할 때도 MD5로 검색해야 인덱스 사용

#### 처리 대기(SLEEP)

- SQL의 개발이나 디버깅 용도로 잠깐 대기하거나 일부러 쿼리의 실행을 오랜 시간 유지하고자 할 때 상당히 유용한 함수

#### 벤치마크(BENCHMARK)

- 디버깅이나 간단한 함수의 성능 테스트용으로 아주 유용한 함수
- BENCHMARK() 함수는 2개의 인자를 필요
  - 첫 번째 인자는 반복해서 수행할 횟수
  - 두 번째 인자는 반복해서 실행할 표현식
    - 스칼라 값을 반환하는 표현식

- 정확한 값은 아님
  - SELECT BENCHMARK(10, expr) 과 SELECT expr을 10번 직접 실행하는 것과는 차이가 있음
    - 쿼리의 파싱이나 최적화, 테이블 잠금이나 네트워크 비용이 다름.
- BENCHMARK() 함수로 얻은 쿼리나 함수의 성능은 그 자체로 큰 의미가 없으며 두 개의 동일 기능을 상대적으로 비교 분석하는 용도로 사용해야 함

#### IP 주소 변환(INET_ATON, INET_NTOA)

- IP 주소는 4바이트의 부호 없는 정수(Unsigned Integer)
- 하지만 대부분의 DBMS에서는 IP 정보를 VARCHAR(15) 타입에 '.'으로 구분해서 저장
  - 저장 공간을 훨씬 많이 필요로 함
  - 저장할 때 "127.0.0.1" 로 저장하므로 IP 주소 자체를 A, B, C 클래스로 구분하는 것도 불가능
- INET_ATON() 함수는 문자열로 구성된 IPv4 주소를 정수형으로 변환하는 함수
- INET_NTOA() 함수는 정수형의 IPv4 주소를 사람이 읽을 수 잇는 형태의 '.' 으로 구분된 문자열로 반환하는 함수
- INET6를 사용하면 IPv6 주소를 변환할 수 있음.

#### JSON 포맥(JSON_PRETTY)

- JSON 데이터의 기본 표시 방법은 단순 테스트 포맷인데 가독성이 안좋음.
- JSON_PRETTY() 함수를 이용하면 JSON 칼럼의 값을 읽기 쉬운 포맷으로 변환해 줌.
- SELECT JSON_PRETTY(doc) FROM employee_docs WHERE emp_no=10005

#### JSON 필드 크기(JSON_STORAGE_SIZE)

- JSON 데이터는 텍스트 기반이지만 MySQL 서버는 디스크의 저장 공간을 절약하기 위해 JSON 데이터를 실제 디스크에 저장할 때
BSON(Binary JSON) 포맷을 사용
  - BSON으로 변환 됐을 때 저장 공간의 크기가 얼마나 될 지 예측하기 어려움
- JSON_STORAGE_SIZE() 함수 제공.
  - 반환되는 값의 단위는 바이트

#### JSON 필드 추출(JSON_EXTRACT)

- JSON_EXTRACT() 함수는 2개의 인자를 필요
  - 첫 번째는 JSON 데이터가 저장된 칼럼 또는 JSON 도큐먼트 자체
  - 두 번째 인자는 가져오고자 하는 필드의 JSON 경로
- SELECT emp_no, JSON_EXTRACT(doc, "$.first_name") FROM employee_docs;
- SELECT emp_no, JSON_UNQUOTE(JSON_EXTRACT(doc, "$.first_name")) FROM employee_docs;
- JSON_UNQUOTE() 함수를 함께 사용하면 따옴표 없이 값만 가져올 수 있다.
- 자주 사용하는 처리이기 때문에 편의성을 위해 연산자를 제공한다.
- SELECT emp_no, doc->"$.first_name" FROM employee_docs;
- SELECT emp_no, doc->>"$.first_name" FROM employee_docs;

#### JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)

- JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지를 확인하는 함수
```mysql
SELECT emp_no FROM employee_docs WHERE JSON_CONTAINS(doc, '{"first_name":"Christian"}');
SELECT emp_no FROM employee_docs WHERE JSON_CONTAINS(doc, '"Christian"','$.first_name');
```
- JSON_CONTAINS() 함수의 첫 번째 인자는 JSON 데이터를 저장하고 있는 칼럼이나 도큐먼트이며, 두 번째 인자는 JSON 오브젝트(도큐먼트 또는 필드 값를 사용한다.

#### JSON 오브젝트 생성(JSON_OBJECT)

- RDBMS 칼럼의 값을 이용해 JSON 오브젝트를 생성하는 함수다.

```mysql
SELECT 
    JSON_OBJECT("empNo", emp_no,
                "salary",salary,
                "fromDate", from_date,
                "toDate", to_date) AS as_json
FROM salaries;
```

#### JSON 칼럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG)

- GROUP BY 절과 함께 사용되는 집계 함수로 RDBMS 칼럼의 값들을 모아 JSON 배열 또는 도큐먼트를 생성하는 함수이다.

```mysql
SELECT dept_no, JSON_OBJECTAGG(emp_no, from_date) AS agg_manager
FROM dept_manager
WHERE dept_no IN('d001','d002','d003')
GROUP BY dept_no;
```

#### JSON 데이터를 테이블로 변환(JSON_TABLE)

- JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어 반환한다.
- 항상 내부 임시 테이블을 이용하기 때문에 임시 테이블에 레코드가 많이 저장되지 않게 주의해야 한다.

-----------------------------

## SELECT

- 웹 서비스와 같이 온라인 트랜잭션 처리 환경의 데이터베이스에서는 INSERT나 UDPATE 같은 작업은 거의 레코드 단위로 발생하므로
성능상 문제가 되는 경우는 별로 없으나 SELECT는 여러 개의 테이블로부터 데이터를 조합해서 빠르게 가져와야 하기 때문에 여러 개의 테이블을
어떻게 읽을 것인가에 많은 주의를 기울여야 한다

### SELECT 절의 처리 순서

1. 드라이빙 테이블에서 WHERE 적용 및 조인 실행
2. GROUP BY
3. DISTINCT
4. HAVING 조건 적용
5. ORDER BY
6. LIMIT

- 각 요소가 없을 순 있지만 순서가 바뀌는 경우는 거의 없다.
- GROUP BY 절이 없이 ORDER BY만 사용된 쿼리에서는 이렇게 수행될 수도 있다.
1. 드라이빙 테이블에서 WHERE 적용
2. ORDER BY
3. 드리븐 테이블 조인 실행
4. LIMIT

- 위에 표시된 실행 순서를 벗어나느 쿼리가 필요하다면 서브쿼리로 작성된 인라인 뷰를 이용해야 한다.
- 하지만 인라인 뷰가 사용되면 임시 테이블이 사용되기 때문에 주의해야 한다.

### WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용

#### 인덱스를 사용하기 위한 기본 규칙

- WHERE 절이나 ORDER BY 또는 GROUP BY가 인덱스를 사용하려면 인덱스된 칼럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다.
- SELECT * FROM salaries WHERE salary*10 > 150000;
  - 위 쿼리의 경우 인덱스인 salary를 가공하여 다른 상숫값과 비교하기 때문에 인덱스를 적절히 이용하지 못한다.
  - 옵티마이저에서 SELECT * FROM salaries WHERE salary > 150000/10; 으로 바꿔서 사용할것같지만
  옵티마이저는 인덱스를 최적으로 이용할 수 있게 표현식을 변환하지는 못한다.
- WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 한다.
  - 값 자체를 변환하지 않는다는 것과 같은 범주에 속하는 이야기

#### WHERE 절의 인덱스 사용

- WHERE 조건이 인덱스를 사용하는 방법
  - 작업 범위 결정 조건
    - WHERE 절에서 동등 비교 조건이나 IN으로 구성된 조건에 사용된 칼럼들이 인덱스의 칼럼 구성과 좌측에서부터 비교했을 때
    얼마나 일치하는가에 따라 달라짐.
    - 인덱스의 순서와 WHERE 조건절의 순서는 실제 인덱스 사용 여부와 무관.
    - 옵티마이저가 인덱스를 사용할 수 있는 조건들을 뽑아서 최적화를 시킴.
      - WHERE 조건이 AND 연산자로 연결되는 경우를 가정
  - 체크 조건
- WHERE절에서 각 조건이 AND로 연결되면 읽어와야 할 레코드의 건수를 줄이는 역할을 하지만 OR로 연결되면 읽어서 비교해야 할 레코드가 더 늘어나기 때문에 주의해야 한다.

#### GROUP BY 절의 인덱스 사용

- GROUP BY 절에 명시된 칼럼의 순서가 인덱스를 구성하는 칼럼의 순서와 같으면 GROUP BY 절은 인덱스를 이용할 수 있다.
- 인덱스를 구성하는 칼럼 중에서 뒤쪽에 있는 칼럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있지만 인덱스의 앞쪽에 있는 칼럼이
GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없다.
- WHERE 조건절과는 달리 GROUP BY 절에 명시된 칼럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못한다.


#### ORDER BY 절의 인덱스 사용

- MySQL에서 GROUP BY와 ORDER BY는 처리 방법이 비슷하기 때문에 인덱스 사용 여부도 비슷하다.
- 하지만 하나 추가되는 것이 있는데 정렬되는 각 칼럼의 오름차순(ASC) 및 내림차순(DESC) 옵션ㅇ이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다.

#### WHERE 조건과 ORDER BY(또는 GROUP BY)절의 인덱스 사용

- 쿼리에 WHERE 절만 또는 GROUP BY 나 ORDER BY 절만 포함돼 있다면 사용된 절 하나에만 초점을 맞춰서 인덱스를 사용할 수 있게 튜닝하면 된다.
- 하지만 애플리케이션에서 사용되는 쿼리는 그렇게 단순하지 않다.
- WHERE 절과 ORDER BY 절이 같이 사용된 하나의 쿼리 문장은 다음 3가지 중 한 가지 방법으로만 인덱스를 이용한다.
  - WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용
    - WHERE 절의 비교 조건에서 사용하는 칼럼과 ORDER BY 절의 정렬 대상 칼럼이 모두 하나의 인덱스에 연속해서 포함돼 있을때 사용
    - 나머지 2가지 방식보다 훨씬 빠른 성능
  - WHERE 절만 인덱스를 이용
    - ORDER BY 절은 인덱스를 이용한 정렬이 불가능
    - 인덱스를 통해 검색된 결과 레코드를 별도의 정렬 처리 과정을 거쳐 정렬 수행
    - WHERE 절의 조건에 일치하는 레코드의 건수가 많지 않을 때 효율적
  - ORDER BY 절만 인덱스를 이용
    - ORDER BY 절의 순서대로 인덱스를 읽으면서 레코드 한 건식 WHERE 절의 조건에 일치하는지 비교하고, 일치하지 않을 때는 버리는 형태
    - 아주 많은 레코드를 조회해서 정렬할 때 이런 형태로 튜닝

#### GROUP BY 절과 ORDER BY 절의 인덱스 사용

- GROUP BY와 ORDER BY 절이 동시에 사용된 쿼리에서 두 절이 모두 하나의 인덱스를 사용해서 처리되려면 GROUP BY 절에 명시된 칼럼과
ORDER BY에 명시된 칼럼의 순서와 내용이 모두 같아야 한다.
- GROUP BY와 ORDER BY가 같이 사용된 쿼리에서는 둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘 다 인덱스를 사용하지 못한다.

#### WHERE 조건과 ORDER BY절, GROUP BY 절의 인덱스 사용

- 모두 포함된 쿼리가 인덱스를 사용하는지 판단하는 방법.
1. WHERE 절이 인덱스를 사용할 수 있는가?
2. GROUP BY 절이 인덱스를 사용할 수 있는가?
3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가?

### WHERE 절의 비교 조건 사용 시 주의사항

- 쿼리가 최적으로 실행되려면 적합한 인덱스와 함께 WHERE 절에 사용되는 비교 조건의 표현식을 적절하게 사용해야 한다.

#### NULL 비교

- MySQL에서는 NULL 값이 포함된 레코드도 인덱스로 관리된다.
- 쿼리에서 NULL 인지 비교하려면 IS NULL 또는 <=> 연산자를 사용해야 한다.
- NULL인 레코드를 조회하는 쿼리이지만 인덱스를 적절히 이용할 수 있다.
- ISNULL() 함수를 사용해도 되지만 ISNULL(...)=1 , ISNULL(...)=TRUE 라고 하면 인덱스나 테이블을 풀스캔하기 때문에
NULL 비교를 할 때는 가급적 IS NULL 연산자를 사용해야 한다.

#### 문자열이나 숫자 비교

- 타입에 맞는 상숫값을 사용해야 한다.
  - 비교 대상 칼럼이 문자열이라면 리터럴
  - 숫자 타입이라면 숫자 리터럴
- SELECT * FROM emp_no='10001'
  - 이 쿼리에서 옵티마이저는 숫자 타입 우선이므로 문자열인 '10001'을 숫자로 바꾸기 때문에 인덱스를 사용할 수 있다.
- SELECT * FROM first_name=10001
  - 이 쿼리에서 옵티마이저는 숫자 타입 우선이므로 first_name을 숫자로 바꾼다. 그렇기에 인덱스에 변환이 이루어져 인덱스를 사용할 수 없다.

#### 날짜 비교

- DATE 또는 DATETIME과 문자열 비교
  - 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행한다.
  - 하지만 DATE_FORMAT 함수를 사용하면 인덱스를 효율적으로 사용하지 못한다.
    - 칼럼을 변경하지 말고, 상수를 변경하라
- DATE와 DATETIME의 비교
  - DATETIME 값에서 시간 부분만 떼어 버리고 비교하려면 DATE() 함수를 사용하면 된다.
    - 날짜 부분만 반환하는 함수
  - DATETIME 타입의 값을 DATE 타입으로 만들지 않고 그냥 비교하면 MySQL 서버가 DATE 타입의 값을
  DATETIME으로 바꾼 다음 비교를 수행한다.
  - DATETIME과 DATE 타입의 비교에서 타입 변환은 인덱스의 사용 여부에 영향을 미치지 않기 때문에 성능보다는 쿼리의 결과에 주의해서 사용하면된다
- DATETIME과 TIMESTAMP의 비교
  - UNIX_TIMESTAMP() 함수의 결과값은 MySQL 내부적으로 단순 숫자값에 불과하다.
  - 비교 값으로 사용되는 상수 리터럴을 비교 대상 컬럼의 타입에 맞게 변환해서 사용해야 한다.

#### Short-Circuit Evaluation

- 여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는
최적화
- MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 Short-circuit Evaluation 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정한다.
- 그런데 WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 Short-curcuit Evaluation과는 무관하게 MySQL 서버는 그 조건을
가장 최우선으로 사용한다.
  - WHERE 조건절에 나열된 조건의 순서가 인덱스의 사용 여부를 결정하지 않는 이유
- MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은
WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것이다.

### DISTINCT

- 많은 사용자가 조인을 하는 경우 레코드가 중복해서 출력되는 것을 막기 위해 DISTINCT를 남용하는데 성능적인 문제도 있지만
쿼리의 결과도 의도한 바와 달라질 수 있다.

### LIMIT n

- LIMIT은 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져오고자 할때 사용한다.
- LIMIT의 중요한 특성은 LIMIT에서 필요한 레코드 건수만 준비되면 즉시 쿼리를 종료한다는 것이다.
- GROUP BY나 ORDER BY 또는 DISTINCT가 인덱스를 이용해 처리될 수 있다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어 주기 때문에
쿼리의 작업량을 상당히 줄어든다.
- LIMIT 2000000, 10 의 경우 2000010 건의 레코드를 읽은 후 2000000건은 버리고 마지막 10건만 사용자에게 반환하기 때문에 쿼리가 느려진다.
- LIMIT 조건의 페이징이 처음 몇 개 페이지 조회로 끝나지 않을 가능성이 높다면 WHERE 조건절로 읽어야할 위치를 찾고 그 위치에서 10개만 읽는 형태의 쿼리를
사용하는 것이 좋다.

### COUNT()

- MyISAM 스토리지 엔진을 사용하는 테이블은 테이블의 메타 정보에 전체 레코드 건수를 관리하기 때문에 WHERE 조건이 없는
COUNT(*) 쿼리는 실제 레코드 건수를 세어 보지 않아도 바로 결과를 반환할 수 있다.
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 WHERE 조건이 없는 COUNT(*) 쿼리라 하더라도 직접 읽어야 하기 때문에 주의해야 한다.
- COUNT(*) 쿼리에서는 ORDER BY 구문이 어떤 경우에도 필요치 않다.
- COUNT() 함수에 칼럼명이나 표현식이 인자로 사용되면 그 칼럼이나 표현식의 결과가 NULL이 아닌 레코드 건수만 반환한다.

### JOIN

#### JOIN의 순서와 인덱스

- 조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면 된다.
- 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복한다.
  - 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지한다.

```mysql
SELECT *
FROM employees e, dept_emp de
WHERE e.emp_no=de.emp_no;
```
- 두 칼럼 모두 각각 인덱스가 있는 경우
  - 어느 테이블을 드라이빙으로 선택하든 인덱스를 이용해 드리븐 테이블의 검색 작업을 빠르게 처리할 수 있다.
- employees.emp_no 에만 인덱스가 있는 경우
  - dept_emp 테이블이 드리븐 테이블로 선택된다면 employees 테이블의 레코드 건수만큼 dept_emp 테이블을 풀 스캔해야 한다.
  - 따라서 옵티마이저는 dept_emp 테이블을 드라이빙 테이블로 선택하고, employees 테이블을 드리븐 테이블로 선택한다.
- dept_emp.emp_no
  - 위와 반대로 처리된다.
- 두 칼럼 모두 인덱스가 없는 경우
  - 어느 테이블을 드라이빙으로 선택하든 드리븐 테이블 풀스캔은 발생하기 때문에 통계 정보를 확인하여 선택한다. 단
  레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 효율적이다.

#### JOIN 칼럼의 데이터 타입

- 조인 칼럼 간의 비교에서 각 칼럼의 데이터 타입이 일치하지 않으면 인덱스를 효율적으로 이용할 수 없다.

#### OUTER JOIN의 성능과 주의사항

- 이너 조인(INNER JOIN)은 조인 대상 테이블에 모두 존재하는 레코드만 결과 집합으로 반환된다.
- MySQL 옵티마이저는 절대 아우터로 조인되는 테이블을 드라이빙 테이블로 선택하지 못하기 때문에 성능 이슈가 발생할 수 있다.
- 필요한 데이터와 조인되는 테이블 간의 관계를 정확히 파악해서 꼭 필요한 경우가 아니라면 이너 조인을 사용하는 것이 업무 요건을 정확히 구현함과 동시에 쿼리의 성능도
향상시킬 수 있다.

#### JOIN과 외래키

- 외래키는 조인과 아무런 연관이 없다.
- 외래키를 생성하는 주목적은 데이터의 무결성을 보장하기 위해서다.

#### 지연된 조인(Delayed Join)

- 조인을 사용해서 데이터를 조회하는 쿼리에 GROUP BY 또는 ORDER BY를 사용할 때 각 처리 방법에서 인덱스를 사용하고 있다면
이미 최적으로 처리되고 있을 가능성이 높지만 그렇지 못하다면 MySQL 서버는 우선 모든 조인을 실행하고 난 다음 GROUP BY나 ORDER BY를
처리한다.
- 조인은 실행되면 될수록 결과 레코드 건수가 늘어나기 때문에 조인의 결과를 GROUP BY 혹은 ORDER BY하면 조인을 실행하기 전의 레코드보다
늘어난다.
- 지연된 조인이란 조인이 실행되기 전에 GROUP BY 나 ORDER BY를 처리하는 방식을 의미한다.
  - 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있다.
- 지원된 조인 형태로 개선하기 위해선 조건이 필요하다
  - LEFT(OUTER) JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계여야 한다.
  - INNER JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1의 관계임과 동시에 드라이빙 테이블에 있는
  레코드는 드리븐 테이블에 모두 존재해야 한다.

### GROUP BY

- 특정 칼럼의 값으로 레코드를 그루핑하고, 그룹별로 집계된 결과를 하나의 레코드로 조회할 때 사용한다.

#### WITH ROLLUP

- 그루핑된 그룹별로 소계를 가져올 수 있는 롤업 기능을 사용할 수 있다.
- 엑셀의 피벗 테이블과 거의 동일한 기능이다.
- 소계 레코드의 칼럼값은 항상 NULL로 표시된다.

### ORDER BY

- ORDER BY 절이 사용되지 않으면 SELECT 쿼리의 결과는 어떤 순서로 정렬?
  - 인덱스를 사용한 SELECT의 경우엔 인덱스에 정렬된 순서
  - 인덱스를 사용하지 않고 풀 테이블 스캔일때 MyISAM 테이블은 저장된 순서이지만 INSERT 순서는 아님
    - INSERT되는 레코드가 테이블의 마지막이 아니라 빈 공간이 있으면 빈 공간에 저장되기 때문
    - InnoDB의 경우 프라이머리 키로 클러스터링돼 있기 때문에 풀 테이블 스캔의 경우 기본적으로 프라이머리 키 순서대로 레코드를 가져옴
  - SELECT 쿼리가 임시 테이블을 거쳐 처리되면 조회되는 레코드의 순서를 예측하기 어려움

#### ORDER BY 사용법 및 주의사항

- 일반적으로 정렬할 대상은 칼럼명이나 표현식으로 명시하지만 SELECT 되는 칼럼의 순번을 명시할 수도 있다.
  - ORDER BY 2 라고 명시하면 SELECT 되는 칼럼 중에서 2번째 칼럼
  - 숫자가 아닌 문자열 상수를 사용하면 옵티마이저가 ORDER BY 절을 무시해버림.

### 서브쿼리

- 조인처럼 여러 테이블을 섞어 두는 형태가 아니어서 쿼리의 가독성이 높아지고 복잡한 쿼리도 손쉽게 작성할 수 있다.
- MySQL 8.0 버전부터는 서브쿼리 처리가 많이 개선됬다.

#### SELECT 절에 사용된 서브쿼리

- SELECT 절에 사용된 서브쿼리는 내부적으로 임시 테이블을 만들거나 쿼리를 비효율적으로 실행하게 만들지는 않기 때문에
서브쿼리가 적절히 인덱스를 사용할 수 있다면 크게 주의할 사항은 없다.
- SELECT 절의 서브쿼리에는 로우 서브쿼리를 사용할 수 없고 오직 스칼라 서브쿼리만 사용할 수 있다.
  - 스칼라 서브쿼리: 레코드의 칼럼이 각각 하나인 결과를 만들어내는 서브쿼리
  - 로우 서브쿼리: 스칼라 서브쿼리보다 레코드 건수가 많거나 칼럼 수가 많은 결과를 만들어 내는 서브쿼리

