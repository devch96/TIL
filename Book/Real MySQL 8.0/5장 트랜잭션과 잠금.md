# 트랜잭션과 잠금

- 트랜잭션은 작업의 완전성을 보장해 주는 것이다.
- 잠금과 트랜잭션은 서로 비슷한 개념 같지만 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.

----------

## 트랜잭션

### MySQL에서의 트랜잭션

- 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합됐을 때만 의미 있는 개념은 아니다.
- InnoDB는 트랜잭션을 지원하는 반면 MyISAM 또는 MEMORY 스토리지 엔진은 지원하지 않는다.

### 주의사항

- 트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
- 프로그램의 코드에서 라인 수는 한두 줄이라고 하더라도 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.

------------

## MySQL 엔진의 잠금

- MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.
- MySQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락 이외에도 테이블의 구조를 잠그는 메타데이터 락 그리고 사용자의 필요에 맞게 사용할 수 있는
네임드 락이라는 잠금 기능도 제공한다.


### 글로벌 락

- MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이
대기 상태로 남는다.

### 테이블 락

- 테이블 락은 개별 테이블 단위로 설정되는 잠금.
- 명시적인 테이블 락도 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 ㄱ거의 없다.

### 네임드 락

- 네임드 락은 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
- 네임드 락은 자주 사용되지 않는다.
  - 데이터베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건처럼
  여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.

### 메타데이터 락

- 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금.
- 배치 프로그램에서 자주 발생

------------

## InnoDB 스토리지 엔진 잠금

- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
- MySQL 서버의 information_schema 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 조인해서 조회하면 현재
어떤 트랜잭션이 어떤 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있으며 장시간 잠금을 가지고 있는 클라이언트를
찾아서 종료시킬 수 있다.

### InnoDB 스토리지 엔진의 잠금

- 레코드 기반의 잠금 기능을 제공하며 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우
는 없다.
- InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재한다.

#### 레코드 락

- 레코드 자체만을 잠그는 것을 레코드 락이라고 한다.
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
  - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

#### 갭 락

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어한다.

#### 넥스트 키 락

- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다.

#### 자동 증가 락

- AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는
일련번호 값을 가져야 하기 때문에 테이블 수준의 잠금을 사용한다.
- INSERT와 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며 UPDATE나 DELETE등의 쿼리에서는 걸리지 않는다.

### 인덱스와 잠금

- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
  - 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.
- 테이블에 인덱스가 하나도 없다면 풀 스캔하면서 UPDATE 작업을 하는데 그 과정에서 모든 레코드를 잠그게 된다.
  - MySQL의 InnoDB에서 인덱스 설계가 중요한 이유

-------------

## MySQL의 격리 수준

- 격리 수준
  - READ UNCOMMITTED
  - READ COMMITTED
  - REPEATABLE READ
  - SERIALIZABLE

### READ UNCOMMITTED

- 각 트랜잭션에서 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.
- INSERT된 내용을 롤백한다고 하더라도 여전히 보이는 것이 문제이다.
- 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 더티 리드(DIRTY READ)라고 하고, 더티 리드가 허용되는 격리 수준이
READ UNCOMMITTED다.
- 더티 리드는 RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.

### READ COMMITTED

- 오라클 DBMS에서 기본으로 사용되는 격리 수준이며 온라인 서비스에서 가장 많이 선택되는 격리 수준이다.
- 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
- NON-REPEATABLE READ라는 부정합의 문제가 있다.
  - 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋남.
    - 사용자 A가 SELECT * WHERE FIRST_NAME = 'TOTO'를 해서 결과 없음을 받았음.
    - A가 트랜잭션을 진행중에 B가 UPDATE SET FIRST_NAME='TOTO'를 하고 커밋함
    - A가 같은 트랜잭션 내에서 다시 검색하면 결과가 나옴.
- 일반적인 웹 프로그램에서는 크게 문제되지 않을 수 있지만 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와
연결되면 문제가 될 수 있다.

### REPEATABLE READ

- InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준.
- NON-REPEATABLE READ 부정합이 발생하지 않는다.
- 언두 로그에서 트랜잭션-ID가 같은 값을 보여준다.
- 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상이 있음
  - PHANTOM READ


### SERIALIZABLE

- 기본적으로 순수한 SELECT 작업은 아무런 레코드 잠금도 설정하지 않고 실행된다.
- 하지만 SERIALIZABLE로 설정되면 읽기 작업도 공유 잠금을 획득해야만 하며 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
- PHANTOM READ 라는 문제가 발생하지 않는다.
