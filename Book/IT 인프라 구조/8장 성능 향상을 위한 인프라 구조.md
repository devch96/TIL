# 성능 향상을 위한 인프라 구조

--------------------

## 응답과 처리량

### 성능 문제의 두 가지 원인

- 시스템 성능 문제는 대부분 사용자 불만을 통해 인지하게 된다
  - 시스템이 느리다
  - 클릭한 후 화면이 뜨지 않는다
  - 일괄 처리가 끝나지 않는다
  - 오후에만 시스템이 갑자기 느리다
- 이러한 불만이 있을 때 인프라 관점에서는 다음 사항을 사용자로부터 확인해야 한다
  - 응답 속도가 느린가?
  - 처리량이 낮은가?
  - 아니면 둘 다인가?
- 시스템 성능을 가리킬 때 응답과 처리량이라는 지표가 자주 사용된다.
  - 응답은 처리 하나당의 소요 시간
  - 처리량은 단위 시간당 처리하는 양
- 실제 시스템에서는 단일 사용자 응답 시간만으로는 부족하기 때문에 여러 사용자의 평균값을 이용하는데 통계학에서 사용되는
퍼센타일(Percentile) 개념을 이용
  - 극단적으로 응답 시간이 긴 사용자는 다른 문제를 내포하고 있을 수 있기 때문에 오차라고 생각하고 평균값에 포함하지 않는 등

### 응답 문제

- 응답 시간에 포함되는 시간
  - 웹 브라우저로 화면을 클릭한 후 요청이 실행되기까지의 시간
    - 웹 서버에 도달하기까지의 시간
    - 웹 서버의 처리 시간
    - AP 서버의 처리 시간
    - DB 서버의 처리 시간
    - 각 서버의 네트워크 통신 시간
    - 클라이언트 PC에 도착하기까지의 시간
    - 결과를 표시하는 시간
- 사용자 체감 시간에는 각 계층의 처리 시간이 포함되므로 응답 문제가 발생하는 위치는 로그나 실제 장비 시험 등을 통해서
구체적으로 어떤 계층에서 응답 지연이 발생하고 있는지 파악해야 한다.
- 사용자가 이용하던 웹 브라우저의 렌더링 속도가 느려서 문제가 발생하는 경우도 있다.
- 서버의 응답 시간에 대해선 로그를 보면 되지만 네트워크 문제는 물리적 제약이 존재하므로 한계가 있다.
- 응답 시간 개선에 한계가 보일 때는 처리량 개선을 통해 시스템 전체 사용률을 개선하는 것이 일반적이다

### 처리량 문제

- 처리량이란 다수의 요청이 동시에 발생하면 막히기 쉽다.
- 응답과 처리량은 밀접한 관계다
- 응답이 매우 느린 시스템에서는 다수의 사용자 요청이 시스템 내에 누적되므로 전체 처리량도 낮아진다.
- 처리량이 포화 상태가 되면 리소스가 부족해져 응답도 함꼐 악화된다.

-------------------

## 병목 현상이란?

### 처리 속도의 제한 요소가 되는 병목 현상

- 병의 목 부분이 좁기 때문에 아무리 다른 부분이 넓더라도 흐르는 수량은 목의 두께에 의해 제한된다.
- 예를 들어 AP 서버에서 CPU 사용률이 높아져서 처리량이 한계에 다다르고 있다면, 웹 서버나 DB 서버의 처리량이 높아도
AP 서버가 처리량의 병목 지점이 되기 때문에 응답 시간이 전체적으로 지연된다.

### 병목 현상은 어떻게 해결하는가?

- 각 서버의 처리량이나 응답 상황 로그를 취득해서 어느 서버가 병목 지점이 되고 있는지 찾아내는 것부터 시작해야 한다.

#### 병목 현상 해결 방법

- 병목 위치를 파악해서 어떻게든 해결하는 것
  - 튜닝이라고 함
  - 병목 영역을 더 집중적으로 파헤치는 접근법이 유효
- 시스템 이용자 수를 제한하는 것
  - 유량 제어
  - 해당 사이트는 트래픽 초과로 차단되었습니다 이런 예시
  - 근본적인 해결책은 되지 못함

### 병목 지점은 반드시 존재한다

- 모든 서버, 소프트웨어, 하드웨어가 균등하게 처리량을 분배하는 것은 이론상 불가능
- 보이는 병목 현상을 모두 해결하자라는 성능 개선 접근법에는 끝이 없다.
- 성능 개선 시에는 반드시 특정 응답을 몇 퍼센트 개선시킨다 등 시스템 전체 관점에서 목표를 만드는 것이 매우 중요하다

---------------------

## 3계층형 시스템 그림을 통해 본 병목 현상

### CPU 병목 현상의 예

- CPU 사용률이 높다 = 나쁘다 가 성립하지는 않으며 그 반대도 성립하지 않는다.
- CPU 사용률은 처리 효율성을 나타내는 것으로 병목 현상 유무와는 관계가 없다.
- CPU 사용률은 하나의 상태를 가리키는 지표일 뿐이므로 CPU 사용률이 급증해서 문제가 있는지 없는지를 판단하려면 사용자 관점의 응답 속도나
시스템 전체 처리량을 확인해야 한다.
- CPU에 기인한 성능 문제
  - CPU를 이용하는 처리가 많아서 대기 행렬이 발생
  - CPU 응답이 느림

#### 대기 행렬의 병목 현상

- CPU 사용률이 높고 OS상에서 가동하고 있는 프로세스 수가 많으면 대기 행렬에서 병목 현상이 발생한다.
- 큐 대기 프로세스 수가 증가하면 vmstat 등의 유틸리티로 Run-Queue라는 값이 증가 하는 것을 확인할 수 있다.
- 대기 행렬은 CPU가 순조롭게 처리를 진행하고 있다면 언제가는 해결되지만, CPU 처리량보다 사용자의 요청이 많다면 대기 행렬이 점점 길어진다.
- 대기 행렬의 병목 현상은 처리량 측면의 문제를 의미한다. 처리량을 늘리면 해결할 수 있다.
  - CPU를 코어 수가 많은 것으로 변경하거나 서브를 추가해서 병렬 처리
  - 처리 자체를 짧게 만드는 방법도 유효
- CPU 코어 수를 늘리거나 수평 분할에 따른 서버 수를 늘리거나 하는 튜닝을 스케일 아웃이라고 부른다.

#### 응답의 병목 현상

- 대기 행렬을 튜닝하면 처리량 문제는 해결되지만 반드시 응답 문제가 해결되는 것은 아니다.
- 응답 시간을 개선하는 방법
  - 처리 능력을 향상시킨다
    - 스케일업이라고 한다.
    - CPU라면 클럭 수
    - 스케일업으로 성능을 향상시키는 것은 한계가 있다.
  - 병렬로 처리한다
    - 처리를 분할해서 다수의 CPU 코어에게 동시 처리를 시킨다.
    - 처리를 병렬화할 수 있는가가 중요 사항이 된다.
    - 인프라만으로 한계가 있기 때문에 애플리케이션 개발자의 협조가 필요하다

#### CPU 사용률이 오르지 않는다.

- 동기 I/O는 시스템 콜로 커널에 명령이 가지만, 이것이 완료되지 않으면 프로세스가 다음 처리를 진행하지 않는다. 이 상태의 프로세스는 대기 상태가 되며,
CPU를 이용할 수 없기 때문에 CPU 사용률은 올라가지 않는다.
- 이런 경우 CPU 사용률이 낮아도 I/O 대기 큐에서 대기하는 프로세스 수가 증가한다.
- CPU를 이용하는 처리와 디스크 I/O 처리를 비교하면 후자가 완료까지 시간이 오래 걸릴 때 이런 상황에 이르는 경우가 있다.
- 해결 방법
  - 처리 다중화
    - 처리를 다중화해서 CPU를 적절하게 활용하는 방법
    - 스레드를 여러 개 가동해서 동기 I/O 명령을 스레드 단위로 병행해서 실행하면 CPU 사용률도, I/O 부하도 증가한다
    - 서버 전체의 리소스 사용 상태를 개선할 수 있다.
  - I/O 비동기화

### 메모리 병목 현상 예

#### 영역 부족에 의한 병목 현상

- 프로세스가 가동해서 어떤 처리를 하려면 반드시 전용 메모리 영역이 필요하다. 하지만 서버상의 메모리 영역은 유한하다
- 유한한 메모리 영역이 부족하지 않도록 OS 커널 측에서 페이징 또는 스와핑이라는 처리를 해 빈 메모리를 확보하는 구조가 있다.
- 부족한 부분은 디스크 영역으로 보완해서 가상적인 큰 메모리가 있다는 것을 보여주는 기술인 가상 메모리가 있다.
  - 메모리가 가득 차게 되면 넘친 정보는 디스크에 저장되며, 해당 프로세스가 다시 이 영역을 이용할 때 메모리로 되돌리는 형태

#### 동일 데이터에 대한 병목 현상

- 메모리에 데이터를 캐시해도 메모리에서 경합이 발생하는 경우도 있다.
- 특정 영역을 복수의 프로세스가 공유하는 경우, 메모리 영역을 참조 또는 갱신할 때 누군가가 그 영역을 관리할 필요가 생긴다.
- 관리 영역이 데이터 영역보다 커지기 때문에 대기 행렬을 많이 사용하진 않는다.
- 애초에 경합이 발생하지 않도록 복수의 프로세스나 스레드가 같은 메모리 영역을 참조하지 않도록 하면 된다

### 디스크 I/O 병목 현상 예

- 메모리와 비교해서 디스크 I/O는 매우 느리다.
- I/O가 병목 지점이 될 때는 CPU 수를 늘리거나 클럭 주파수를 높여도 효과가 없고 I/O 효율을 높이든가 I/O를 줄이는 방법을 고민해야 한다.

#### 외부 저장소

- 로컬 디스크는 서너 대의 디스크로 RAID를 구성하고, 캐시로는 서버의 OS 메모리를 이용하지만 외부 저장소는 수십 대에서 수백 대 단위의 디스크를 배치하고,
거기에 캐시 전용 메모리 영역까지 있으므로 처리량 관점에서는 외부 저장소가 압도적으로 유리하다.
- 단일 응답은 가까우면 빠르다라는 규칙으로 로컬 디스크가 빠르지만, 외부 저장소는 자신이 가진 메모리 영역을 잘 활용해서 데이터 캐시를
효율적으로 작성함으로써 응답 속도를 개선하려 한다

#### 순차 I/O와 랜덤 I/O

- 디스크 I/O에는 순차(Sequenthial) 액세스와 랜덤(Random) 액세스가 있다
  - 순차는 순서를 따른다는 의미로, 선두부터 차례대로 액세스하는 방식이다.
  - 랜덤 액세스는 헤드가 움직이면서 해당 위치로 바로 건너뛰는 액세스 방식이다
- 단일 디스크가 기록 위치인 경우는 순차 방식이 빠르고 랜덤은 느리다.
- 저장 장치 측에서는 큰 파일에 대한 일괄 읽기 처리가 발생하면 다수의 디스크에 대해 동시에 순차 액세스를 한다.
- 작은 파일에 액세스하는 경우에는 단일 디스크에 랜덤 I/O를 하기 때문에 빠르지 않다.

### 네트워크 I/O 병목 현상

- 네트워크를 경유한 I/O는 CPU 버스나 메모리 간 I/O보다도 응답 시간 오버헤드가 크다.
- 응답을 근본적으로 개선하는 것은 어려우며, 처리량을 개선하는 접근법이나 네트워크 I/O 자체가 발생하지 않도록 하는 방법이 효과가 있다

#### 통신 프로세스의 병목 현상

- 통신에서 대역을 모두 사용하려면 다중화해서 병렬화할 필요가 있다.

#### 네트워크 경로의 병목 현상

- 라우터 중에는 방화벽 기능을 갖추고 있는 것이나, 세션 감시를 해서 장시간 지연되고 있는 세션을 강제적으로 끊어 버리는 기능 등 고기능을 갖춘 것도 있다.
- 트래픽 증감에 대ㅎ서도 검토해야 한다.

### 애플리케이션 병목 현상 예

- 인프라 측은 스케일업, 스케일아웃 등의 개념을 통해 개선이 가능하지만 애플리케이션 측도 같은 방식으로 확장하지 않으면
애플리케이션 자체가 병목 지점이 되는 경우가 있다.
- 알고리즘의 문제라면 인프라 측 리소스를 아무리 늘려도 애플리케이션 처리량이 높아지지 않거나 응답 속도를 개선할 수 없다.

#### 데이터 갱신의 병목 현상

- 데이터베이스를 이용한 시스템에서 자주 발생하는 것이 특정 데이터에 의존하는 처리가 병목 지점이 되는 것이다.
  - 반드시 재고 개수에서 1을 뺀다 라는 처리
  - 테이블의 특정 레코드를 배타적 제어하도록 구현되기 때문에 병목현상의 원인이 됨
- 실시간으로 해야 하고 엄격하게 해야 하는 경우엔 필수이지만 개선 방법이 있다.
  - 값의 캐시화
    - 별도 서버에 질의를 던지는 것이 병목지점이 된다면 더 가까운 장소에 캐시화하는 것이 일반적 방법
    - 네트워크를 경유하는 질의가 없어지므로 처리 효율이 개선될 수 있지만, 병목 지점이라는 것에는 변함이 없어서 근본적인 해결책은 아님
  - 병목 지점의 분할
    - 재고가 200개 있다고 하면 100개씩 레코드를 분할하여 한 번에 두 개의 처리를 하고 데이터 일치성 문제를 해결함.

#### 외부 질의의 병목 현상

- 시스템 하나로 완성되는 시스템은 거의 없다.
- 대부분의 시스템은 다른 시스템과 데이터 연계 등을 통해 협력할 필요가 있는데 이 부분이 병목 지점이 되는 경우도 많다.

