# 인프라를 지탱하는 기본 이론

---------------

## 직렬/병렬

### 직렬/병렬이란?

- CPU 제조사가 클럭(Clock) 속도를 올리는 대신에 코어 수를 늘려서 소비 전력과 발열 문제를 잡으려 했기에 엔지니어가
병렬 처리를 접할 기회가 이전에 비해 상당히 늘어났다.
- 하지만 무조건 병렬화한다고 해서 성능이 향상되는 것은 아니다.
  - CPU 코어나 서버를 병렬화할 때는 병렬화한 하드웨어를 놀리지 않고 어떻게 효율적으로 활용할지가 중요해진다.
- 도로와 마찬가지로 처리 특성에 따라선 병렬화할 수 있는 것과 없는 것이 있다.
- 병렬 처리를 할 때는 가능한 한 병렬화해서 직렬 부분을 줄이고, 어쩔 수 없이 직렬화해야 하는 경우에는 효율성을 노핑는 것이 중요하다.
- 직렬/병렬의 중요 사항
  - 직렬 처리로 속도를 올리는 데는 한계가 있다.
  - 병렬화하면 속도는 빨라지지 않지만 단위 시간당 처리량이 늘어난다.
    - 벙렬 처리에서는 합류점, 직렬화 구간, 분기점이 병목 지점이 되기 쉽다
    - 병렬화할 때는 일을 분담해서 처리한 후 다시 집약할 때 오버헤드가 걸린다. 따라서 오버헤드를 감안하더라도 효과가 있을 경우에 병렬화를 한다.

### 어디에 사용되나?

#### 웹 서버와 AP 서버에서의 병렬화

- 웹 서버에는 다수의 이용자가 접속하기 때문에 복수의 프로세스가 분담해 병렬 처리(멀티 프로세스)
- AP 서버에서는 JVM 프로세스가 하나이지만 복수의 스레드가 병렬로 처리(멀티 스레드)
  - JVM 프로세스를 복수 가동하면 멀티 프로세스와 멀티 스레드를 이용할 수 있음
- 하나의 CPU 코어를 동시에 사용할 수 있는 것은 1 스레드이기 때문에 하나의 CPU 코어 밖에 없는 서버에서는 스레드를 아무리 늘려도 동시에 실행할 수 있는 것은
1개의 스레드이다.

#### DB 서버에서의 병렬화

- 오라클 DB에서는 클라이언트 요청을 접수하는 서버 프로세스가 클라이언트 접속 수 만큼 생성된다.

### 정리

- 직렬 장점
  - 구조가 간단해서 설계나 구현 난이도가 낮다
- 직렬 단점
  - 복수의 리소스를 유용하게 이용할 수 없다.
- 병렬 장점
  - 복수의 리소스를 유용하게 이용하여 직렬에 비해 동일 시간당 처리할 수 있는 양이 증가.
  - 일부가 고장 나더라도 처리르 계속할 수 있다.
- 병렬 단점
  - 처리 분기나 합류를 위한 오버헤드가 발생
  - 베타적 제어 등을 고려해야하고 구조가 복잡해서 설계나 구현 난이도가 높음
- 병렬화 시의 주의점
  - 병렬 처리에서 합류점, 직렬화 구간, 분기점은 병목 지점이 되기 쉽다.
  - 병렬화는 오버헤드를 필연적으로 불러일으키므로 단점 이상의 효과를 얻을 수 있는 경우에만 병렬화해야 한다.

    
-------------------

## 동기/비동기

### 동기/비동기란?

- 구글 맵이 Ajax(Asynchronous JavaScript + XML)를 사용한 웹 서비스를 다수 공개하면서 '비동기'라는 용어를 접할 기회가 늘어났다.
- 동기
  - 누군가에게 일을 부탁하고 그 일이 끝나기까지 잠자코 기다리는 것
  - 일을 부탁한 후 끝날 때까지 아무것도 하지 않고 기다리기 때문에 그 사이에 다른 일을 할 수 없지만 의뢰한 것이 끝났는지 여부를 확실하게
  확인할 수 있음.
- 비동기
  - 누군가에게 일을 부탁하고 '끝나면 말해'라고 말해 두고 다른 일을 하는 것.
  - 처리를 병행해서 진행할 수 있음.
  - 끝날 때까지 기다리지 않기 때문에 병렬로 다른 일을 할 수 있지만 의뢰한 일이 끝났는지 여부를 확인하고 싶으면 별도의 방법을 이용해야 함

### 어디에 사용되나?

- Ajax가 등장하기 이전에는 링크나 버튼을 클릭할 때마다 화면 전체가 바뀌는 것을 기다려야 했으나, Ajax가 등장한 후에 웹 페이지에서는
비동기 통신이 가능해져서 화면을 보거나 입력하면서 필요한 부분만 갱신할 수 있게 된다.
  - 검색어 후보 표시
    - 키워드를 입력하면 Ajax가 입력 도중인 키워드를 구글 검색 엔진 서버에 전송해서 키워드 후보 데이터를 얻어서 브라우저에 표시
    - 키워드 입력과 키워드 후보 표시를 동시에 병렬로 실행할 수 있음.

#### DBMS에서 사용되는 비동기 I/O

- 비동기 I/O는 대량의 I/O를 효율적으로 처리해야 하는 DBMS에 적합하다.
- DBMS에서 비동기 I/O를 사용하면 쓰기가 끝났는지 확인하지 않고 다음 처리를 진행해도 괜찮나 생각할 수 있지만 DBMS에서는 비동기로 I/O를 요구한 후에 
끝났는지 여부를 확인하고 있다.


### 정리

- 동기 장점
  - 의뢰한 처리가 끝났는지 여부를 쉽게 확인할 수 있어서 구조가 간단하고 구현 난이도도 낮다
- 동기 단점
  - 의뢰한 처리가 끝나기까지 기다려야 하기 때문에 대기 시간을 활용할 수 없다.
- 비동기 장점
  - 의뢰한 처리가 진행되고 있는 동안 시간을 효율적으로 사용해서 병렬 처리를 할 수 있다.
- 비동기 단점
  - 의뢰한 처리가 끝났는지 확인하지 않으면 모르기 때문에 불필요한 확인 처리가 늘어난다.
  - 구조가 복잡해서 구현 난이도가 높다.
- 비동기의 본질은 병렬. 주의점은?
  - 비동기로 요구한 처리가 끝나지 않은 상태에서 다음 처리를 진행해도 문제가 없는가
  - 비동기로 요구한 처리가 끝났는지 확인할 필요가 있는가

-----------------------

## 큐

### 큐란?

- 큐(Queue)는 대기 행렬이라 표현할 수 있다.
- 하드웨어, OS, 데이터베이스, 애플리케이션 등 거의 모든 곳에서 이 구조가 사용되고 있어서 설계나 성능 튜닝 시에 빠질 수 없는 지식.
- 큐의 동작 원리를 FIFO(First In First Out, 선입선출)이라고 한다.

### 어디에 사용되나?

- CPU 처리를 기다리고 있는 프로세스나 스레드 행렬
- 하드 디스크 등의 저장소 읽기 처리를 기다리고 있는 I/O 요구 행렬
- 네트워크 접속 성립을 기다리고 있는 접속 요구 행렬
- CPU를 기다리고 있는 프로세스 행렬을 '런큐(Run-queue)'라고 하며 런큐에 쌓인 프로세스 수를 코어 수로 나눠서 1이라면 문제 없다는 것이 일반적.
  - CPU에서 처리 중인 프로세스를 런큐로 인식할지는 OS 종류에 따라 달라짐
  - 리눅스는 실행 중인 프로세스도 런큐로 인식
- OS 커널에는 프로세스 스케줄러라는 기능이 있어서 런큐 등을 관리한다.

#### 데이터베이스의 디스크 I/O

- 기본적인 개념은 CPU와 비슷하나 약간의 차이가 있다.
- 프로세스 별로 기록하는 HDD 위치가 다르기 때문에 CPU처럼 비어 있다는 이유로 다른 것을 사용할 수 없다.
- 고속 I/O가 요구되는 REDO 로그를 전용 디스크에 두는 것은 마치 계산대에서 특정 상품만 구매할 수 있는 계산대를 만드는 것과 같다.

### 정리

- 큐의 특징은 선두에서부터 순서대로 처리된다는 점.
- 순서대로 처리하고 싶은 경우나 행렬이 생기는 경우는 큐를 사용하는 것이 좋음.

---------------------------

## 배타적 제어

### 배타적 제어란?

- 여러 사람이 공유하는 물건일 경우, 누군가가 그 물건을 사용하고 있으면 다른 사람은 그것을 사용할 수 없다.
- 배타적 제어는 다른 것을 배제하는 제어다.
- 혼자서 사용하는 것을 배타적 제어할 필요 없는 것처럼 컴퓨터에서 직렬 처리에서는 배타적 제어가 필요없다.
- OS나 DBMS는 병렬 처리를 위해 배타적 제어를 사용한다.
- 병렬 처리 시에 각 처리가 서로 관계없이 동작하는 경우에는 배타적 제어가 필요 없지만 대부분은 공유 데이터를 이용하며 부분적으로는
직렬 처리를 사용해야만 되는 경우가 있는데 이때 배타적 제어가 필요하다.
- 배타적 제어의 특징
  - 복수의 처리가 공유 자원(CPU, 메모리, 디스크 등)에 동시에 액세스(주로 갱신)하면 불일치가 발생할 수 있기 때문에
  배타적 제어로 보호해 주어야 한다.
  - 특정 처리가 공유 자원을 이용하고 있는 동안 다른 처리가 이용할 수 없게 해서 불일치가 발생하지 않도록 한다.

### 어디에 사용되나?

#### DBMS에 사용되는 배타적 제어

- 특정 프로세스가 공유 데이터를 변경하고 있는 도중에 다른 프로세스가 해당 공유 데이터를 읽거나 공유 데이터를 동시에 변경하지 못하도록
배타적 제어를 하고 있다.
- DBMS의 배타적 제어에서는 매우 짧은 시간 동안만 락(Lock)을 유지하는 래치(Latch)라는 것이 있어서 CPU에서 의미가 없는 처리를 하면서 대기하는 방식이 있다.
  - 스핀락(Spin-lock)이라고 불림
- 비교적 장시간 락을 유지하도록 큐를 이용해서 관리하는 방식
  - 슬립락(Sleep-lock)

#### OS 커널에 사용되는 배타적 제어

- 리눅스 커널은 빅 커널락(Big Kernel Lock, BKL)이라 불리는 하나의 스핀락으로 유지된다.
- 여러 프로세스나 스레드에서 빅 커널락을 이용해서 경합 처리를 하면, CPU 코어가 여러 개라도 병렬 처리가 안 되고 선행 처리가 끝날 때 까지
기다려야 한다

### 정리

- 배타적 제어를 사용하는 경우
  - 장점
    - 공유 데이터의 일관성을 유지할 수 있음.
  - 단점
    - 병렬 처리가 안됨
- 배타적 제어를 사용하지 않는 경우
  - 장점
    - 병렬로 빠르게 처리 가능
  - 단점
    - 데이터 불일치가 발생할 가능성이 있다

------------------------

## 상태 저장/상태 비저장

### 상태 저장/상태 비저장이란?

- 정보를 많이 가지고 있는 상태 저장(Stateful)은 세분화된 제어가 가능한 반면에 구조가 복잡하다.
  - ssh는 상태 저장 프로토콜
- 상태 비저장(Stateless)은 고기능은 아니지만 간단하다
  - http는 상태 비저장 프로토콜
- '상태'를 가진다는 것은 과거에 부여한 '정보'를 저장해서 계속 활용할 수 있다는 것을 의미한다.

### 자세히 살펴보자

- 상태를 고려하는 것을 '상태 저장', 상태를 고려하지 않는 것을 '상태 비저장'
- 상태 저장은 부여된 정보에 따라 상태가 전이된다.
- 상태 저장 구조를 사용하는 이점은 과거 정보를 가져올 수 있어서 정보에 따른 복잡한 처리를 할 수 있다는 것이고 단점은 약간이나마 시스템 복잡성이 커진다는 점과
있을 수 없는 상태가 된 경우의 대처 등도 생각해야 한다.
- 상태 비저장 구조의 장점은 간단하다는 것이다. 간단한 구조 때문에 성능이나 안정성을 쉽게 향상시킬 수 있지만 과거 정보를 가져올 수 없기 때문에 복잡한 처리가
어렵다.

### 어디에 사용되나?

#### 컴퓨터 내부 구조

- 컴퓨터 내에서는 거의 모든 곳에 상태 저장이 사용되고 있다.
- 프로세스 상태 전이
  - 개시(Created)
  - 실행 가능 상태(Runnable)
  - 실행 상태(Running)
  - 대기 상태(Sleeping)
  - 종료(Terminated)
- 프로세스 처리는 상태 저장 방식.

#### 네트워크 통신 구조

- 브라우저가 HTTP 서버에 접속할 때는 HTTP라 불리는 프로토콜을 사용하는데 기본저긍로 상태 비저장 프로토콜이다.
- 하지만 회원 정보와 같은 상태를 저장해야 하는 경우엔 HTTP에서 세션(Session)이라는 개념을 사용해서 상태 저장 구조를 구현한다.

### 정리

- 상태 저장
  - 상태 전이를 의식해서 처리하며 과거 경위를 이해한 상태에서 응답을 줌
  - 자신의 상태를 이해하기 때문에 요청 내용을 최소화할 수 있음
  - 상태를 관리함으로써 자유로운 처리가 가능해지지만 서버 측 처리가 복잡해져서 리소스 부하가 높아지고 대량의 사용자 요청이 버거워질 수도 있다.
- 상태 비저장
  - 매번 신규 요청이 생성됨
  - 요청과 그에 대한 응답 구조가 간단

-----------------------

## 가변 길이/고정 길이

### 가변 길이/고정 길이란?

- 미리 크기가 정해져 있는 경우를 고정 길이(Fixed-length)
- 정해져 있지 않은 경우를 가변 길이(Variable-length)
- 고정 길이형에서는 넣을 수 있는 위치가 정해져 있기 때문에 새롭게 추가된 데이터도 종류별로 잘 정리가 된다. 하지만 비어있는 공간의 낭비가 있다.
- 가변 길이형에서는 공간을 절약할 수는 있지만 비슷한 종류의 데이터들이 여기 저기에 흩어져 원하는 데이터를 찾는 것이 힘들어진다.
- 고정 길이의 장점은 크기가 정해져 있어 원하는 것에 쉽게 액세스가 가능
- 가변 길이의 장점은 데이터를 꽉 채워서 담을 수 있기에 저장 시의 데이터 크기를 절약할 수 있지만 액세스하는데 고정 길이에 비해 많은 시간이 걸림

### 어디에 사용되나?

- 윈도우즈에서는 일반적으로 NTFS라 불리는 파일 시스템이 사용되고 있는데 각종 파일을 고정 길이로 저장하고 있다.
  - txt 파일 크기:12바이트, 디스크 할당 크기:4096바이트
  - 실제로는 12바이트지만 저장 시에 4096바이트를 사용하고 있다는 것을 의미
- 네트워크에서 데이터를 교환할 때는 패킷이란것을 사용하는데 패킷은 일회용이기 때문에 가변 길이로 데이터를 처리해도 한쪽으로 편중되지 않는다.

### 정리

- 가변 길이
  - 데이터 크기를 매번 변경하는 것
  - 데이터 전체 양이 줄어든다
  - 효율성을 추구함
- 고정 길이
  - 모두 같은 크기를이용해서 처리
  - 크기가 균일해서 관리가 수월
  - 간단한 것을 추구함

-----------------

## 데이터 구조(배열과 연결 리스트)

### 데이터 구조(배열과 연결 리스트)란?

- 배열과 연결 리스트는 모두 데이터를 순차적으로 처리하는 구조이지만, 구조가 다르기 때문에 성능적인 측면도 많이 다르다.
- 배열
  - 같은 크기의 상자를 빈틈없이 나열한 것
  - 몇 번째 상자인지만 알면 해당 상자에 한번에 액세스 가능
  - 중간에 상자를 추가하거나 삭제할 경우 전체 상자를 움직여야 함
- 연결 리스트
  - 상자를 선으로 연결한 것
  - 상자를 찾으려면 끝에서부터 순서대로 하나씩 상자를 확인해야 함.
  - 중간에 상자를 추가하거나 삭제할 경우 선만 바꿔서 연결하면 됨

### 어디에 사용되나?

- 배열이 차례나 색인 같은 형태로 나열돼 있으며 거기에 연결 리스트가 매달려 있는 듯한 해시 테이블로 많이 사용한다.
- SQL 정보 캐시나 OS 커널의 데이터 캐시등의 형태로 사용된다

### 정리

- 배열
  - 장점
    - N번째 요소 탐색이 빠르다
  - 단점
    - 데이터 추가, 삭제가 느리다
- 연결 리스트
  - 장점
    - 데이터 추가, 삭제가 빠르다
  - 단점
    - N번째 요소 탐색이 느리다

------------------

## 탐색 알고리즘(해시/트리 등)

### 탐색 알고리즘(해시/트리 등)이란?

- 해시나 트리는 탐색 알고리즘이 아닌 데이터 구조이지만 효율적 탐색을 위해 사용된다.
- 필요한 때에 필요한 데이터를 신속하게 찾기 위해서는 데이터를 정리해 둘 필요가 있다.
- 데이터를 찾을 때의 데이터 구조와 데이터 저장 방식 특성에 따라 적합한 데이터 정리 방법이 달라진다.

### 어디에 사용되나?

- SQL 튜닝 시에 '풀 스캔(Full scan)으로 돼 있어서 느렸는데, 인덱스를 생성해서 인덱스 스캔(Index sacn)하니까 빨라졌어'
- 디스크에서 원하는 데이터를 얼마나 적은 노력으로 추출하느냐가 관건으로 인덱스는 이를 위한 하나의 수단에 불과하다.

