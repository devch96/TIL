# 배열

- 자료구조는 크게 메모리 공간 기반의 연속 방식과 포인터 기반의 연결 방식으로 나뉨
- 배열은 연속 방식의 가장 기본이 되는 자료형
- 배열은 크기를 지정하고 해당 크기만큼의 연속된 메모리 공간을 할당받는 작업을 수행하는 자료형을 말함
    - 크기가 고정되어 있으며 생성한 배열의 크기를 변경하는 것은 불가능
- 배열은 어느 위치나 O(1)에 조회가 가능하다는 장점이 있음
- 배열에서 4번째 값에 접근하고 싶다면 int 배열이므로 각각 4바이트 즉 (4 - 1) * 4 = 12가 되고 0x00에서 시작해 12만큼 증가한 16진수는 0x0C

----------

## 동적 배열

- 실제 데이터에서는 전체 크기를 가늠하기 힘들 때가 많기에 크기를 지정하지 않고 자동으로 리사이징하는 배열
    - 자바에서는 ArrayList, C++에서는 std::vector
- 동적 배열의 원리는 미리 초기값을 작게 잡아 배열을 생성하고, 데이터가 추가되면서 꽉 채워지면 늘려주고 모두 복사하는 식
    - 더블링(Doubling)이라 하여 2배씩 늘려줌
    - 모든 언어가 그러는 것은 아님
- ArrayList는 초깃값으로 크기가 10인 배열을 설정하고, 값으로 공간이 가득 차면 더블링으로 늘려줌
    - 명칭은 더블링이지만 정확히 2배를 늘려주는 것은 아니며 재할당 비율은 그로스 팩터(성장 인자)
    - int newCapacity = oldCapacity + (oldCapacity >> 1); 1.5배
- 동적 배열은 정적 배열과 달리 크기를 지정할 필요가 없어 매우 편리하며 조회 또한 기존의 배열과 동일하게 O(1)에 가능
- 더블링이 필요할 만큼 공간이 차면 새로운 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업이 필요하므로 O(n) 비용 발생

---------

## 두 수의 합

- 덧셈하여 타깃을 만들 수 있는 배열의 두 숫자 인덱스를 리턴하라

### 브루트 포스로 계산

- 배열을 두 번 반복하면서 모든 조합을 더해서 일일이 확인해보는 무차별 대입 방식인 브루트 포스 방식
- O(n^2)
- 비효율적

```java
public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for(int j = i + 1; j < nums.length; j++) {
            if(nums[i] + nums[j] == target) {
                return new int[] {i,j};
            }
        }
    }
    return null;
}
```

### 풀이 2) 첫 번째 수를 뺀 결과 키 조회

- target 변수에서 첫 번째 수를 빼면 두 번째 수를 바로 알아낼 수 있음
- 두 번째 수를 키로 하고 기존의 인덱스는 값으로 바꿔서 맵으로 저장해두면 나중에 두 번째 수를 키로 조회해서 정답을 즉시 찾아낼 수 있음
- 주의해야 할 부분은 현재 인덱스를 정답으로 착각할 수 있다는 점

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> numsMap = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        numsMap.put(nums[i], i);
    }

    for (int i = 0; i < nums.length; i++) {
        if (numsMap.containsKey(target - nums[i]) && i != numsMap.get(target - nums[i])) {
            return new int[] {i, numsMap.get(target - nums[i])};
        }
    }
    return null;
}
```

### 풀이 3) 조회 구조 개선

- 맵 저장과 조회를 2개의 for 문으로 각각 처리했던 방식을 좀 더 개선
- 동일한 O(n)에서 약간의 차이만 있을 뿐 성능상 큰 이점은 없음

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> numsMap = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (numsMap.containsKey(target - nums[i])) {
            return new int[] {i, numsMap.get(target - nums[i])};
        }

        numsMap.put(nums[i], i);
    }

    return null;
}
```

### 풀이 4) 투 포인터 이용

- 투 포인터란 왼쪽 포인터와 오른쪽 포인터의 합이 타깃보다 크다면 오른쪽 포인터를 왼쪽으로, 작다면 왼쪽 포인터를 오른쪽으로 옮기면서
  값을 조정하는 방식
- 하지만 이 문제는 풀 수 없음
    - 정렬된 입력값이 아니기 때문

### 풀이 5) 코틀린 풀이


```kotlin
fun twoSum(nums: IntArray, target: Int): IntArray {
    val numsMap: MutableMap<Int, Int> = mutableMapOf()

    for((i, num) in nums.withIndex()) {
        if (numsMap.containsKey(target - num)) {
            return intArrayOf(numsMap[target-num] ?: 0, i)
        }
        numsMap[num] = i
    }
    return intArrayOf(0,0)
}
```

----------

## 빗물 트래핑

- 높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라

### 풀이 1) 투 포인터를 최대로 이동

- 높이와 너비 모든 공간을 차례대로 모두 살펴보면 O(n^2)
- 투 포인터나 스택으로 O(n)이 가능
- 막내는 높고 낮음에 무관하게 전체 부피에 영향을 끼치지 않으면서 그저 왼쪽과 오른쪽을 가르는 장벽 역할을 함
- 최대 높이의 막대까지 각각 좌우 막대 최대 높이가 현재 높이와의 차이만큼 물 높이를 더해 나감
- 좌우 어느쪽이든 낮은 쪽은 높은 쪽을 향해서 포인터가 가운데로 점점 이동함

```java
public int trap(int[] height) {
    int volume = 0;
    int left = 0;
    int right = height.length - 1;
    int leftMax = height[left];
    int rightMax = height[right];

    while (left < right) {
        leftMax = Math.max(height[left], leftMax);
        rightMax = Math.max(height[right], rightMax);

        if (leftMax <= rightMax) {
            volume += leftmax - height[left];
            left += 1;
        } else {
            volume += rightMax - height[right];
            right -= 1;
        }
    }
    return volume;
}
```

### 풀이 2) 스택 쌓기

- 스택에 쌓아 낳아가면서 현재 높이가 이전 높이보다 높을 때를 기준으로 격차만큼 물이 쌓이는 양을 채움
- 이전 높이는 고정된 형태가 아니라 들쑥날쑥하기 때문에 스택으로 채워나가다가 변곡점을 만날 때마다 스택에서 하나씩 꺼내면서
  이전과의 차이만큼 물이 쌓이는 양을 채워나감

```java
public int[] trap(int[] height) {
    Deque<Integer> stack = new ArrayDeque<>();
    int volume = 0;

    for (int i = 0; i < height.length; i++) {
        // 변곡점을 만나는 경우
        while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
            // 스택에서 꺼냄
            Integer top = stack.pop();
            if(stack.isEmpty()) {
                break;
            }
            // 스택의 마지막 위치까지를 거리로 계산
            int distance = i - stack.peek() - 1;
            // 현재 높이 또는 스택의 마지막 위치 높이 중 낮은 값에 방금 꺼낸 높이의 차이를 물 높이로 지정
            int waters = Math.min(height[i], height[stack.peek()]) - height[top];
            
            volume += distance * waters;
        }
        stack.push(i);
    }
    return volume;
}
```

### 풀이 3) 코틀린 풀이

```kotlin
fun trap(height: IntArray): Int {
    var volume = 0
    var left = 0
    var right = height.size - 1
    var leftMax = height[left]
    var rightMax = height[right]
    
    while (left < right) {
        leftMax = height[left].coerceAtLeast(leftMax)
        rightMax = height[right].coerceAtLeast(rightMax)
        
        if (leftMax <= rightMax) {
            volume += leftMax - height[left]
            left += 1
        } else {
            volume += rightMax - height[right]
            right -= 1
        }
    }
    return volume
}
```

- 자바의 Math.max는 coerceAtLeast()
  - 이 함수는 파라미터보다 값이 커야 함을 뜻함
  - 파라미터의 값이 더 크다면 그 값을 리턴하기에 두 값 중 큰 값을 취하는 Math.max()와 같은 역할을 함

------------

## 세 수의 합

- 배열을 입력받아 합으로 0을 만들 수 있는 3개의 엘리먼트를 출력하라

### 풀이 1) 브루트 포스로 계산

- 브루트 포스 풀이에는 중복된 값이 있을 수 있으므로 continue로 건너뜀

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new LinkedList<>();
    Arrays.sort(nums);
    
    for (int i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        for (int j = i + 1; j < nums.length - 1; j++) {
            if(j > i + 1 && nums[j] == nums[j-1]) {
                continue;
            }
            for(int k = j + 1; k < nums.length; k++) {
                if (k > j + 1 && nums[k] == nums[k-1]) {
                    continue;
                }
                if(nums[i] + nums[j] + nums[k] == 0) {
                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));
                }
            }
        }
    }
    return result;
}
```

### 풀이 2) 투 포인터로 합 계산

- 정렬한 다음에 i를 축으로 하고 중복된 값을 건너뛰게 한 부분은 동일하지만 중복이 아닌 경우 투 포인터로 풀이 가능
- 정렬을 한 다음 sum이 기준값보다 낮으면 left++, 기준값보다 높으면 right--

```java
public List<List<Integer>> threeSum(int[] nums) {
    int left, right, sum;
    List<List<Integer>> results = new ArrayList<>();
    Arrays.sort(nums);
    
    for(int i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] == nums[i-1]) {
            continue;
        }
        left = i + 1;
        right = nums.length - 1;
        while ( left < right) {
            sum = nums[i] + nums[left] + nums[right];
            if (sum < 0) {
                left++;
            } else if(sum > 0) {
                right--;
            } else {
                results.add(Arrays.asList(nums[i], nums[left], nums[right]));
                while(left < right && nums[left] == nums[left + 1]) {
                    left += 1;
                }
                while(left < right && nums[right] == nums[right-1]) {
                    right -= 1;
                }
                left += 1;
                right -= 1;
            }
        }
    }
    return results;
}
```