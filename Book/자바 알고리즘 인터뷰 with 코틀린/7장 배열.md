# 배열

- 자료구조는 크게 메모리 공간 기반의 연속 방식과 포인터 기반의 연결 방식으로 나뉨
- 배열은 연속 방식의 가장 기본이 되는 자료형
- 배열은 크기를 지정하고 해당 크기만큼의 연속된 메모리 공간을 할당받는 작업을 수행하는 자료형을 말함
    - 크기가 고정되어 있으며 생성한 배열의 크기를 변경하는 것은 불가능
- 배열은 어느 위치나 O(1)에 조회가 가능하다는 장점이 있음
- 배열에서 4번째 값에 접근하고 싶다면 int 배열이므로 각각 4바이트 즉 (4 - 1) * 4 = 12가 되고 0x00에서 시작해 12만큼 증가한 16진수는 0x0C

----------

## 동적 배열

- 실제 데이터에서는 전체 크기를 가늠하기 힘들 때가 많기에 크기를 지정하지 않고 자동으로 리사이징하는 배열
    - 자바에서는 ArrayList, C++에서는 std::vector
- 동적 배열의 원리는 미리 초기값을 작게 잡아 배열을 생성하고, 데이터가 추가되면서 꽉 채워지면 늘려주고 모두 복사하는 식
    - 더블링(Doubling)이라 하여 2배씩 늘려줌
    - 모든 언어가 그러는 것은 아님
- ArrayList는 초깃값으로 크기가 10인 배열을 설정하고, 값으로 공간이 가득 차면 더블링으로 늘려줌
    - 명칭은 더블링이지만 정확히 2배를 늘려주는 것은 아니며 재할당 비율은 그로스 팩터(성장 인자)
    - int newCapacity = oldCapacity + (oldCapacity >> 1); 1.5배
- 동적 배열은 정적 배열과 달리 크기를 지정할 필요가 없어 매우 편리하며 조회 또한 기존의 배열과 동일하게 O(1)에 가능
- 더블링이 필요할 만큼 공간이 차면 새로운 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업이 필요하므로 O(n) 비용 발생

---------

## 두 수의 합

- 덧셈하여 타깃을 만들 수 있는 배열의 두 숫자 인덱스를 리턴하라

### 브루트 포스로 계산

- 배열을 두 번 반복하면서 모든 조합을 더해서 일일이 확인해보는 무차별 대입 방식인 브루트 포스 방식
- O(n^2)
- 비효율적

```java
public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for(int j = i + 1; j < nums.length; j++) {
            if(nums[i] + nums[j] == target) {
                return new int[] {i,j};
            }
        }
    }
    return null;
}
```

### 풀이 2) 첫 번째 수를 뺀 결과 키 조회

- target 변수에서 첫 번째 수를 빼면 두 번째 수를 바로 알아낼 수 있음
- 두 번째 수를 키로 하고 기존의 인덱스는 값으로 바꿔서 맵으로 저장해두면 나중에 두 번째 수를 키로 조회해서 정답을 즉시 찾아낼 수 있음
- 주의해야 할 부분은 현재 인덱스를 정답으로 착각할 수 있다는 점

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> numsMap = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        numsMap.put(nums[i], i);
    }

    for (int i = 0; i < nums.length; i++) {
        if (numsMap.containsKey(target - nums[i]) && i != numsMap.get(target - nums[i])) {
            return new int[] {i, numsMap.get(target - nums[i])};
        }
    }
    return null;
}
```

### 풀이 3) 조회 구조 개선

- 맵 저장과 조회를 2개의 for 문으로 각각 처리했던 방식을 좀 더 개선
- 동일한 O(n)에서 약간의 차이만 있을 뿐 성능상 큰 이점은 없음

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> numsMap = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (numsMap.containsKey(target - nums[i])) {
            return new int[] {i, numsMap.get(target - nums[i])};
        }

        numsMap.put(nums[i], i);
    }

    return null;
}
```

### 풀이 4) 투 포인터 이용

- 투 포인터란 왼쪽 포인터와 오른쪽 포인터의 합이 타깃보다 크다면 오른쪽 포인터를 왼쪽으로, 작다면 왼쪽 포인터를 오른쪽으로 옮기면서
  값을 조정하는 방식
- 하지만 이 문제는 풀 수 없음
    - 정렬된 입력값이 아니기 때문

### 풀이 5) 코틀린 풀이


```kotlin
fun twoSum(nums: IntArray, target: Int): IntArray {
    val numsMap: MutableMap<Int, Int> = mutableMapOf()

    for((i, num) in nums.withIndex()) {
        if (numsMap.containsKey(target - num)) {
            return intArrayOf(numsMap[target-num] ?: 0, i)
        }
        numsMap[num] = i
    }
    return intArrayOf(0,0)
}
```

----------

## 빗물 트래핑

- 높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라

### 풀이 1) 투 포인터를 최대로 이동

- 높이와 너비 모든 공간을 차례대로 모두 살펴보면 O(n^2)
- 투 포인터나 스택으로 O(n)이 가능
- 막내는 높고 낮음에 무관하게 전체 부피에 영향을 끼치지 않으면서 그저 왼쪽과 오른쪽을 가르는 장벽 역할을 함
- 최대 높이의 막대까지 각각 좌우 막대 최대 높이가 현재 높이와의 차이만큼 물 높이를 더해 나감
- 좌우 어느쪽이든 낮은 쪽은 높은 쪽을 향해서 포인터가 가운데로 점점 이동함

```java
public int trap(int[] height) {
    int volume = 0;
    int left = 0;
    int right = height.length - 1;
    int leftMax = height[left];
    int rightMax = height[right];

    while (left < right) {
        leftMax = Math.max(height[left], leftMax);
        rightMax = Math.max(height[right], rightMax);

        if (leftMax <= rightMax) {
            volume += leftmax - height[left];
            left += 1;
        } else {
            volume += rightMax - height[right];
            right -= 1;
        }
    }
    return volume;
}
```

### 풀이 2) 스택 쌓기

- 스택에 쌓아 낳아가면서 현재 높이가 이전 높이보다 높을 때를 기준으로 격차만큼 물이 쌓이는 양을 채움
- 이전 높이는 고정된 형태가 아니라 들쑥날쑥하기 때문에 스택으로 채워나가다가 변곡점을 만날 때마다 스택에서 하나씩 꺼내면서
  이전과의 차이만큼 물이 쌓이는 양을 채워나감

```java
public int[] trap(int[] height) {
    Deque<Integer> stack = new ArrayDeque<>();
    int volume = 0;

    for (int i = 0; i < height.length; i++) {
        // 변곡점을 만나는 경우
        while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
            // 스택에서 꺼냄
            Integer top = stack.pop();
            if(stack.isEmpty()) {
                break;
            }
            // 스택의 마지막 위치까지를 거리로 계산
            int distance = i - stack.peek() - 1;
            // 현재 높이 또는 스택의 마지막 위치 높이 중 낮은 값에 방금 꺼낸 높이의 차이를 물 높이로 지정
            int waters = Math.min(height[i], height[stack.peek()]) - height[top];

            volume += distance * waters;
        }
        stack.push(i);
    }
    return volume;
}
```

### 풀이 3) 코틀린 풀이

```kotlin
fun trap(height: IntArray): Int {
    var volume = 0
    var left = 0
    var right = height.size - 1
    var leftMax = height[left]
    var rightMax = height[right]

    while (left < right) {
        leftMax = height[left].coerceAtLeast(leftMax)
        rightMax = height[right].coerceAtLeast(rightMax)

        if (leftMax <= rightMax) {
            volume += leftMax - height[left]
            left += 1
        } else {
            volume += rightMax - height[right]
            right -= 1
        }
    }
    return volume
}
```

- 자바의 Math.max는 coerceAtLeast()
    - 이 함수는 파라미터보다 값이 커야 함을 뜻함
    - 파라미터의 값이 더 크다면 그 값을 리턴하기에 두 값 중 큰 값을 취하는 Math.max()와 같은 역할을 함

------------

## 세 수의 합

- 배열을 입력받아 합으로 0을 만들 수 있는 3개의 엘리먼트를 출력하라

### 풀이 1) 브루트 포스로 계산

- 브루트 포스 풀이에는 중복된 값이 있을 수 있으므로 continue로 건너뜀

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new LinkedList<>();
    Arrays.sort(nums);

    for (int i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        for (int j = i + 1; j < nums.length - 1; j++) {
            if(j > i + 1 && nums[j] == nums[j-1]) {
                continue;
            }
            for(int k = j + 1; k < nums.length; k++) {
                if (k > j + 1 && nums[k] == nums[k-1]) {
                    continue;
                }
                if(nums[i] + nums[j] + nums[k] == 0) {
                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));
                }
            }
        }
    }
    return result;
}
```

### 풀이 2) 투 포인터로 합 계산

- 정렬한 다음에 i를 축으로 하고 중복된 값을 건너뛰게 한 부분은 동일하지만 중복이 아닌 경우 투 포인터로 풀이 가능
- 정렬을 한 다음 sum이 기준값보다 낮으면 left++, 기준값보다 높으면 right--

```java
public List<List<Integer>> threeSum(int[] nums) {
    int left, right, sum;
    List<List<Integer>> results = new ArrayList<>();
    Arrays.sort(nums);

    for(int i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] == nums[i-1]) {
            continue;
        }
        left = i + 1;
        right = nums.length - 1;
        while ( left < right) {
            sum = nums[i] + nums[left] + nums[right];
            if (sum < 0) {
                left++;
            } else if(sum > 0) {
                right--;
            } else {
                results.add(Arrays.asList(nums[i], nums[left], nums[right]));
                while(left < right && nums[left] == nums[left + 1]) {
                    left += 1;
                }
                while(left < right && nums[right] == nums[right-1]) {
                    right -= 1;
                }
                left += 1;
                right -= 1;
            }
        }
    }
    return results;
}
```

### 풀이 3) 코틀린 풀이

```kotlin
fun threeSum(nums: IntArray): List<List<Int>> {
    var left: Int
    var right: Int
    var sum: Int
    val result: MutableList<List<Int>> = mutableListOf()
    Arrays.sort(nums)
    
    for(i in 0 until nums.size - 2) {
        if (i > 0 && nums[i] == nums[i-1]) {
            continue
        }
        left = i + 1
        right = nums.size - 1
        while(left < right) {
            sum = nums[i] + nums[left] + nums[right]
            if(sum < 0) {
                left+=1
            } else if(sum > 0) {
                right-=1
            } else {
                result.add(listOf(nums[i], nums[left], nums[right]))
                while (left < right && nums[left] == nums[left+1]) {
                    left += 1
                }
                while (left < right && nums[right] == nums[right-1]) {
                    right -= 1
                }
                left += 1
                right -= 1
            }
        }
    }
    return result
}
```

- MutableList는 List를 상속받기 때문에 리턴 타입이 List 일때 MutableList를 리턴하는것이 가능
  - 반대는 불가능

-----------

## 배열 파티션 I

- n개의 페어를 이용한 min(a,b)의 합으로 만들 수 있는 가장 큰 수를 출력하라

### 풀이 1) 오름차순 풀이

- 페어의 min()을 합산했을 때 최대가 되려면 결국 각각의 min()이 가급적 커야한다는 뜻이고 뒤에서부터 내림차순으로 집어넣으면
항상 최대의 min() 페어를 유지할 수 있다

```java
public int arrayPartiSum(int[] nums) {
    int sum = 0;
    Arrays.sort(nums);
    List<Integer> pair = new ArrayList<>();
    
    for (int n : nums) {
        pair.add(n);
        if(pair.size() == 2) {
            sum += Collections.min(pair);
            pair.clear();
        }
    }
    return sum;
}
```

### 풀이 2) 짝수 번째 값 계산

- 페어에 대해 일일이 min() 값을 구하지 않아도 짝수 번째 인덱스(인덱스는 0 부터 시작)의 값을 더하면 됨
- 정렬도니 상태에서는 짝수 번째에 항상 작은 값이 위치하기 때문

```java
public int arrayPartiSum(int[] nums) {
    int sum = 0;
    Arrays.sort(nums);
    for(int i = 0; i < nums.length; i++) {
        if(i%2==0) {
            sum+=nums[i];
        }
    }
    return sum;
}
```

### 풀이 3) 코틀린 풀이

```kotlin
fun arrayPartiSum(nums: IntArray): Int {
    var sum = 0
    nums.sort()
    for((i,n) in nums.withIndex()) {
        if(i % 2 == 0) {
            sum += n
        }
    }
    return sum;
}
```

---------

## 자신을 제외한 배열의 곱

- 배열을 입력받아 output[i]가 자신을 제외한 나머지 모든 엘리먼트의 곱셈 결과가 되도록 출력하라
- 나눗셈을 하지 않고 O(n)에 풀이하라

### 풀이 1) 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱하기

- 미리 전체 곱셈 값을 구해놓고 각 항목별로 자기 자신을 나눠서 풀이하는 방법은 안됨
- 자기 자신을 제외하고 왼쪽의 곱셈 결과와 오른쪽의 곱셈 결과를 곱하는 방법

```java
public int[] productExceptSelf(int[] nums) {
    int[] result = new int[nums.length];
    int p = 1;
    for (int i = 0; i < nums.length; i++) {
        result[i] = p;
        p *= nums[i];
    }
    p = 1;
    for (int i = nums.length - 1; i >= 0; i--) {
        result[i] *= p;
        p *= nums[i];
    }
    return result;
}
```

### 풀이 2) 코틀린 풀이

```kotlin
fun productExceptSelf(nums: IntArray): IntArray {
    val result= IntArray(nums.size)
    var p = 1
    for(i in nums.indices) {
        result[i] = p
        p *= nums[i]
    }
    p = 1
    for(i in numsindices.reversed()) {
        result[i] *= p
        p *= nums[i]
    }
    return result
}
```

----------

## 주식을 사고팔기 가장 좋은 시점

- 한 번의 거래로 낼 수 있는 최대 이익을 산출하라

### 풀이 1) 브루트 포스로 계산

```java
public int maxProfit(int[] prices) {
    int maxProfit = 0;
    for (int i = 0; i < prices.length; i++) {
        for (int j = i+1; j<prices.length; j++) {
            maxProfit = Math.max(maxProfit, prices[j] - prices[i]);
        }
    }
    return maxProfit;
}
```

### 풀이 2) 저점과 현재 값과의 차이 계산

- 현재 값을 가리키는 포인터가 우측으로 이동하면서 이전 상태의 저점을 기준으로 가격 차이를 계산하고 만약 가격이 클 경우
최댓값을 계속 교체해 나가는 형태로 O(n) 풀이가 가능

```java
public int maxProfit(int[] prices) {
    int maxProfit = 0;
    int minPrice = prices[0];
    for(int price : prices) {
        // 지금까지의 저점 계산
        minPrice = Math.min(minPrice, price);
        // 현재 값과 저점의 차이가 최대 이익인 경우 교체
        maxProfit = Math.max(maxProfie, price - minPrice);
    }
    return maxProfit;
}
```

### 풀이 3) 코틀린 풀이

```kotlin
fun maxProfit(prices: IntArray): Int {
    var maxProfit = 0
    var minPrice = prices[0]
    for(price in prices) {
        minPrice = minPrice.coerceAtMost(price)
        maxProfit = maxProfit.coerceAtLeast(price-minPrice)
    }
    
    return maxProfit
}
```