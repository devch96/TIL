# 자바, 세상에서 가장 유명한 언어

--------

- 모두 다 함께 아는 언어로 얘기하는 것이 무엇보다도 중요함
  - 자바는 지난 30여 년간 세상에서 가장 인기 있는 언어

----------

## 자바의 역사

- 자바는 `한 번 만들면 어디에서나 동작한다(WORA:Write Once, Run Anywhere)` 라는 슬로건과 함께 1996년에 첫 정식 버전을 발표했음
- WORA는 한 번 컴파일된 자바 코드는 다른 플랫폼에서 다시 컴파일할 필요 없이 동작한다는 의미
  - 윈도우에서 컴파일한 자바 코드가 리눅스에서도 바로 돌아간다는 뜻
- 1998년에는 자바2(1.2)가 등장하면서 도약함
  - 자바 컬렉션 프레임워크가 등장
- 이후 자바는 5버전에서 제네릭, 오토박싱 등 대대적인 기능 향상과 함께 훨씬 더 편리한 언어로 진화함
  - 이 즈음 스프링 프레임워크가 등장하면서 웹 애플리케이션을 구축하는 데 널리 사용되기 시작함
- 자바 6 버전에 이르러 자바 생태계는 2가지 큰 변화를 맞이함
  - 자바를 개발한 썬 마이크로시스템즈가 오라클에 합병됨
  - 안드로이드 모바일 운영체제가 등장하면서 자바를 공식 언어로 채택
- 2011년에는 자바 7 등장
- 2014년에 등장한 8 버전에는 함수형 언어의 특징을 대대적으로 도입해 문법에 큰 변화를 가져옴

-------------

## 자바의 주요 특징

- C는 대표적 절차형 프로그래밍 언어로, 큰 규모의 프로그램을 개발할 때는 코드가 지나치게 복잡해지고 가독성이 떨어져 객체 지향 프로그래밍의 개념을 탑재해
만들어진것이 자바
- OOP의 첫 번째 원칙은 바로 캡슐화(Encapsulation)로 변수와 함수를 클래스라는 단위로 묶어 따로 분리해서 처리하는 개념
  - 클래스 개념 덕분에 반복되는 부분을 최소화해 단위별로 개발할 수 있게 됐으며 깨끗하고 유지보수하기 쉽고 안전하며 재사용이 가능한 코드를
  만들 수 있게 됨
- 클래스 개념을 C에 도입한 것이 C with Classes라는 이름의 언어이며 이 언어는 C++로 이름을 바꾸게 됨

### 객체 지향 프로그래밍 언어

- 자바는 WORA 원칙 덕분에 플랫폼에 독립적이어서 개발하기 편했으며 OOP 언어라는 점에서 복잡한 문제를 쉽게 처리할 수 있었기에 처음 등장하자마자 
인기를 끌었음
- OOP는 모듈식 구조를 제공하므로 큰 규모의 프로그램을 개발할 때 더욱 유리하기에 대규모 프로젝트에 자바가 채택되기 시작함
- 그러나 자바는 OOP를 너무 강조한 나머지 코드가 지나치게 장황하며 문법 또한 복잡함
  - 큰 규모는 괜찮으나 작은 프로젝트 또는 간결하게 구현해야 하는 코딩 테스트에서 불리하게 작용
- 숫자를 키보드 입력으로 받는 코드
  - 자바가 훨씬 장황함
```
// C 언어
scnaf("%d", &num)

// 자바
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
try {
    int num = Integer.parseInt(br.readLine());
} catch (IOException e) {
     throw new RuntimeException(e);
 }
```

- 실제로도 코딩 테스트에서는 자바의 OOP 개념을 사용할 일이 거의 없음
  - 절차적인 방식으로 작성하는 것이 문제 풀이에 훨씬 더 유리
  - 8 버전부터 등장한 함수형 프로그래밍 개념을 활용하는 편이 더 유용
#### OOP의 4가지 특징
  - 캡슐화
    - 속성과 행위를 외부와 분리
    - 속성을 변수, 행위를 메소드, 캡슐을 클래스에 빗댐
    - 외부 코드가 데이터에 직접 접근하지 못하도록 방어막 역할을 하고 내부 상태는 private, 외부에는 public 메서드를 노출하여 정보를 은닉할 수있음
      - 느슨한 결합이 가능
      - 내부에서 변수명을 변경하는 등의 변화가 있어도 외부 메소드는 변함이 없기 때문에 의존성이 낮고 모듈 수정이 비교적 자유로움
    - Setter/Getter 메서드
    - 캡슐화를 구현하기 위해서는 여러 방식으로 접근을 제어(접근 제어자 제공)
  - 추상화
    - 복잡한 시스템에서 핵심적인 개념 또는 기능을 간추려내는 것을 추상화라고 함
    - 수행하는 방법이 아니라 수행하는 일 자체에 집중해 복잡도를 낮추는 것
    - 추상화를 잘못 쓰면 심하게 복잡해짐
      - FizzBuzz Enterprise Edition
    - 추상화가 지나치면 오히려 코드를 이해하기 어렵고 활용하기는 훨씬 더 어려움
  - 상속
    - 한 객체를 또 다른 객체가 이어받는 것
  - 다형성
    - 경우에 따라 객체가 다르게 동작하거나 어떤 동작을 다른 방법으로 동작하게 하는 개념
      - 메서드 오버로딩, 메서드 오버라이딩
      - 오버로딩은 이름은 같지만 파라미터가 다른 메서드
      - 오버라이딩은 상속을 받아서 메서드를 재정의
#### 접근 제어자
  - public: 어디서든 접근 할 수 있음.
  - private: 클래스 내에서만 접근할 수 있음
  - protected: 상속받은 클래스이거나 같은 패키지에서만 접근할 수 있음
  - default: 접근 제어자를 부여하지 않으면 디폴드가 되며 같은 패키지에서만 접근할 수 있음

#### 제네릭, 더 안전한 코드로
  - 제네릭이란 클래스나 메서드에서 사용할 자료형을 컴파일 타임에 미리 지정하는 방식을 말함
    - 컴파일 시점에 타입 검사를 할 수 있게 되어 객체의 타입 안정성을 높일 수 있으며 타입 변환 시에도 자동으로 검사를 수행할 수 있음
  - 제네릭 이전에는 리스트 반복시 일일이 인덱스를 지정해야 했지만 이후에는 강화된 루프문을  사용할 수 있음
  - 제네릭 등장 초기에는 변수뿐만 아니라 객체에도 타입 선언을 했어야 하나 불필요하게 코드가 길어지면 실수할 가능성이 높기에 자바 7에서는 이를 개선한
  다이아몬드 연산자가 도입됨
    - 변수 선언에만 타입을 기술하고 객체에는 타입 선언을 생략

### 함수형 프로그래밍 언어

- 자바 8 버전이 등장하면서 객체 지향과 함수형의 장점을 고루 갖춘 혁신적인 언어로 거듭남
- OOP 개념들은 코딩 테스트에서 활용하기 어렵지만 함수형 언어 개념은 코딩 테스트에도 매우 유용함

#### 람다 표현식
- 코딩 테스트에서 가장 유용한 것은 람다 표현식
- 함수형 인터페이스를 매우 적은 코딩으로 간결하게 구현할 수 있음
- (파라미터) -> 내용
- 함수형 인터페이스란 추상 메서드를 하나만 갖는 인터페이스를 일컬으며 기존에는 익명 클래스를 생성해 메서드명을 기입하고 사용해야 했으나
  람다 표현식을 사용하면 간단하게 구현할 수 있음
```java
@FunctionalInterface
interface MathInterface {
    double getPiValue();
}

MathInterface math = new MathInterface() {
    @Override
    public double getPiValue() {
        return 3.141592;
    }
}
System.out.println("Pi: " + math.getPiValue());

MathInterface math = () -> 3.141592;
System.out.println("Pi: " + math.getPiValue());
```

- 람다 표현식은 정렬을 구현할 때 유용함

```java
class Member {
    String name;
    int age;
    
    public Member(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

List<Member> members = new ArrayList<>();
members.add(new Member("윈터", 23));
members.add(new Member("카리나", 24));
members.add(new Member("닝닝", 22));

// 정렬을 익명 클래스로 구현
Collections.sort(members, new Comparator<Member>() {
    @Override
    public int compare(Member o1, Member o2) {
        return o2.age - o1.age;
  }
})

// 정렬을 람다 표현식으로 구현
members.sort((o1, o2) -> o2.age - o1.age);
```

#### 스트림 API

- 자바 8에서는 메서드 참조와 함께 스트림 API라는 혁신적인 기능을 소개
  - 컬렉션 내에서 해결하지 못하고 외부 클래스에 의존해야 했던 기능을 스트림 파이프라인을 구성해 처리할 수 있게 됐고, 번거로운
  처리 작업은 함수형 인터페이스와 람다 표현식, 메서드 참조를 통해 매우 편리하게 처리할 수 있게 됨
- 번거로운 반복 작업을 몇 줄의 코드로 간결하게 처리할 수 있게 해주기 때문에 코딩 테스트에서도 유용

```java
class Member {
    String name;
    int age;
    
    public Member(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

List<Member> members = new ArrayList<>();
members.add(new Member("윈터", 23));
members.add(new Member("카리나", 24));
members.add(new Member("닝닝", 22));

// 스트림 API를 사용하지 않은 예전 방식
List<String> chosenMembers = new ArrayList<>();

for(Member member : members) {
    if (member.age == 24) {
        chosenMembers.add(member.name);
    }
}
// chosenMembers 정렬
Collections.sort(chosenMembers);
// chosenMembers 출력
for (String name : chosenMembers) {
    System.out.println(name);
}

// 스트림 API 사용 방식
member.stream()
.filter(m -> m.age == 24) // 24세 필터링
        .map(m -> m.name) // 이름 매핑
        .sorted() // 정렬
.collect(Collectors.toList()) // 리스트로 취함
        .forEach(System.out::println) // 메서드 참조로 출력
```

- forEach() 메서드로 리스트의 내용을 순회할 수 있으며 collect()는 생략 가능
- 컬렉션의 내용을 메서드 참조로 바로 출력하므로 별도의 변수 선언이 필요 없음
- System.out::println 은 메서드 참조이고, 메서드 참조란 특정 메서드의 참조를 파라미터로 전달하는것
  - 자바의 기본 제공 메서드뿐만 아니라 직접 만든 메서드도 얼마든지 사용 가능

```java
List<Double> numbers = Arrays.asList(49.1, 25.5, 9.9);

// 람다 표현식
numbers.stream()
.map(n -> Math.round(n))
        .forEach(n -> System.out.println(n));

// 메서드 참조
numbers.stream()
.map(Math::round)
.forEach(Ssytem.out::println);
```

---------

## 자바의 도구

### 즉시 실행 가능한 JShell

- 자바 9 버전에서 JShell이 처음 등장하면서 REPL 환경을 사용할 수 있게 됨
  - REPL이란 Read-Eval-Print Loop의 약어
  - 입력하고 실행하고 출력하는 과정을 반복하면서 결과를 실시간으로 확인할 수 있는 상호작용 환경
  - TDD 방식으로 접근이 어려운 코딩 테스트에서 REPL 환경은 사실상 가장 자주 쓰는 디버깅 환경
- JShell은 터미널에서 jshell만 입력하면 간단히 실행되므로 매우 쉬움
- 기본적인 패키지는 이미 임포트가 되어 있으므로 java.util.* 를 굳이 새롭게 임포트할 필요가 없음
- Jshell 명령
  - /methods: 정의한 메서드 확인
  - /vars: 정의한 변수 확인
  - /list: 입력했던 코드 확인
  - /types: 정의한 타입(클래스, 인터페이스 등) 확인
  - /imports: 임포트 패키지(기본 패키지 포함) 확인

### 자바는 어떻게 빌드하고 어떻게 실행할까

- C++는 각 운영체제에서 실행되는 컴파일러가 소스 파일을 읽어 들인 다음, 해당 운영체제에 최적화된 바이너리를 한 번에 만듬
  - 윈도우에서는 비주얼 스튜디오에 포함된 윈도우 C++ 컴파일러인 (MSVC, Microsoft Visual C++) 컴파일러가 윈도우에 최적화된 바이너리를 만듬
  - 리눅스에서는 리눅스 C++ 컴파일러인 GCC(GNU Compiler Collection)가 리눅스에 최적화된 바이너리를 만듬
- 윈도우와 리눅스의 컴파일러가 완전히 다르기 때문에 서로 동일한 소스 코드라고 해도 다르게 동작할 수 있으며 컴파일이 안될 수도 있음
  - 맥이나 모바일 장비, 가전제품 같은 다른 환경에서 동작하게 하려면 각 기기에 맞춰서 개발해야 하는 어려움이 있음
- 자바는 이를 컴파일러와 실행 환경을 분리하는 방식으로 해결
- 바이트 코드라는 표준 중간 계층을 두어 컴파일러는 소스 파일을 읽어 들여 바이트 코드까지만 만들고 실행 환경은 각각의 운영체제에서 동작하는 방식
  - 컴파일러는 하나만 있으면 됨
  - 다른 환경에서 자바를 돌리려면 바이트 코드를 해당 환경에서 동작시키는 자바 실행 환경(JRE, Java Runtime Environment)만 개발하면 됨
- JRE는 각종 라이브러리와 도구, 자바 가상 머신(JVM, Java Virtual Machine)으로 구성되어 있음
  - 라이브러리에는 자바 컬렉션 프레임워크와 같은 기본으로 제공하는 참조 자료형과 java.util.* 같은 기본 패키지와 클래스 ,인터페이스 등이 포함됨
  - JVM은 자바의 컴파일된 바이트 코드를 각 운영체제에 맞게 실행해주는 가장 중요한 핵심적인 역할을 수행함

```java
// Hello.java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

// 빌드
javac Hello.java
```

- 자바 컴파일러인 javac로 소스 코드를 컴파일하면 Hello.class라는 클래스 파일이 생성되고, 이것이 자바 바이트 코드
- javap -c Hello.class : 디스어셈블러(기계어를 어셈블리어로 바꿔주는 프로그램)
- 자바 소스 파일(java)을 자바 컴파일러(javac)가 컴파일하여 바이트 코드(.class)를 만든다
- 각 운영체제별 JRE(자바 실행 환경)에서 JVM(자바 가상 머신)을 통해 바이트 코드(.class)를 운영체제에 맞게 해석하여 실행한다.

----------

## JVM 기반 언어의 등장

- JVM이 웬만한 운영체제는 모두 지원하기 시작하면서 어디에서나 실행되는 JVM의 이점을 굳이 자바가 아니라도 함께 누리길 희망하는 언어들이 등장하기 시작함
  - 어떤 언어든 간에 자바 바이트 코드를 만들어내기만 하면 됨
  - 나머지는 JVM이 알아서 처리해주기 때문
- 맨 먼저 시도한것은 제이파이썬(JPython)
- 루비 진영에서는 제이루비라는 이름으로 지원하기 시작
- 스칼라, 그루비 같은 JVM 전용 언어까지 등장
- 자이썬(Jython): 파이썬의 JVM 버전
- 제이루비(JRuby): 루비의 JVM 버전
- 스칼라(Scala): JVM 전용으로 시작한 언어로 함수형 프로그래밍 언어를 중심으로 객체 지향과 여러 컨셉을 접목하여 학계에서 시작된 언어
- 그루비(Groovy): 스크립트 언어처럼 쉽게 사용할 수 있도록 JVM 기반에 동적 프로그래밍 언어의 특징을 구현한 언어
  - 빌드 도구인 그레이들(Gradle)이 그루비로 구현되어 있음
- 클로저(Clojure): 리스프(LISP)언어의 방언 격으로 간결하면서도 표현력이 높은 코드가 특징