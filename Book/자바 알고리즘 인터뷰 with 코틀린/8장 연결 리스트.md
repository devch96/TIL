# 연결 리스트

- 연결 리스트는 대표적인 선형 자료구조 중 하나로 다양한 추상 자료형 구현의 기반이 됨
- 데이터 엘리먼트의 선형 집합이지만 데이터의 순서가 메모리에 물리적인 순서대로 저장되지 않음
  - 메모리에 물리적인 순서대로 저장되는 배열과는 가장 큰 차이
- 동적으로 새로운 노드를 삽입하거나 삭제하기가 간편하며 연결 구조를 통해 물리 메모리를 연속적으로
사용하지 않아도 되기 때문에 관리도 쉬움
- 데이터를 구조체로 묶어서 포인터로 연결한다는 개념은 여러 가지 방법으로 다양하게 활용 가능
- 연결 리스트는 배열과 달리 특정 인덱스에 접근하려면 전체를 순서대로 읽어야 하기 때문에 O(n)소요: 탐색
- 시작 또는 끝 지점에 아이템을 추가하거나 삭제, 추출하는 작업은 O(1)에 가능
- 자바에서 연결 리스트를 구현한 자료형은 자바 컬렉션 프레임워크에서 제공하는 LinkedList
- 보통 자료형에서 연결 리스트를 말할 때는 한쪽으로만 삽입과 추출이 가능한 단일 연결 리스트를 지칭하지만 자바는 이미 이중으로 구현되어 있음

---------

## 팰린드롬 연결 리스트

- 연결 리스트가 팰린드롬 구조인지 판별하라

### 풀이 1) 스택을 이용한 풀이

```java
public boolean isPalindrome(ListNode head) {
    Stack<Integer> stack = new Stack<>();
    ListNode node = head;
    while (node != null) {
        stack.add(node.val);
        node = node.next;
    }
    while (head != null) {
        if (head.val != stack.pop()) {
            return false;
        }
        head = head.next;
    }
    return true;
}
```

### 풀이 2) 데크를 이용한 풀이

- 데크는 이중 연결 리스트 구조로 양쪽 방향 모두 추출하는 데 시간 복잡도 O(1)이 걸림

```java
public boolean isPalindrome(ListNode head) {
    Deque<Integer> deque = new LinkedList<>();
    ListNode node = head;
    while(node != null) {
        deque.add(node.val);
        node = node.next;
    }
    // 데크가 모두 비거나(짝수 개) 1개 이하(홀수 개)가 될 때까지 비교
    while(!deque.isEmpty() && deque.size() > 1) {
        if(deque.pollFirt() != deque.pollLast()) {
            return false;
        }
    }
    return true;
}
```

### 풀이 3) 러너를 이요한 우아한 풀이

- 러너는 연결 리스트를 순회할 때 2개의 포인터를 동시에 사용하는 기법
- 한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간 위치, 길이 등을 판별할 때 유용하게 사용할 수 있음
  - 빠른 러너, 느린 러너
- 대개 빠른 러너는 두 칸씩 건너뛰고 느린 러너는 한 칸씩 이동
  - 이때 빠른 러너가 연결 리스트의 끝에 도달하면 느린 러너는 중간 지점
  - 중간 위치를 찾아내면 전체 길이를 알아낼 수 있고 여기서부터 값을 비교하거나 뒤집기를 시도하는 등 활용 가능
- 느린 러너가 중간까지 이동한 후에 나머지 경로를 역순으로 하여 연결 리스트 rev를 만들어 나감
- rev를 만들고 난 후 원래 연결 리스트와 일치하는지 확인

```java
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head;
    while( fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    // 홀수 개일 때 느린 러너가 한 칸 더 앞으로 가도록 처리
    if(fast!=null) {
        slow = slow.next;
    }
    
    ListNode rev = null;
    while (slow != null) {
        ListNode next = slow.next;
        slow.next = rev;
        rev = slow;
        slow = next;
    }
    
    while (rev != null) {
        if (rev.val != head.val) {
            return false;
        }
        rev = rev.next;
        head = head.next;
    }
    return true;
}
```
- 연결 리스트를 다른 자료형으로 변환하지 않았기 때문에 매우 빠름

### 풀이 4) 코틀린 풀이

- 변수명과 예약어가 겹칠 경우 코틀린에서는 백틱을 사용해 표현할 수 있음

```kotlin
fun isPalindrome(head: ListNode?): Boolean {
    val deque: Deque<Int> = LinkedList()
    var node = head
    while(node != null) {
        deque.add(node.`val`)
        node = node.next
    }
    while(!deque.isEmpty() && deque.size > 1) {
        if(deque.pollFirst() != deque.pollLast()) {
            return false
        }
    }
    return true
}
```