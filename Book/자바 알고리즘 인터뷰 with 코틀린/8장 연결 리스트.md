# 연결 리스트

- 연결 리스트는 대표적인 선형 자료구조 중 하나로 다양한 추상 자료형 구현의 기반이 됨
- 데이터 엘리먼트의 선형 집합이지만 데이터의 순서가 메모리에 물리적인 순서대로 저장되지 않음
    - 메모리에 물리적인 순서대로 저장되는 배열과는 가장 큰 차이
- 동적으로 새로운 노드를 삽입하거나 삭제하기가 간편하며 연결 구조를 통해 물리 메모리를 연속적으로
  사용하지 않아도 되기 때문에 관리도 쉬움
- 데이터를 구조체로 묶어서 포인터로 연결한다는 개념은 여러 가지 방법으로 다양하게 활용 가능
- 연결 리스트는 배열과 달리 특정 인덱스에 접근하려면 전체를 순서대로 읽어야 하기 때문에 O(n)소요: 탐색
- 시작 또는 끝 지점에 아이템을 추가하거나 삭제, 추출하는 작업은 O(1)에 가능
- 자바에서 연결 리스트를 구현한 자료형은 자바 컬렉션 프레임워크에서 제공하는 LinkedList
- 보통 자료형에서 연결 리스트를 말할 때는 한쪽으로만 삽입과 추출이 가능한 단일 연결 리스트를 지칭하지만 자바는 이미 이중으로 구현되어 있음

---------

## 팰린드롬 연결 리스트

- 연결 리스트가 팰린드롬 구조인지 판별하라

### 풀이 1) 스택을 이용한 풀이

```java
public boolean isPalindrome(ListNode head) {
    Stack<Integer> stack = new Stack<>();
    ListNode node = head;
    while (node != null) {
        stack.add(node.val);
        node = node.next;
    }
    while (head != null) {
        if (head.val != stack.pop()) {
            return false;
        }
        head = head.next;
    }
    return true;
}
```

### 풀이 2) 데크를 이용한 풀이

- 데크는 이중 연결 리스트 구조로 양쪽 방향 모두 추출하는 데 시간 복잡도 O(1)이 걸림

```java
public boolean isPalindrome(ListNode head) {
    Deque<Integer> deque = new LinkedList<>();
    ListNode node = head;
    while(node != null) {
        deque.add(node.val);
        node = node.next;
    }
    // 데크가 모두 비거나(짝수 개) 1개 이하(홀수 개)가 될 때까지 비교
    while(!deque.isEmpty() && deque.size() > 1) {
        if(deque.pollFirt() != deque.pollLast()) {
            return false;
        }
    }
    return true;
}
```

### 풀이 3) 러너를 이요한 우아한 풀이

- 러너는 연결 리스트를 순회할 때 2개의 포인터를 동시에 사용하는 기법
- 한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간 위치, 길이 등을 판별할 때 유용하게 사용할 수 있음
    - 빠른 러너, 느린 러너
- 대개 빠른 러너는 두 칸씩 건너뛰고 느린 러너는 한 칸씩 이동
    - 이때 빠른 러너가 연결 리스트의 끝에 도달하면 느린 러너는 중간 지점
    - 중간 위치를 찾아내면 전체 길이를 알아낼 수 있고 여기서부터 값을 비교하거나 뒤집기를 시도하는 등 활용 가능
- 느린 러너가 중간까지 이동한 후에 나머지 경로를 역순으로 하여 연결 리스트 rev를 만들어 나감
- rev를 만들고 난 후 원래 연결 리스트와 일치하는지 확인

```java
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head;
    while( fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    // 홀수 개일 때 느린 러너가 한 칸 더 앞으로 가도록 처리
    if(fast!=null) {
        slow = slow.next;
    }

    ListNode rev = null;
    while (slow != null) {
        ListNode next = slow.next;
        slow.next = rev;
        rev = slow;
        slow = next;
    }

    while (rev != null) {
        if (rev.val != head.val) {
            return false;
        }
        rev = rev.next;
        head = head.next;
    }
    return true;
}
```
- 연결 리스트를 다른 자료형으로 변환하지 않았기 때문에 매우 빠름

### 풀이 4) 코틀린 풀이

- 변수명과 예약어가 겹칠 경우 코틀린에서는 백틱을 사용해 표현할 수 있음

```kotlin
fun isPalindrome(head: ListNode?): Boolean {
    val deque: Deque<Int> = LinkedList()
    var node = head
    while(node != null) {
        deque.add(node.`val`)
        node = node.next
    }
    while(!deque.isEmpty() && deque.size > 1) {
        if(deque.pollFirst() != deque.pollLast()) {
            return false
        }
    }
    return true
}
```

----------

## 두 정렬 리스트의 병합

- 정렬되어 있는 두 연결 리스트를 합쳐라

### 풀이 1) 재귀 구조로 연결

- 정렬된 리스트라는 점이 중요
- 병합 정렬의 마지막 조합과 동일한 방식으로 첫 번째부터 비교하면서 리턴하면 쉽게 풀 수 있는 문제

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    if (list1 == null) return list2;
    if (list2 == null) return list1;
    if (list1.val < list2.val) {
        list1.next = mergeTwoLists(list1.next, list2);
        return list1;
    } else {
        list2.next = mergeTwoLists(list1, list2.next);
        return list2;
    }
}
```

### 풀이 2) 코틀린 풀이

```kotlin
fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? {
    if (list1 == null) return list2
    if (list2 == null) return list1
    return if(list1.`val` < list2.`val`) {
        list1.next = mergeTwoLists(list1.next, list2)
        list1
    } else {
        list2.next = mergeTwoLists(list1, list2.next)
        list2
    }
}
```

---------

## 역순 연결 리스트

- 연결 리스트를 뒤집어라

### 풀이 1) 재귀 구조로 뒤집기

```java
public ListNode reverse(ListNode node, ListNode prev) {
    if (node == null) return prev;
    ListNode next = node.next;
    node.next = prev;
    return reverse(next, node);
}

public ListNode reverseList(ListNode head) {
    return reverse(head, null);
}
```

### 풀이 2) 반복 구조로 뒤집기

```java
public ListNode reverseList(LiseNode head) {
    ListNode prev = null, node = head;
    while (node != null) {
        ListNode next = node.next;
        node.next = prev;
        prev = node;
        node = next;
    }
    return prev;
}
```

### 풀이 3) 코틀린 풀이

```kotlin
fun reverseList(head: ListNode?): ListNode? {
    var prev: ListNode? = null
    var node = head
    while (node != null) {
        val next = node.next
        node.next = prev
        prev = node.next
        node = next
    }
    return prev
}
```

----------

## 두 수의 덧셈

- 역순으로 저장된 연결리스트의 숫자를 더하라

### 풀이 1) 자료형 변환

- 연결 리스트를 문자열로 이어 붙인 다음 숫자로 변환하고 계산 후 다시 연결 리스트로 변환
  - 많은 시간이 소요도리수도
  - 역순으로 뒤집어야함

```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null, node = head;
    while (node != null) {
        ListNode next = node.next;
        node.next = prev;
        prev = node;
        node = next;
    }
    return prev;
}

public BigInteger toBigInt(ListNode node) {
    String val = "";
    while (node != null) {
        val += node.val;
        node = node.next;
    }
    return new BigInteger(val);
}

public ListNode toReversedLinkedList(BigInteger val) {
    ListNode prev = null, node = null;
    for (char c : String.valueOf(val).toCharArray()) {
        node = new ListNode(Character.getNumericValue(c));
        node.next = prev;
        prev = node;
    }
    return node;
}

public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode l1Reversed = reverseList(l1);
    ListNode l2Reversed = reverseList(l2);
    
    BigInteger result = toBigInt(l1Reversed).add(toBigInt(l2Reversed));
    return toReversedLinkedList(result);
}
```

### 풀이 2) 전가산기 구현

- 입력값 A와 B, 이전의 자리올림수(Carray in) 이렇게 3 가지 입력으로 합과 다음 자리올림수(Carry out) 여부를 결정

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode node = new ListNode(0);
    ListNode root = node;
    
    int sum, carry = 0, remainder;
    while (l1 != null || l2 != null || carry != 0) {
        sum = 0;
        if(l1 != null) {
            sum += l1.val;
            l1 = l1.next;
        }
        if(l2 != null) {
            sum += l2.val;
            l2 = l2.next;
        }
        remiander = (sum + carry) % 10;
        carry = (sum + carry) / 10;
        node.next = new ListNode(remainder);
        node = node.next;
    }
    return root.next;
}
```

## 페어의 노드 스왑

- 연결 리스트를 입력 받아 페어 단위로 스왑하라

### 풀이 1) 값만 교환

- 연결 리스트의 노드를 변경하는 게 아닌, 노드 구조는 그대로 유지하되 값만 변경하는 방법
- 실용성과는 다소 거리가 있음
  - 연결 리스트는 복잡한 여러 가지 값들의 구조체로 구서오디어 있어 값만 바꾸는 것은 매우 어려운 일

```java
public ListNode swapPairs(ListNode head) {
    ListNode node = head;
    
    while(node != null && node.next != null) {
        int tmp;
        tmp = node.val;
        node.val = node.next.val;
        node.next.val = tmp;
        node = node.next.next;
    }
    return head;
}
```

- 코딩 테스트 이후 코드 리뷰를 진행하다 좋지 않은 피드백을 받을 가능성이 있음
- 빨리 풀기 위해 시도한 방법이라는 사실을 어필하고 다른 풀이를 충분히 설명할 수 있어야 함

### 풀이 2) 반복 구조로 스왑

- 값을 바꾸는 일에 비해 연결 리스트 자체를 바꾸는 일은 다소 복잡한 문제
- 현재 노드를 node, 다음 노드를 a 다음 다음 노드를 b라고 할때
```java
a.next = b.next;
node.next = b;
node.next.next = a;
```

```java
public ListNode swapPairs(ListNode head) {
    ListNode node = new ListNode(0);
    ListNode root = node;
    node.next = head;
    while (node.next != null && node.next.next != null) {
        ListNode a = node.next;
        ListNode b = node.next.next;
        a.next = b.next;
        node.next = b;
        node.next.next = a;
        node = node.next.next;
    }
    return root.next;
}
```

### 풀이 3) 재귀 구조로 스왑

```java
public ListNode swapPairs(ListNode head) {
    if(head != null && head.next != null) {
        ListNode p = head.next;
        head.next = swapPairs(head.next.next);
        p.next = head;
        return p;
    }
    return head;
}
```

### 풀이 4) 코틀린 풀이

```kotlin
fun swapPairs(head: ListNode?): ListNode? {
    if(head?.next != null) {
        val p = head.next
        head.next = swapPairs(head.next.next)
        p.next = head
        return p
    }
    return head
}
```

--------

## 홀짝 연결 리스트

- 연결 리스트를 홀수 번째 노드 다음에 짝수 번째 노드가 오도록 재구성하라. 공간 복잡도 O(1), 시간 복잡도 O(n)에 풀이하라

### 풀이 1) 반복 구조로 홀짝 노드 처리

- 홀수 노드 다음에 짝수 노드가 오게 재구성하라고 했으니 홀, 짝 각 노드를 구성한 다음 홀수 노드의 마지막을 짝수 노드의 처음과 이어주면 됨

```java
public ListNode oddEvenList(ListNode head) {
    if(head == null) return null;
    ListNode odd = head;
    ListNode even = head.next;
    ListNode evenHead = even;
    while (even != null && even.next != null) {
        odd.next = odd.next.next;
        even.next = even.next.next;
        odd = odd.next;
        even = even.next;
    }
    odd.next = evenHead;
    return head;
}
```

### 풀이 2) 코틀린 풀이

```kotlin
fun oddEvenList(head: ListNode?): ListNode? {
    if (head == null) return null
    var odd: ListNode = head
    var even = head.next
    val evenHead = even
    while(even?.next != null) {
        odd.next = odd.next.next
        even.next = even.next.next
        odd = odd.next
        even = even.next
    }
    odd.next = evenHead
    return head
}
```

---------

## 역순 연결 리스트 2

- 위치 left에서 right까지를 역순으로 만들어라. 위치는 1부터 시작한다

### 풀이 1) 반복 구조로 노드 뒤집기

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    if (head == null) return null;
    ListNode root = new ListNode(0);
    root.next = head;
    ListNode start = root;
    for (int i = 0; i < left - 1; i++) {
        start = start.next;
    }
    ListNode end = start.next;
    for(int i = 0; i < right - left; i++) {
        ListNode tmp = start.next;
        start.next = end.next;
        end.next = end.next.next;
        start.next.next = tmp;
    }
    return root.next;
}
```