# 스택, 큐

- 스택은 LIFO(Last In First Out 후입선출)
  - 접시, 책을 쌓아놈. 마지막에 쌓은 접시가 맨 위에 놓이므로 가장 마지막에 쌓은 접시를 가장 먼저 꺼냄
- 큐는 FIFO(First In First Out 선입선출)
  - 맛집에 입장하기 위해 줄을 서는 것

---------

## 스택

- 스택은 콜 스택이라 하여 컴퓨터 프로그램의 서브루틴에 대한 정보를 저장하는 자료구조에도 널리 활용됨
- 컴파일러가 출력하는 에러도 스택처럼 맨 마지막 에러가 가장 먼저 출력되는 순서를 보임
- 스택에 엘리먼트가 넘쳐서 에러가 발생하는 것을 스택 버퍼 오버플로라고 부름

```java
class MyNode {
    int item;
    MyNode next;
    
    public MyNode(int item, Node next) {
        this.item = item;
        this.next = next;
    }
}

class MyStack {
    MyNode last;
    
    public MyStack() {
        this.last = null;
    }
    
    public void push(int item) {
        this.last = new MyNode(item, this.last);
    }
    
    public int pop() {
        int item = this.last.item;
        this.last = this.last.next;
        return item;
    }
}
```

----------

## 큐

- 큐는 가장 먼서 삽입된 엘리먼트가 처리되는 추상 자료형
- 데크나 우선순위 큐, 너비 우선 탐색이나 캐시 등을 구현할 때 널리 사용됨

--------

## 자바에서 활용하기

### 자바의 큐 선언

```java
Queue<Integer> queue = new LinkedList<>();
queue.offer(1);
queue.offer(2);
queue.offer(3);
queue.poll(); // 1
```

### 자바의 스택 선언

- 스택 자료형도 문제 없이 지원하나 Stack 클래스가 오래되었기 때문에 사용해선 안된다
  - Stack 클래스는 자바 1.2가 등장하기 전 CPU 코어가 하나밖에 없던 시절에 나온 자료형으로 모든 작업에 잠금이
  수행되는 Vector라는 자료형을 기반으로 함
  - 요즘처럼 멀티코어가 당연한 시대에는 성능에 심각한 문제가 있음
- Stack의 기반이 되는 Vector라는 자료형은 ArrayList로 개선되었으며 자바 공식 문서에서도 Stack을 사용하려고 하면 대신 새로운 자료형인 Deque를
사용하라 안내한다
  - Queue와 마찬가지인 인터페이스로 실제 구현체는 LinkedList 또는 ArrayDeque로 가능

```java
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);
stack.push(2);
stack.push(3);
stack.pop(); // 3
```

### 스레드 안전이 필요한 경우

- 성능을 위해 새로운 자료형을 사용하라고 하지만 성능이 좋은 대신 스레드 안전하지 않음
- 스레드 안전이 필요한 경우 Stack?
- LinkedBlockingDeque 또는 ConcurrentLinkedDeque를 사용하면 됨

--------

## 유효한 괄호

- 대중소 세 종류 괄호로 된 입력값이 유효한지 판별하라

### 풀이 1) 스택 일치 여부 판별

- 전형적인 스택 문제
- 열림 괄호는 스택에 푸쉬, 닫힘 괄호는 스택에서 팝한 결과가 매핑 테이블 결과와 매칭되는지 확인

```java
public boolean isValid(Sting s) {
    Deque<Character> stack = new ArrayDeque<>();
    Map<Character, Character> table = new HashMap<>() {{
        put(')', '(');
        put('}', '{');
        put(']', '[');
    }};
    for(int i = 0; i < s.length(); i++) {
        if(!table.containsKey(s.charAt(i))) {
            stack.push(s.charAt(i));
        } else if(stack.isEmpty() || table.get(s.charAt(i)) != stack.pop()) {
            return false;
        }
    }
    return stack.size() == 0;
}
```

### 풀이 2) 코틀린 풀이

```kotlin
fun isValid(s: String): Boolean {
    val stack: Deque<Char> = ArrayDeque()
    val table: Map<Char, Char> = mapOf(
        ')' to '(',
        '}' to '{',
        ']' to '['
    )
    for (i in s.indices) {
        if(!table.containsKey(s[i])) {
            stack.push(s[i])
        } else if(stack.isEmpty() || table[s[i]] !== stack.pop()) {
            return false
        }
    }
    return stack.size == 0
}
```

----------

## 중복 문자 제거

- 중복된 문자를 제외하고 사전식 순서로 나열하라

### 재귀를 이용한 분리

- 사전식 순서란 사전에서 가장 먼저 찾을 수 있는 순서
  - bcabc에서 중복 문자를 제외하면 사전에서 가장 먼저 찾을 수 있는 문자열은 abc
  - 앞에 e 문자가 하나 더 붙은 ebcabc가 입력값이라면 eabc
- 중복 문자를 제외한 알파벳순으로 문자열 입력값을 모두 정렬한 다음 가장 빠른 a부터 접미사를 분리해 확인함

```java
public Set<Character> toSortedSet(String s) {
    Set<Character> set = new TreeSet<>(new Comparator<Character>(){
        @Override
        public int compare(Character o1, Character o2) {
            if(o1 == o2) return 0;
            else if(o1 > o2) return 1;
            else return -1;
        }
    });
    for (int i = 0; i < s.length(); i++) {
        set.add(s.charAt(i));
    }
    return set;
}

public String removeDuplicateLetters(String s) {
    for (char c : toSortedSet(s)) {
        String suffix = s.substring(s.indexOf(c));
        if (toSortedSet(s).equals(toSortedSet(suffix))) {
            return c + removeDuplicateLetters(suffix.replace(String.valueOf(c), ""));
        }
    }
    return "";
}
```

### 풀이 2) 스택을 이용한 문자 제거

- 입력 문자열을 문자 단위로 처리하면서 스택 변수에는 문자를 차례대로 쌓아나가고 seen 변수에는 처리한 걸로 선언하면서 반복
- 스택에 있는 문자가 현재 문자보다 더 뒤에 붙여야 할 문자이고 아직 처리해야 할 문자가 남아있다면 스택에 쌓아둔걸 꺼내서 없앰

```java
public String removeDuplicateLetters(String s) {
    Map<Character, Integer> counter = new HashMap<>();
    Map<character, Boolean> seen = new HashMap<>();
    Deque<Character> stack = new ArrayDeque<>();
    for (char c : s.toCharArray()) {
        counter.put(c, couter.get(c) == null ? 1 : counter.get(c) + 1);
    }
    for (char c : s.toCharArray()) {
        counter.put(c, counter.get(c) - 1);
        if (seen.get(c) != null && seen.get(c) == true) {
            continue;
        }
        while(!stack.isEmpty() && stack.peek() > c && counter.get(stack.peek()) > 0) {
            seen.put(stack.pop(), false);
        }
        stack.push(c);
        seen.put(c, true);
    }
    StringBuilder sb = new StringBuilder();
    while(!stack.isEmpty()) {
        sb.append(stack.poolLast());
    }
    return sb.toString();
}
```

----------

## 일일 온도

- 매일의 온도 리스트 temperatures를 입력받아서, 더 따뜻한 날씨를 위해서는 며칠을 더 기다려야 하는지를 출력하라

### 풀이 1) 스택 값 비교

- 현재의 인덱스를 계속 스택에 쌓아두다가 이전보다 상승하는 지점에서 현재 온도와 스택에 쌓아둔 인덱스 지점의 온도 차이를 비교해서 더 높다면
스택의 값을 pop() 으로 꺼내고 현재 인덱스와 스택에 쌓아둔 인덱스의 차이를 정답으로 업데이트 그리고 현재 인덱스를 다시 삽입

```java
public int[] dailyTemperatures(int[] temperatures) {
    int[] result = new int[temperatures.length];
    Deque<Integer> stack = new ArrayDeque<>();
    for (int i = 0; i < temperatures.length; i++) {
        while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
            int last = stack.pop();
            result[last] = i - last;
        }
        stack.push(i);
    }
    return result;
}
```

----------

## 큐를 이용한 스택 구현

- 큐를 이용해 push, pop, top, empty를 지원하는 스택을 구현하라

```java
public class MyStack {
    Queue<Integer> queue = new LinkedList<>();
    
    public void push(int x) {
        queue.add(x);
        for(int i = 1; i < queue.size(); i++) {
            queue.add(queue.remove());
        }
    }
    
    public int pop() {
        return queue.remove();
    }
    
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.size() == 0;
    }
}
```

--------

## 스택을 이용한 큐 구현

- 스택을 이용해 push, pop, peek, empty 연산을 지원하는 큐를 구현하라

### 풀이 1) 스택 2개 사용

- 스택은 아무리 추가, 삭제를 반복해도 가장 마지막에 삽입된 아이템만 넣고 빼기를 반복하기 때문에 하나의 스택만 이용해서는 안됨


```java
class MyQueue {
    Deque<Integer> input = new ArrayDeque<>();
    Deque<Integer> output = new ArrayDeque<>();
    
    public void push(int x) {
        input.push(x);
    }
    
    public int pop() {
        peek();
        return output.pop();
    }
    
    public int peek() {
        if(output.isEmpty()) {
            while(!input.isEmpty()) {
                output.push(input.pop());
            }
        }
        return output.peek();
    }
    
    public boolean empty() {
        return input.isEmpty() && output.isEmpty();
    }
}
```