# 자료형

## 자바는 어떤 자료형을 제공할까

- 원시 자료형(Primitive Data Type)과 원시가 아닌 자료형(Non-Primitive Data Type)으로 구분 가능
  - 원시가 아닌 자료형은 사용자 정의 자료형 또는 참조 자료형으로 부르기도 하며 자바에서는 클래스 형태로 되어 있음

### 원시 자료형

- int, boolean, float 등은 모두 원시 자료형
- 원시형은 메모리에 정확하게 형 크기만큼의 공간을 할당하고 그 공간을 오로지 값으로 채워 넣음
- int a = 7 일 경우 메모리 특정 영역에 4바이트를 할당하고 (00000000 00000000 00000000 00000111) 이라는 값을 채워 넣음

### 참조 자료형

- 원시형과 비교해 다음과 같은 차이가 있음
  - 원시형은 자바 메모리 모델에서 훨씬 더 빠른 영역에 할당되지만 참조형은 좀 더 느린 영역에 할당됨
  - 원시형은 자료형에 따라 크기가 제각각이며 자료형 크기만큼의 메모리만 할당하지만 참조형은 일정한 크기의 메모리가 할당됨(크기가 훨씬 더 큼)
  - 참조형은 메서드 호출을 통해 여러 편리한 작업을 수행할 수 있음
  - 원시형은 항상 값이 존재하야 하며 널이 될수 없지만 참조형은 널이 될 수 있음
  - 컬렉션의 엘리먼트는 참조형만 가능함
  - 원시형을 선언하는 키워드는 소문자로 시작하며 참조형은 대문자로 시작함
- 참조형은 별도로 정의하며 부가 기능을 제공하는 편리한 자료형
  - 원시형을 쓰면 사용하는 메모리의 영역이 다르고 필요한 최소한의 공간만을 이용하기에 매우 빠른 연산이 가능함
- 자바는 C와 달리 원시형에 1:1 대응하는 참조형도 제공함
  - 그 자체가 클래스 객체이며 원시형을 감싸고 있다고 하여 래퍼 클래스라고도 함
  - byte - Byte
  - short - Short
  - int - Integer
  - long - Long
  - float - Float
  - double - Double
  - boolean - Boolean
  - char - Character
- 참조형임에도 불구하고 원시형처럼 단순히 값을 대입하는 것도 가능하며 오히려 권장됨
  - Integer a = 7(오토박싱)
  - 오토박싱(AUto Boxing)의 도움을 받아 자동으로 참조형으로 변환해주기 때문
- 참조형은 클래스 객체이므로 여러 메타 정보와 함께 다양한 메서드를 제공할 수 있음
  - 정수형을 문자형으로 변환, 실수 같은 자료형으로 변환
- 참조형은 대부분 16바이트이기 때문에 원시형에 비해 크기가 훨씬 더 크고 속도도 느림
  - 원시형은 메모리 주소를 알아내 그곳에 들어있는 값을 조회하면 되지만 참조형은 해당 메모리 주소에 실제로 값이 포함된 또 다른 주소가
  기입 되어 있고 그 주소를 찾아서 값을 조회하는 명령을 내리는 등 부가 작업이 추가로 필요함
- 값을 비교할 때도 == 연산자로 바로 비교하는 원시형과 달리 참조형은 그 자체가 값이 아니기 때문에 compareTo() 메서드를 사용해야 함
  - == 로 비교해도 자바는 참조형과 원시형을 필요시 자동으로 변환해주기 때문에 문제없으나 속도 저하가 발생함

----------

## 자바 컬렉션 프레임워크의 등장

- 복수 개의 값을 처리하려면 어떤 자료형을 사용해야 할까?
  - 배열은 복수 개의 자료를 처리하는 데 널리 사용됨
  - 하지만 정적 배열은 사용에 제약이 따르고 크기를 마음대로 조절할 수가 없음
- 배열의 기능을 뛰어넘어, 자유로운 삽입과 삭제가 가능하면서 크기에 신경 쓸 필요가 없으며 여러 가지 편리한 부가 기능을 함께 제공하는 목록형
- 자바 컬렉션 프레임워크의 주요 이점
  - 일관성 있는 API
    - 동일한 기능을 하는 자료형은 공통 인터페이스를 제공함
    - List, Set 모두 엘리먼트를 삽입하는 메서드는 add()로 동일
    - 공통 표준을 제공하여 학습 비용을 줄이고 호환성을 높임
  - 개발 비용 절약
    - 필수 데이터 구조와 알고리즘을 미리 구현하여 제공하므로 개발자가 일일이 알고리즘을 구현할 필요가 없음
  - 고성능 구현 제공
    - 잘 만든 고성능 구현을 제공함
  - 재사용 가능
    - 공통 표준을 제공하므로 재사용이 가능함
- 컬렉션 프레임워크의 대표적인 인터페이스는 List,Set,Queue 인터페이스는 Collection 인터페이스를 확ㅈ아하고 있고, Map은 별도로 정의되어 있음
- List
  - 순서대로 엘리먼트를 모아두는 모음집
- Set
  - List와 유사하지만 중복을 허용하지 않음
- Queue
  - 큐 자료구조 인터페이스
  - Deque
    - 양쪽에서 삽입과 삭제를 처리할 수 있는 스택과 큐의 특징을 모두 갖고 있는 인터페이스
- Map
  - Collection을 확장하지 않고 별도로 구현되어 있음

### 가장 자주 쓰게 될 리스트

- 순서대로 엘리먼트를 추출하거나 또는 임의의 위치를 추출할 수도 있으며 검색도 가능함
- ArrayList
  - 리스트의 가장 기본이 되는 구현, 시퀀스 형태의 엘리먼트를 동적 배열로 구현한 자료형
- LinkedList
  - 리스트를 연결 리스트로 구현한 자료형
  - 이중 연결 리스트로 구현되어 있음
- Vector
  - 자바 초기에 추가된 자료형으로 더 이상 쓰이지 않음

### 가장 유용하게 쓰게 될 맵

- List,Set,Queue와 달리 키/값을 모두 갖는 자료형
- HashMap
  - 해시 테이블 구조의 자료형
  - 입력 순서를 보장하지 않음
- LinkedHashMap
  - 입력 순서가 유지 됨
- TreeMap
  - 값에 따라 순서를 정렬함
  - 내부적으로 자가 균형 이진 탐색 트리인 레드-블랙 트리로 구현되어 있으며 정렬 순서도 임의로 지정할 수 있음
- Hashtable
  - 자바 초기에 추가된 자료형으로 더 이상 쓰이지 않음
- 맵 내부를 순회하여 추출할 때는 그대로 순회할 수 없고 entrySet()을 이용해 내부의 키/값 형태를 Entry<K, V> 를 지닌 집합 자료형,Set으로 만든 다음에 순회할 수 있음

---------

## 초기 자료형의 성능 문제

- 자바 1.0 초기 시절부터 목록형 자료형에 대한 고민이 있었고, 컬렉션 프레임워크가 나오기 전 C++의 영향을 받아 벡터 형태의 자료형과 해시 테이블
형태의 자료형을 별도로 제공함
  - Vector, Hashtable
- 자바 컬렉션 프레임워크가 등장하기 이전에 사용됐던 레거시 자료형
- 자바 초기 시절에는 동기화를 과도하게 적용하곤 했음
  - CPU 코어가 1개이던 시절
- 멀티 코어 시대가 열리면서 더 이상 동기화를 디폴트로 둘 수 없음
  - 따라서 Vector는 ArrayList, Hashtable은 Map 인터페이스로 대체됨
- 자료형뿐만 아니라 문자열을 조작하는 클래스도 같은 이유로 대체됨
  - StringBuffer는 모든 메서드가 동기화로 동작해 개선이 필요했지만 하위 호환성을 위해 수정할 수 없었고,
  StringBuilder로 대체됨
- Vector, 이를 상속한 Stack, Hashtable 추가로 문자열을 조작하는 StringBuffer에 이르기까지 이 모든 자료형은 더 이상 사용해선 안됨
  - 동기화가 필요하다면 구식이 된 Hashtable 대신 ConcurrentHashMap을 사용해야 함

-----------

## 무한대 크기의 숫자를 저장할 수 있는 자료형

- 자바는 독특한 참조형을 많이 지원함
- BigInteger
  - 큰 정수라는 명칭에 걸맞게 아무리 큰 숫자도 저장할 수 있는 독특한 자료형
  - 무제한 자릿수를 제공하는 정수형
- 정수를 숫자의 배열로 간주함
  - 자릿수 단위로 쪼개어 배열 형태로 표현함
- 10 진수를 2진수로 쪼개어 32비트씩 쪼개고 배열에 넣을때 다시 10진수로 변환함
- 숫자를 임의 정밀도로 처리하면 여러 부가 작업이 추가되어 계산 속도가 저하되지만 어떤 크기의 숫자가 입력되든 오버플로를 고민할 필요가 없어
계산 오류를 방지할 수 있다는 점은 큰 장점

-----------

## 코틀린은 어떤 자료형을 제공할까

- 코틀린은 자바처럼 완전한 원시형은 제공하지 않고 모든 자료형을 참조형으로 제공함
- 코틀린은 변수를 선언할 때 자료형 선언을 생략할 수 있음(타입 추론)
  - val four = 4 // Int
  - val fourBillion = 40000000 // Long
  - val fourLong = 4L // Long
  - val fourByte: Byte = 4 // Byte

### 코틀린 자료형의 속도는 과연 빠를까

- 자바의 참조형은 원시형에 비해 느리다
  - 참조형은 메모리의 해당 주소가 데이터가 직접 위치하는 것이 아닌 참조값만 갖고 있기 때문
- 참조형인 코틀린의 Int는 자바의 원시형 int를 한 꺼풀 감싼 형태로 저장하고 있음
- 코틀린은 참조 자료형만 제공하지만 실제로 컴파일될 때는 자바의 원시형과 동일한 바이트 코드를 사용해 실행 속도를 최적화함

---------

## 코틀린은 컬렉션 프레임워크를 어떻게 구현했을까

- 인터페이스만 코틀린에서 만들어두고 실제 자료형은 자바 컬렉션 프레임워크에서 제공하는 자료형을 그대로 활용하는 식
- 자체 컬렉션을 구현하지 않고 자바 컬렉션 프레임워크를 사용한 이유
  - 자바의 표준 컬렉션을 이용하면 호환성이 높음
  - 자바와 코틀린 간에 호출이 일어날 때 서로 변환할 필요가 없음

```java
//자바
List<Integer> list1 = new ArrayList<>();
list1.add(1);
list1.add(2);
list1.add(3);

Collections.max(list1)
```

```kotlin
var list2 = arrayListOf(1,2,3)
list2.max()
```

- list2는 java.util.ArrayList 클래스이고 여기에는 max()가 선언되어있지 않은데 어떻게 사용할까?

### 클래스의 기능을 확장하는 코틀린의 확장 함수

- 동일한 자바 클래스를 사용하면서도 코틀린에서 좀 더 풍부하게 활용할 수 있는 방법
- 자바에서는 클래스에 메서드를 추가하려면 해당 클래스 내부에서 소스 코드를 수정해야 가능함
- 코틀린은 해당 클래스를 전혀 건드리지 않고도 밖에서 메서드를 추가할 수 있는 기능을 제공하며 이를 확장 함수라 함

```kotlin
fun List<Int>.lastElement(): Int = this.get(this.size - 1)
```

- 인터페이스나 구현 클래스가 아님에도 클래스 선언 밖에서 확장을 원하는 클래스를 정하고, 함수명을 선언하고 기능을 구현하면 해당 기능이
동작하도록 클래스를 확장할 수 있음
  - 자바 클래스를 이용하면서도 자바가 지원하지 않는 여러 기능을 추가할 수 있어 매우 편리

### 코틀린이 별도로 구현한 컬렉션 인터페이스

- 코틀린은 ArrayList,HashMap과 같은 자바 클래스를 그대로 사용하지만 이를 감싸고 있는 인터페이스는 코틀린에서 별도로 정의하고 있음
- 자바 컬렉션 프레임워크의 인터페이스와 마찬가지로 상위에 Collection이 존재하고 이를 상속받아 List,Set 등의 인터페이스가 구성됨
  - 하지만 Mutable이라는 이름이 붙은 인터페이스가 추가되어 있음
- 함수형 언어의 특징을 많이 지니고 있는 코틀린은 항상 불변이 기본
- List,Set,Map 모두 기본은 불변이며 만약 값을 수정해야 하는 경우 MutableList, MutableSet, MutableMap으로 별도로 선언해야 함

```kotlin
// 불변 리스트 생성
val a: List<Int> = listOf(1,2,3)
// 가변 리스트 생성
val b: MutableList<Int> = mutableListOf(1,2,3)
```

- 만약 자바의 LinkedList를 사용하고 싶으면 어떡할까?
- 코틀린에서는 arrayListOf()처럼 LinkedList를 생성하는 함수가 없지만 자바 클래스와 완벽하게 호환되기 때문에 자바 클래스를 그대로 사용하면 됨

```kotlin
import java.tuil.LinkedList

val a = LinkedList<Int>();
```

- 리스트는 arrayList가 디폴트이지만 맵은 LinkedHashMap이 디폴트
  - hashMapOf()라는 함수 제공 - HashMap
```kotlin
val a = mapOf("b" to 2, "c" to 3, "a" to 1)
```

---------

## 자바 컬렉션 프레임워크의 실행 속도

- 자바는 기본적으로 초깃값을 10으로 설정하고 1.5배씩 늘려줌
  - 더블링
- 1억 개를 차례대로 삽입하면 40여회는 더블링해야함
- 크기를 미리 잡아주면 훨씬 더 빠르게 실행됨
  - 원시형이랑 큰 차이 없음