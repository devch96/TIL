# 코틀린, 구글이 인정한 공식 언어

- 2011년 젯브레인즈에서 JVM 기반의 새로운 언어에 도전
  - 자바가 인도네이사의 섬 이름에서 유래한 데서 착안해 러시아의 섬 이름을 따와서 코틀린으로 정함
- 코틀린은 스칼라와 유사하면서도 스크립트 언어만큼이나 간결한 문법을 제공함
  - 자바와의 호환성 또한 뛰어남

---------

## 코틀린의 주요 특징

### 실용성

- 학교나 연구소에서 탄생한 연구를 위한 언어가 아님
- 코틀린은 실무에서 당면한 문제를 해결하기 위해 만든 실용적인 언어
- 학계에서 연구 중인 주제보다는 다른 언어에서 성공적으로 검증된 방식을 채택하려고 노력했기 때문에 언어의 복잡도가 줄어들었고
널리 알려진 개념을 잘 담아내어 익히기도 훨씬 수월함
- 언어와 IDE는 서로 개별적으로 발전해왔으나 코틀린은 인텔리제이라는 강력한 도구를 만들어낸 젯브레인즈에서 탄생했기 때문에
언어와 도구가 함께 개발됨

### 상호운용성

- 코틀린은 기존 자바 라이브러리와 완벽하게 호환됨
  - 단일 프로젝트에서 일부는 자바로 작성하고 일부는 코틀린으로 작성해도 아무 문제 없이 컴파일되고 호환됨
  - 자바 메서드를 호출하거나 자바 클래스를 상속받을 수도 있음
  - 인터페이스를 구현하거나 자바 애노테이션을 코틀린 코드에 적용하는 것도 가능
- 반대도 마찬가지

### 안전성

- 언어가 안전하다는 뜻은 언어의 구조가 개발자가 실수한 가능성을 원천적으로 방지해 오류의 가능성을 줄여준다는 얘기
  - C언어는 강력하지만 안전장치가 거의 없다. 조금만 실수를 해도 메모리가 줄줄 새는 프로그램을 만들어버린다
  - 자바는 가비지 컬렉터가 있어 사용하지 않는 메모리는 자동으로 해제하여 메모리 누수의 가능성을 줄인다
- 코틀린은 자바보다도 훨씬 더 안전한 언어를 지향했고 그 결과물 중 하나가 언어 차원에서 지우너하는 널 안정성이다
- 자바 개발자들이 흔히 접하는 에러인 NPE(NullPointerException)은 컴파일 타임에 오류를 발견하기 쉽지 않다
- 코틀린에는 언어 차원에서 널 허용 여부를 구분할 수 있는 표현이 추가됨
  - val a1: String? = null // 널이 될 수 있음
  - val a2: String = null // 널이 될 수 없으며, 에러 발생
- 널 허용 여부를 미리 지정할 수 있어 런타임에 널 포인터 예외가 발생할 여지를 없애줌
- 널 허용 여부를 구분하는 것이 컴파일 타임에 오류를 잡을 수 있는것인가?
  - 자바는 런타임에 NPE가 발생하면 애플리케이션이 실행 중에 갑자기 중단되는 원인이 됨
  - 코틀린의 경우 널을 파라미터로 넘기면 오류가 발생함
    - NPE를 원천적으로 차단
  - 가끔씩 널이 되는 값이라면 파라미터와 리턴 타입을 허용해야 함
    - ?
  - 널 허용 타입을 받는다는 것은 어떤 식으로든 함수 내에서 널 여부를 검사하도록 코틀린 컴파일러가 강제함
  - 코틀린의 널 안정성

### 우아함

- 자바의 가장 큰 장점이자 단점은 하위 호환성
  - 30년이 지났기 때문에 레거시가 많음
- 코틀린은 하위 호환성을 유지하기 시작한것은 7년 정도에 불과
- 가장 기본적인 for 문부터 자바에서 지우너하지 않는 when 조건문까지 우아하며 편리하게 사용 가능함

-------

## 코틀린의 기본 문법

```kotlin
fun main() {
    println("Hello, World!");
}
```

- 함수의 선언은 fun
- 클래스가 보이지 않음
  - 자바와 달리 반드시 클래스를 선언할 필요가 없음
  - 선택사항이며 클래스 없이 독립된 함수만 따로 존재하는 경우가 훨씬 더 많음
  - 클래스에서 구현된 함수는 메서드라고 부르는데 자바는 클래스가 필수이므로 모든 함수를 메서드라고 부름
- 자바는 표준 라이브러리에서 출력을 위한 기능을 제공함
  - System 클래스에서 out이라는 변수명으로 PrintStream을 지정하고, println()이라는 메서드를 실행하는 기능
    - System.out.println()
  - 코틀린은 println()만 하면 됨
    - 단순히 System.out.println()을 대신 호출해주는 역할
```kotlin
public actual inline fun println(message: Any?) {
    System.out.println(message)
}
```
- 라인 끝에 세미콜론이 보이지 않음
  - 줄바꿈으로 구문을 구분함

```kotlin
// 자바
public int square(int x) {
  ...
}

fun square(x: Int): Int {
    return x * x
}

fun main() {
    val result: Int = square(5)
    println(result)
}
```

- 코틀린은 fun 키워드로 함수 여부를 먼저 표현하며 리턴 타입은 맨 뒤에 선언
- 자바는 함수 여부를 따로 나타내지 않으며 리턴 타입을 맨 앞에 선언
- 자바와 달리 코틀린은 public이 디폴트

```kotlin
// 자바
int result = square(5);

// 코틀린
var result: Int = square(5)
```

- 자바는 맨 앞에 타입을 선언하고 변수명을 씀
- 코틀린은 var 키워드로 변수임을 먼저 나타내고 뒤이어 변수명과 타입을 씀
- 코틀린은 함수형 프로그래밍 언어의 특징을 강하게 갖고 있기 때문에 읽기 전용에 매우 큰 의미를 둠
  - 값이 수정되지 않는다면 되도록 읽기 전용 변수로 선언하는 것을 권장함
  - val result: Int = square(5)
  - var 키워드를 val로 바꾸기만 하면 읽기 전용이 됨
- 코틀린은 타입 추론을 지원하기 때문에 변수 선언 시 굳이 Int 같은 타입을 정해주지 않아도 자동으로 함수의 리턴 타입이 무엇인지 알아내서 정해줌
  - var result = square(5)
  - 자바 10 버전 이상에서는 자바도 타입 추론을 지원함(var)
    - 사실상 코틀린과 동일

### 깔끔한 for 반복문

```java
int sum = 0;
for (int i = 1; i <= 10; i++) {
    sum += i;
}
System.out.println(sum);
```

```kotlin
var sum = 0
for (i in 1..10) {
    sum += i
}
println(sum)
```

- 코틀린은 모든 범위를 in 이후에 둘 수 있음
- 범위 표현식에서 내림차준으로 하거나 2 이상 건너뛰어야 할때는 downTo와 step이라는 키워드 사용

```kotlin
for (i in 10 downTo 0 step 2) {
    
}
```

### 정갈한 when 조건문

- 코틀린도 if, else를 지원하지만 when이 더 좋음
- when은 자바의 switch와 유사하지만 더 많은 기능을 제공함

```java
public String getTypeOfDayWithSwitchStatement(int dayOfWeek) {
    String typeofDay;
    switch(dayOfWeek) {
      case 1:
          typeOfDay = "한 주의 시작";
          break;
      case 2:
      case 3:
      case 4:
          typeOfDay = "주중";
          break;
      case 5:
          typeOfDay = "한 주의 끝";
          break;
      case 6:
      case 7:
          typeOfDay = "주말";
          break;
      default:
          throw new IllegalArgumentException("잘못된 날: " + dayOfWeek);
    }
    return typeOfDay;
}
```

- 월요일(1)은 한 주의 시작, 화/수/목(2,3,4)은 '주중', 금요일(5)은 '한 주의 끝', 토/일(6,7)은 '주말'을 출력

```kotlin
fun getTypeOfDayWithSwitchStatement(dayOfWeek: Int): String {
    val typeOfDay: String = when (dayOfWeek) {
        1 -> "한 주의 시작"
      2, 3, 4 -> "주중"
      5 -> "한 주의 끝"
      6, 7 -> "주말"
      else -> throw IllegalArgumentException("잘못된 날 : $dayOfWeek")
    }
    return typeOfDay
}
```

- when 조건문을 이용해 typeOfDay 변수에 바로 할당되도록 처리
  - 코드가 간결해지고 어떤 역할을 하는지 금방 알아차릴 수 있음
- when 조건문에서 괄호와 인자는 생략이 가능함

### 편리한 함수 선언

- 자바는 메서드를 선언하는 데 제약이 많음
- 파라미터가 하나만 달라져도 자바에서는 중복으로 선언해야 함

```java
void overloadMethod(int paramA, int paramB){
    
}

void overloadMethod(int paramA, int paramB, int paramC){
    
}
```

- 동일한 메서드명으로 파라미터만 다르게 해서 재선언하는 과정을 메서드 오버로딩이라고 하며 OOP의 중요한 개념
  - 만약 비슷한 역할을 구현하려면 제각각 구현해야 하는 번거로움이 있음

```java
// 같은 역할을 해야 한다면
void overloadMethod(int paramA, int paramB){
    overloadMethod(paramA, paramB, 0);
}

void overloadMethod(int paramA, int paramB, int paramC){

}
```

```kotlin
fun overloadFunction(paramA: Int, paramB: Int, paramC: Int = 0) {
    
}
```

- paramC: Int = 0이라는 디폴트 값
- 코틀린은 함수에 디폴트값을 지정할 수 있음
- 코틀린은 명명 인자(Named Argument) 지원
  - overloadFunction(paramA = 1, paramB = 2, paramC = 0)
  - C++과 자바에서는 이 기능이 존재하지 않아 빌더 패턴을 고안해 사용
  - 코틀린은 빌더 패턴을 사용할 필요 없음(파이썬도 지원)
- 코틀린은 함수가 단일 표현식으로 리턴하는 경우 중괄호를 생략하고 간단하게 정의 할 수 있음
  - fun square(x: Int): Int = x*x
  - 변수 선언과 마찬가지로 리턴 타입을 명시하지 않아도 리턴 타입을 자동으로 추론함
  - fun square(x: Int) = x * x

### 함수형 프로그래밍 언어

```java
List<Integer> doubleList = list.stream()
        .map(m -> m*2)
        .collect(Collectors.toList());
```

```kotlin
val doubleList = list.map { it * 2 }
```

- stream()을 명시할 필요가 없으며 map() 또한 단일 파라미터인 경우 it 라는 기본 이름을 제공하므로 훨씬 더 단순하게 작성할 수 있음
- collect()를 이용해 스트림을 컬렉션으로 바꾸는 과정도 별도로 명시할 필요 없이 코틀린은 자동으로 처리해줌
- filter()나 map()을 사용할 경우 소괄호 대신 중괄호를 사용함
  - 코틀린에서는 함수의 마지막 인자가 함수이면 람다 표현식을 전달할 수 있고 이때 소괄호는 생략 가능
  - map( { it * 2 } ) 와 동일

```java
members.stream()
.filter(m -> m.age == 24)
        .map(m -> m.name)
        .sorted()
.collect(Collectors.toList())
```

```kotlin
members.filter { it.age == 24 }
  .map { it.name }
  .sorted()
```

### 가시성 제어자

- 코틀린에서는 자바의 접근 제어자와 동일한 역할을 가시성 제어자라는 이름으로 부름
- public: 어디서나 접근 가능
  - 디폴트
- private: 클래스 내에서만 접근 가능. 자바와 동일
- protected: 상속받은 클래스에서만 접근가능. 자바와 동일
  - 코틀린의 경우 클래스 선언은 final이 디폴트이기 때문에 상속을 허용하려면 클래스 앞에 open을 별도로 선언해야 함
- internal: 자바에서의 디폴트, 동일 모듈로 접근 제한

### 확장 함수

- 기존에 정의한 클래스에 추가로 새로운 함수를 정의할 수 있는 기능으로 원래 클래스를 건드리지 않고도 여러 가지 편리한 기능을 추가할 수 있음

------------

## 코틀린은 어떻게 빌드하고 어떻게 실행할까

```kotlin
// Hello.kt
fun main() {
    println("Hello, World!")
}

kolinc Hello.kt
```

- 코틀린은 클래스 파일을 생성할 때 접미사로 코틀린을 의미하는 Kt 를 부여하는 규칙이 있음
  - Hello라는 클래스는 HelloKt로 컴파일됨
- JRE의 라이브러리는 자바만을 위한 전용 실행 환경이였기에 다른 import 클래스가 담긴 코틀린 파일은 바로 실행되지 않음
  - 코틀린은 컴파일러가 코틀린 코드를 컴파일할 때 기본 클래스를 함께 묶어 jar로 배포하는 방식을 택함

### 코틀린은 과연 느릴까

- 리트코드에서만 느리고 나머지는 안느림
- 코틀린은 이미 컴파일된 상태에서는 빠르게 실행되지만 자바에 비해 컴파일 시간이 많이 느린 것은 사실
