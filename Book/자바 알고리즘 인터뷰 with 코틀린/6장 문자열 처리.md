# 문자열 처리

- 문자열 처리와 관련된 알고리즘이 쓰이는 대표적인 분야
    - 정보 처리 분야
        - 어떤 키워드로 웹 페이지를 탐색
    - 통신 시스템 분야
        - 문자 메시지나 이메일을 보낼 때
    - 프로그래밍 시스템 분야

---------

## 유효한 팰린드롬

- 주어진 문자열이 팰린드롬인지 확인하라. 대소문자를 구분하지 않으며, 영숫자(영문자와 숫자)만을 대상으로 한다.
- 팰린드롬이란 앞뒤가 똑같은 단어나 문장

### 풀이 1) 문자 단위로 추출해서 처리

- 자바의 기본 문자열 자료형인 String은 기본적으로 문자열 처리를 위한 다양한 기능을 지원함
- 이 문제의 경우 문자열에서 문자를 하나씩 추출해 비교해야 하기 때문에 문자열 자료형을 그대로 사용하기보다는 문자를 하나씩 추출하는 방식이
  비교적 편함
- 추출하려면 charAt() 메서드에 인덱스 지정
- 문자가 일치하는지 여부는 char끼리 단순히 비교하면 되지만 대소문자를 구분하지 않으며 영숫자만을 대상으로 한다는 제약 조건이 있음
    - 자바의 Character 클래스에는 원시 자료형 char를 입력값으로 하여 모두 소문자로 변경해주는 toLowerCase() 메서드와 영숫자인지 판별해주는 isLetterOrDigit()
      메서드가 존재
- 문자열에서 맨 앞의 문자와 맨 뒤의 문자를 추출한 다음 유효한 문자인지를 확인하고, 모두 소문자로 변경한 뒤에 일치 여부를 판별하면됨
- 맨 앞에서는 한 칸씩 뒤로, 맨 뒤에서는 한 칸씩 앞으로

```java
public boolean isPalindrome(String s) {
    int start = 0;
    int end = s.length() - 1;
    // 서로 중앙으로 이동
    while (start < end) {
        // 영숫자가 아니라면 한 칸씩 이동
        if(!Character.isLetterOrDigit(s.charAt(start))) {
            start++;
        } else if(!Character.isLetterOrDigit(s.charAt(end))) {
            end--;
        } else { // 유효한 문자라면 확인
            if(Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end))) {
                return false;
            }
            start++;
            end--;
        }
    }
    return true;
}
```

### 풀이 2) 문자열 직접 비교

- 문자 단위로 추출하지 않고 문자열을 직접 비교해서 풀이
- 정규식을 이용해 영숫자만 걸러낼 수 있음
- StringBuilder 클래스는 문자열을 뒤집는 메서드를 제공함
    - 스레드 안전하지 않음

```java
public boolean isPalindrome(String s) {
    // 영숫자만 추출
    String s_filtered = s.replaceAll("[^A-Za-z0-9]","").toLowerCase();
    String s_reversed = new StringBuilder(s_filtered).reverse().toString();
    return s_filtered.equals(s_reversed);
}
```

- 문자열에서 일일이 문자를 추출하지 않아도 되기 때문에 코드가 간결해지나 실행 속도가 더 느림

### 풀이 3) 코틀린 풀이

- 자바의 switch 절은 반드시 변수를 지정해야 하고 그 변수의 값에 따라서 분기를 하는 데 반해 코틀린의 when은 변수를 지정하지 않아도
  조건만 일치하면 분기할 수 있음

```kotlin
fun isPalindrome(s: String): Boolean {
    var start = 0
    var end = s.length - 1
    while (start < end) {
        when {
            !Character.isLetterOrDigit(s[start]) -> start++
            !Character.isLetterOrDigit(s[end]) -> end--
            else -> {
                if (Character.toLowerCase(s[start]) != Character.toLowerCase(s[end])) {
                    return false
                }
                start++
                end--
            }
        }
    }
    return true
}
```

- 자바에서 charAt() 메서드의 리턴값은 char이고 원시 자료형인 데 반해, 코틀린에서 인덱스로 직접 접근해 추출한 결과는
  원시 자료형이 아니라 Char 라는 코틀린 클래스로서 참조형이다
    - 코틀린은 경우에 따라 원시 자료형을 사용함

-----------

## 문자열 뒤집기

- 문자열을 뒤집는 함수를 작성하라. 입력값은 문자 배열이며, 리턴 없이 입력 배열 내부를 직접 조작하라

### 풀이 1) 문자 배열로 스왑

- 문자열에서 맨 앞 문자와 맨 뒤 문자를 추출한 다음 중앙에서 만날 때까지 서로 스왑 하면서 한 칸씩 이동하면 쉽게 해결 가능

```java
public void reverseString(char[] s) {
    int start = 0;
    int end = s.length - 1;
    while (start < end) {
        char temp = s[start];
        s[start] = s[end];
        s[end] = temp;
        start++;
        end--;
    }
}
```

### 풀이 2) 코틀린 풀이

- 자바의 스왑을 코틀린에서는 좀 더 편하게 작성할 수 있다
- s[start] = s[end].also { s[end] = s[start] }
- also는 코틀린에서 모든 객체에 기본적으로 제공하는 함수이며, 속성의 변경 없이 중괄호 내 명령이 실행됨

```kotlin
val numbers = mutableListOf(1,2,3)
numbers.add(4).also {println("$it")}
---
[1,2,3]
```

- numbers는 also 부분이 다 실행되기 전에 속성이 변하지 않기 때문에 1,2,3 이 먼저 출력되고 이후에 add가 실행됨
- s[start] = s[end].also { s[end] = s[start] }
    - also가 실행되는 시점에 속성이 변하지 않기 때문에 원래 값으로 s[end] = s[start]가 실행되고, 값이 변하지 않은 상태로 s[start] = s[end]가 됨

```kotlin
fun reverseString(s: CharArray): Unit {
    var start = 0
    var end = s.size - 1
    while (start < end) {
        s[start] = s[end].also {s[end] = s[start]}
        start++
        end--
    }
}
```

--------------

## 로그 파일 재정렬

- 로그를 재정렬하라 기준은 다음과 같다
    - 로그의 가장 앞부분은 식별자로서, 순서에 영향을 끼치지 않는다.
    - 문자로 구성된 로그가 숫자 로그보다 앞에 오며, 문자 로그는 사전순으로 한다.
    - 문자가 동일할 경우에는 식별자순으로 한다.
    - 숫자 로그는 입력 순서대로 한다

### 풀이 1) 문자 로그와 숫자 로그를 구분해 각각 처리

- 먼저 문자로 구성된 로그가 숫자 로그보다 이전에(앞서) 오며, 숫자 로그는 입력 순서대로 둠
    - 문자 로그와 숫자 로그는 서로 정렬 방식이 다르므로 하나로 처리하기보다는 둘을 아예 분리해 정렬하고 나중에 결과를 서로 이어 붙이는 것이
      처리하기 더 편함
- 문자 로그의 정렬 기준은 사전순으로 하되, 문자가 동일할 경우 식별자 순으로 함
    - Collections.sort()에 Comparator를 이용하면 정렬 조건을 설정하고 정렬할 수 있음
    - 두 값이 동일하다면 0, 비교 대상의 순서가 앞으로 와야 하는 경우에는 1, 비교 대상의 순서가 뒤에 머물러야 할 경우에는 -1
    - 자바 8 이상 버전에서는 복잡한 Comparator를 일일이 지정하는 대신 람다 표현식으로 대체 가능
- 숫자 로그의 경우에는 입력 순서를 그대로 유지한다고 했으니 그냥 두고, 문자 로그의 정렬 결과 뒤에 추가해주기만 하면 됨

```java
public String[] reorderLogFiles(String[] logs) {
    List<String> letterList = new ArrayList<>();
    List<String> digitList = new ArrayList<>();

    for(String log : logs) {
        if (Character.isDigit(log.split(" ")[1].charAt(0))) {
            digitList.add(log);
        } else {
            letterList.add(log);
        }
    }

    letterList.sort((s1, s2) -> {
        // 식별자와 식별자 외 나머지 부분 두 부분으로 나눔
        String[] s1x = s1.split(" ", 2);
        String[] s2x = s2.split(" ", 2);

        // 문자 로그 사전순 비교
        int compared = s1x[1].compareTo(s2x[1]);
        if(compared == 0) {
            // 두 문자가 같을 경우 식별자로 비교
            return s1x[0].compareTo(s2x[0]);
        } else {
            return compared;
        }
    });

    letterList.addAll(digitList);
    return letterList.toArray(new String[0]);
}
```

### 풀이 2) 코틀린 풀이

```kotlin
fun reorderLogFiles(logs: Array<String>): Array<String> {
    val letterList = mutableListOf<String>()
    val digitList = mutableListOf<String>()
    for (log in logs) {
        if (Character.isDigit(log.split(" ")[1][0])) {
            digitList.add(log)
        } else {
            letterList.add(log)
        }
    }
    
    letterList.sortWith(Comparator { s1: String, s2: String ->
        val s1x = s1.split(" ", limit = 2)
        val s2x = s2.split(" ", limit = 2)
        
        val compared = s1x[1].compareTo(s2x[1])
        if (compared == 0) {
            s1x[0].compareTo(s2x[0])
        } else {
            compared
        }
    })
    
    letterList.addAll(digitList)
    
    return letterList.toTypedArray()
}
```

- 자바의 경우와 달리 sort() 대신 sortWith()를 사용하고, Comparator를 명시적으로 선언한다.

------------

## 가장 흔한 단어

- 금지된 단어를 제외하고 가장 흔하게 등장하는 단어를 출력하라. 대소문자를 구분하지 않으며, 구두점 또한 무시한다

### 풀이 1) 전처리 작업 후 개수 처리 및 추출

- 입력값에는 대소문자가 섞여 있으며 쉼표 등 구두점이 존재하기에 데이터 클렌징이라 부르는 입력값에 대한 전처리 작업이 필요함
- 정규식에서 \W 는 단어 문자(Word Character)가 아닌 것을 뜻함
  - 단어 문자를 뜻할때는 \w 소문자를 사용
- 문자 뒤에 + 를 붙이면 연속적인 값을 의미
  - a+ 표현식은 a와 aa를 모두 의미
- \W+는 연속적으로 단어 문자가 아닌 값을 의미
- replaceAll() 메서드에서 역슬래시는 앞에 한 번 더 역슬래시로 처리해 \\W와 같은 형태로 사용해야 함

```java
public String mostCommonWord(String p, String[] banned) {
    // 금지어 목록이 String 배열이므로, 비교 메서드를 제공하는 Set으로 변경함
    Set<String> ban = new HashSet<>(Arrays.asList(banned));
    Map<String, Integer> counts = new HashMap<>();
    
    String[] words = p.replaceAll("\\W+", " ").toLowerCase().split(" ");
    for (String w : words) {
        if(!ban.contains(w)) {
            counts.put(w, counts.getOrDefault(w, 0) + 1);
        }
    }
    
    return Collections.max(counts.entrySet(), Map.Entry.comparingByValue()).getKey();
}
```

### 풀이 2) 코틀린 풀이

```kotlin
fun mostCommonWord(paragraph: String, banned: Array<String>): String {
    val counts: MutableMap<String, Int> = mutableMapOf()
    
    val words = paragraph.replace("\\W+".toRegex(), " ").toLowerCase().trim().split(" ")
    for (w in words) {
        if(!banned.contains(w)) {
            counts[w] = counts.getOrDefault(w, 0) + 1
        }
    }
    return counts.maxBy{ it.value }!!.key
}
```