# 문자열 처리

- 문자열 처리와 관련된 알고리즘이 쓰이는 대표적인 분야
  - 정보 처리 분야
    - 어떤 키워드로 웹 페이지를 탐색
  - 통신 시스템 분야
    - 문자 메시지나 이메일을 보낼 때
  - 프로그래밍 시스템 분야

---------

## 유효한 팰린드롬

- 주어진 문자열이 팰린드롬인지 확인하라. 대소문자를 구분하지 않으며, 영숫자(영문자와 숫자)만을 대상으로 한다.
- 팰린드롬이란 앞뒤가 똑같은 단어나 문장

### 풀이 1) 문자 단위로 추출해서 처리

- 자바의 기본 문자열 자료형인 String은 기본적으로 문자열 처리를 위한 다양한 기능을 지원함
- 이 문제의 경우 문자열에서 문자를 하나씩 추출해 비교해야 하기 때문에 문자열 자료형을 그대로 사용하기보다는 문자를 하나씩 추출하는 방식이
비교적 편함
- 추출하려면 charAt() 메서드에 인덱스 지정
- 문자가 일치하는지 여부는 char끼리 단순히 비교하면 되지만 대소문자를 구분하지 않으며 영숫자만을 대상으로 한다는 제약 조건이 있음
  - 자바의 Character 클래스에는 원시 자료형 char를 입력값으로 하여 모두 소문자로 변경해주는 toLowerCase() 메서드와 영숫자인지 판별해주는 isLetterOrDigit()
  메서드가 존재
- 문자열에서 맨 앞의 문자와 맨 뒤의 문자를 추출한 다음 유효한 문자인지를 확인하고, 모두 소문자로 변경한 뒤에 일치 여부를 판별하면됨
- 맨 앞에서는 한 칸씩 뒤로, 맨 뒤에서는 한 칸씩 앞으로

```java
public boolean isPalindrome(String s) {
    int start = 0;
    int end = s.length() - 1;
    // 서로 중앙으로 이동
    while (start < end) {
        // 영숫자가 아니라면 한 칸씩 이동
        if(!Character.isLetterOrDigit(s.charAt(start))) {
            start++;
        } else if(!Character.isLetterOrDigit(s.charAt(end))) {
            end--;
        } else { // 유효한 문자라면 확인
            if(Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end))) {
                return false;
            }
            start++;
            end--;
        }
    }
    return true;
}
```

### 풀이 2) 문자열 직접 비교

- 문자 단위로 추출하지 않고 문자열을 직접 비교해서 풀이
- 정규식을 이용해 영숫자만 걸러낼 수 있음
- StringBuilder 클래스는 문자열을 뒤집는 메서드를 제공함
  - 스레드 안전하지 않음

```java
public boolean isPalindrome(String s) {
    // 영숫자만 추출
    String s_filtered = s.replaceAll("[^A-Za-z0-9]","").toLowerCase();
    String s_reversed = new StringBuilder(s_filtered).reverse().toString();
    return s_filtered.equals(s_reversed);
}
```

- 문자열에서 일일이 문자를 추출하지 않아도 되기 때문에 코드가 간결해지나 실행 속도가 더 느림

### 풀이 3) 코틀린 풀이

- 자바의 switch 절은 반드시 변수를 지정해야 하고 그 변수의 값에 따라서 분기를 하는 데 반해 코틀린의 when은 변수를 지정하지 않아도
조건만 일치하면 분기할 수 있음

```kotlin
fun isPalindrome(s: String): Boolean {
    var start = 0
    var end = s.length - 1
    while (start < end) {
        when {
            !Character.isLetterOrDigit(s[start]) -> start++
            !Character.isLetterOrDigit(s[end]) -> end--
            else -> {
                if (Character.toLowerCase(s[start]) != Character.toLowerCase(s[end])) {
                    return false
                }
                start++
                end--
            }
        }
    }
    return true
}
```

- 자바에서 charAt() 메서드의 리턴값은 char이고 원시 자료형인 데 반해, 코틀린에서 인덱스로 직접 접근해 추출한 결과는
원시 자료형이 아니라 Char 라는 코틀린 클래스로서 참조형이다
  - 코틀린은 경우에 따라 원시 자료형을 사용함

-----------

## 문자열 뒤집기

- 문자열을 뒤집는 함수를 작성하라. 입력값은 문자 배열이며, 리턴 없이 입력 배열 내부를 직접 조작하라

### 풀이 1) 문자 배열로 스왑

- 문자열에서 맨 앞 문자와 맨 뒤 문자를 추출한 다음 중앙에서 만날 때까지 서로 스왑 하면서 한 칸씩 이동하면 쉽게 해결 가능

```java
public void reverseString(char[] s) {
    int start = 0;
    int end = s.length - 1;
    while (start < end) {
        char temp = s[start];
        s[start] = s[end];
        s[end] = temp;
        start++;
        end--;
    }
}
```

### 풀이 2) 코틀린 풀이

- 자바의 스왑을 코틀린에서는 좀 더 편하게 작성할 수 있다
- s[start] = s[end].also { s[end] = s[start] }
- also는 코틀린에서 모든 객체에 기본적으로 제공하는 함수이며, 속성의 변경 없이 중괄호 내 명령이 실행됨

```kotlin
val numbers = mutableListOf(1,2,3)
numbers.add(4).also {println("$it")}
---
[1,2,3]
```

- numbers는 also 부분이 다 실행되기 전에 속성이 변하지 않기 때문에 1,2,3 이 먼저 출력되고 이후에 add가 실행됨
- s[start] = s[end].also { s[end] = s[start] }
  - also가 실행되는 시점에 속성이 변하지 않기 때문에 원래 값으로 s[end] = s[start]가 실행되고, 값이 변하지 않은 상태로 s[start] = s[end]가 됨

```kotlin
fun reverseString(s: CharArray): Unit {
    var start = 0
    var end = s.size - 1
    while (start < end) {
        s[start] = s[end].also {s[end] = s[start]}
        start++
        end--
    }
}
```

--------------

## 로그 파일 재정렬

- 로그를 재정렬하라 기준은 다음과 같다
  - 로그의 가장 앞부분은 식별자로서, 순서에 영향을 끼치지 않는다.
  - 문자로 구성된 로그가 숫자 로그보다 앞에 오며, 문자 로그는 사전순으로 한다.
  - 문자가 동일할 경우에는 식별자순으로 한다.
  - 숫자 로그는 입력 순서대로 한다

