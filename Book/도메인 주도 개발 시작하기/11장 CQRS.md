# CQRS

------------

## 단일 모델의 단점

- 주문 내역 조회 기능을 구현하려면 여러 애그리거트에서 데이터를 가져와야 한다.
  - Order에서 주문 정보, Product에서 상품 이름, Member에서 회원 이름과 ID
- 조회 화면 특성상 조회 속도가 빠를수록 좋은데 여러 애그리거트의 데이터가 필요하면 구현 방법을 고민해야 한다.
- 식별자를 이용해서 애그리거트를 참조하는 방식을 사용하면 즉시 로딩(Eager) 방식과 같은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없다.
- 한번의 쿼리로 조회 화면에 필요한 데이터를 읽어올 수 없어 조회 성능에 문제가 생길 수 있다.
- 식별자가 아니라 직접 참조하는 방식으로 연결해도 조회 화면 특성에 따라 같은 연관도 즉시 로딩이나 지연 로딩으로 처리해야 하기 때문에
고민거리가 생긴다.
- 조회 기능을 구현할 때 DBMS가 제공하는 전용 기능이 필요하면 JPA의 네이티브 쿼리를 사용해야 할 수도 있다.
- 이런 고민이 발생하는 이유는 시스템 상태를 변경할 때와 조회할 때 단일 도메인 모델을 사용하기 때문이다.
- 객체 지향으로 도메인 모델을 구현할 때 주로 사용하는 ORM 기법은 도메인 상태 변경 기능을 구현하는 데는 적합하지만 주문 상세 조회 화면처럼
여러 애그리거트에서 데이터를 가져와 출력하는 기능을 구현하기에는 고려할 게 많아서 구현을 복잡하게 만드는 원인이 된다.
- 이런 구현 복잡도를 낮추는 방법은 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다.

-------------

## CQRS

- 시스템이 제공하는 기능은 크게 두가지로 나눌 수 있다.
  - 상태 변경
    - 새로운 주문 생성, 배송지 정보 변경, 회원 암호를 변경...
    - 개발자는 현재 저장하고 있는 데이터를 변경하는 방식으로 기능을 구현
  - 상태 정보 조회
    - 주문 상세 내역 보기, 게시글 목록 보기, 회원 정보 보기...
    - 필요한 데이터를 읽어와 UI를 통해 보여주는 방식으로 구현
- 도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경하지만 조회 기능에 필요한 데이터를 표시하려면
두 개 이상의 애그리거트가 필요할 때가 많다.
- 상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.
- 단일 모델을 사용할 떄 발생하는 복잡도를 해결하기 위해 사용하는 방법이 있는데 바로 CQRS다.
- CQRS(Command Query Responsibility Segregation)의 약자로 상태를 변경하는 명령(Command)을 위한 모델과 상태를 제공하는 조회(Query)를 위한
모델을 분리하는 패턴이다.
- CQRS는 복잡한 도메인에 적합하다.
- CQRS를 사용하면 명령 모델은 객체 지향에 기반해서 도메인 모델을 구현하기에 적당한 JPA를 사용해서 구현하고, 조회 모델은 DB 테이블에서 SQL로 데이터를 조회
할 때 좋은 마이바티스를 사용해서 구현하면 된다.
- 명령 모델은 상태를 변경하는 도메인 로직을 수행하는 데 초점을 맞춰 설계하고, 조회 모델은 화면에 보여줄 데이터를 조회하는 데 초점을 맞춰 설계한다.

### 웹과 CQRS

- 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많다.
- 포털이나 대형 온라인 쇼핑몰과 같이 조회 기능 요청 비율이 월등히 높은 서비스를 만드는 개발팀은 조회 성능을 높이기 위해 쿼리를 최적화하고, 메모리에 조회
데이터를 캐싱해서 응답 속도를 높이기도 하며 조회 전용 저장소를 따로 사용하기도 하는 등 다양한 기법을 사용하는데 결과적으로
CQRS를 적용하는 것과 같은 효과를 만든다.
  - 메모리에 캐싱하는 데이터는 DB에 보관된 데이터를 그대로 저장하기보다는 화면에 맞는 모양으로 변환한 데이터를 캐싱 할 때 성능에 더 유리. 즉 조회
  전용 모델을 캐시
  - 조회 속도를 높이기 위해 쿼리를 최적화한다는 것은 조회 화면에 보여줄 데이터를 빠르게 읽어올 수 있도록 쿼리를 작성하는 것.
- 대규모 트래픽이 발생하는 웹 서비스는 알게 모르게 CQRS를 적용한다. 단지 명시적으로 명령 모델과 조회 모델을 구분하지 않을 뿐이다.
- 조회 속도를 높이기 위해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분하여 조회 기능 때문에 명령 모델이 복잡해지는 것을 막고
명령 모델에 관계없이 조회 기능에 특화된 구현 기법을 쉽게 적용하자

### CQRS 장단점

- 장점
  - 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다는 점.
    - 복잡한 도메인은 주로 상태 변경 로직이 복잡한데 명령 모델과 조회 모델을 구분하면 조회 성능을 위한 코드가 명령 모델에 없으므로 도메인 로직을
    구현하는 데 집중할 수 있다.
    - 명령 모델에서 조회 관련 로직이 사라져 복잡도가 낮아진다.
  - 조회 성능을 향상시키는 데 유리
    - 조회 단위로 캐시 기술을 적용할 수 있고, 조회에 특화된 쿼리를 마음대로 사용할 수 있다.
    - 캐시뿐만 아니라 조회 전용 저장소를 사용하면 조회 처리량을 대폭 늘릴 수 있다.
    - 조회 전용 모델을 사용하기 때문에 조회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않는다.
- 단점
  - 구현해야 할 코드가 더 많다.
    - 도메인이 복잡하거나 대규모 트래픽이 발생하는 서비스라면 조회 전용 모델을 만드는 것이 향후 유지 보수에 유리
    - 도메인이 단순하거나 트래픽이 많지 않은 서비스라면 조회 전용 모델을 따로 만들 때 얻을 이점이 있는 지 따져봐야 함
  - 더 많은 구현 기술이 필요하다
    - 명령 모델과 조회 모델을 다른 구현 기술을 사용해서 구현하기도 하고 경우에 따라 다른 저장소를 사용하기도 함.
    - 데이터 동기화를 위해 메시징 시스템을 도입해야 할 수도 있음.
- 도메인이 복잡하지 않은데 CQRS를 도입하면 두 모델을 유지하는 비용만 높아지고 얻을 수 있는 이점은 없다.
- 트래픽이 높은 서비스인데 단일 모델을 고집하면 유지 보수 비용이 오히려 높아질 수 있으므로 CQRS 도입을 고려하자.
