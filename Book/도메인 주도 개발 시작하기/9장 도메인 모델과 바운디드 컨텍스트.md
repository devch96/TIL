# 도메인 모델과 바운디드 컨텍스트

-----------------------

## 도메인 모델과 경계

- 처음 도메인 모델을 만들 때 빠지기 쉬운 함정이 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것인데,
한 도메인은 다시 여러 하위 도메인으로 구분되기 때문에 한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지
않은 모델을 만들게 된다.
  - 상품이라는 모델에서, 카탈로그의 상품, 재고 관리에서 상품, 주문에서 상품, 배송에서 상품은 이름만 같지 실제로 의미하는 것이 다르다.
  - 카탈로그에서의 상품은 상품 이미지, 상품 명, 가격, 옵션, 상세 설명과 같은 상품 정보 위주라면 재고 관리에서는 실존하는
  개별 객체를 추적하기 위한 목적으로 상품을 사용한다.
  - 카탈로그에서는 물리적으로 한 개인 상품이 재고 관리에서는 여러 개 존재할 수 있다.
- 논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.
  - 회원 도메인에서는 사람을 회원, 주문 도메인에서는 주문자, 배송 도메인에서는 보내는 사람이라고 부르기도 한다.
- 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을
표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.
- 하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다.
- 모델은 특정한 컨텍스트(문맥) 하에서 완전한 의미를 갖는다.
- 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트라고 부른다.

---------------------

## 바운디드 컨텍스트

- 바운디드 컨텍스트는 모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.
- 바운디드 컨텍스트는 용어를 기준으로 구분한다.
- 바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 물리적 시스테믕로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.
- 조직 구조에 따라 바운디드 컨텍스트가 결정되기도 한다.
- 여러 하위 도메인을 하나의 바운디드 컨텍스트 내에서 개발할 때의 주의점은 하위 도메인의 모델이 섞이지 않도록 하는 것이다.
- 한 개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 하며 이렇게 함으로써 하위 도메인을
위한 모델이 서로 뒤섞이지 않고 하위 도메인마다 바운디드 컨텍스트를 갖는 효과를 낼 수 있다.

---------------------

## 바운디드 컨텍스트 구현

- 바운디드 컨텍스트는 도메인 모델만 포함하는 것이 아닌 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭처
영역을 모두 포함한다.
- 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 테이블도 바운디드 컨텍스트에 포함된다.

------------------

## 바운디드 컨텍스트 간 통합

- 바운디드 컨텍스트 간의 통합은 다른 모델을 기반으로 데이터를 작성하고 있기 때문에 데이터를 일치시켜서 표현해야 하는 것을 중요시해야 한다.
```java
public class RecSystemClient implements ProductRecommendationService{
    private ProductRepository productRepository;
    
    @Override
    public List<Product> getRecommendationsOf(ProductId id){
        List<RecommendationItem> items = getRecItems(id.getValue());
        return toProducts(items);
    }
    
    private List<RecommendationItem> getRecItems(String itemId){
        return externalRecClient.getRecs(itemId);
    }
    
    private List<Product> toProducts(List<RecommendationItem> items){
        return items.stream()
                .map(item -> toProductId(item.getItemId()))
                .map(prodId -> productRepository.findById(prodId))
                .collect(toList());
    }
    
    private ProductId toProductId(String itemId){
        return new ProductId(itemId);
    }
}
```
- 두 모델 간의 변환 과정이 복잡하다면 변환 처리를 위한 별도 클래스를 만들고 이 클래스에서 변환을 처리해도 된다.
- REST API를 호출하는 것은 두 바운디드 컨텍스트를 직접 통합하는 방법이다.
- 메시지 큐를 사용하는 것은 간접적으로 통합하는 방식 중 대표적인 방법이다.
- 메시지 큐는 비동기로 메시지를 처리하기 때문에 반대쪽 컨텍스트가 메시지를 처리할 때까지 기다리지 않고 바로 이어서 자신의 처리를 계속 한다.

---------------------

## 바운디드 컨텍스트 간 관계

- 두 바운디드 컨텍스트 간 관계 중 가장 흔한 관계는 한쪽에서 API를 제공하고 다른 한쪽에서 그 API를 호출하는 관계이다.
  - REST API가 대표적
- 하류 컴포넌트인 API를 호출하는 컨텍스트는 상류 컴포넌트인 API를 제공하는 컨텍스트가 제공하는 데이터와 기능에 의존한다.
- 제공하는 REST API의 인터페이스가 바뀌면 하류 컴포넌트 시스템의 코드도 바뀌게 된다.
- 이런 상황에 있어서 두 팀의 상호 협력은 필수적이다.
- 상류 팀이 마음대로 API를 변경하면 하류 팀은 변경된 API에 맞추느라 우선순위가 높은 다른 기능을 개발하지 못할 수도 있고, 반대로 상류 팀이 무언가를
변경할 때마다 하류 팀으로부터 여러 절차를 거쳐 승낙을 받아야 한다면 상류 팀은 새로운 개발 시도 자체를 하지 않을 수도 있기에 상류 팀과 하류 팀은
개발 계획을 서로 공유하고 일정을 협의해야 한다.
- 상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다.
  - REST API를 제공하거나 프로토콜 버퍼와 같은 것을 이용해서 서비스를 제공할 수 있다.
- 하류 팀이 다수 존재하면 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다.
- 이러한 서비스를 가리켜 공개 호스트 서비스(Open Host Service)라고 한다.
- 두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있는데 이러한 모델을 공유 커널(Shared Kernel)이라고 부른다.
- 두 바운디드 컨텍스트가 아예 통합하지 않는 방식인 독립 방식도 있다.
- 독립방식에서는 수동으로 바운디드 컨텍스트를 통합해야 한다.
- 나중에 통합하려면 별도의 시스템을 만들어야 할 수도 있다.

--------------------

## 컨텍스트 맵

- 컨텍스트 맵은 바운디드 컨텍스트 간의 관계를 표시한 것이다.
- 컨텍스트 맵은 시스템의 전체 구조를 보여준다. 이는 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 도메인에 맞게 바운디드 컨텍스트를 조절하고
사업의 핵심 도메인을 위해 조직 역량을 어떤 바운디드 컨텍스트에 집중할지 파악하는 데 도움을 준다.
- 컨텍스트 맵을 그리는 규칙은 따로 없으며, 간단한 도형과 선을 이용해서 각 컨텍스트의 관계를 이해할 수 있는 수준에서 그리면 된다.