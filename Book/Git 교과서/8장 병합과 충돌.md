# 병합과 충돌

---------

## 병합

- 브랜치의 생성 목적은 원본 코드에 영향을 주지 않고 분리하여 개발하기 위함
- 독립된 브랜치에서 개발 작업이 끝나면 원본 브랜치에 작업한 결과를 반영해야 함
- 분리된 브랜치를 한 브랜치로 합치는 작업을 병합이라고 함

### 하나씩 직접 비교하는 수동 병합

- 수동으로 병합하려면 양쪽 파일을 일일이 비교하며 바뀐 점을 찾아서 적용해야 함
- 수천 줄 이상인 코드를 하나로 합치는 것은 매우 힘든 작업

### 깃으로 자동 병합

- 깃을 사용하면 복잡한 파일을 좀 더 간편하게 병합할 수 있음
- 깃의 자동 병합은 원본을 기준으로 두 파일의 변경 이력을 비교하고, 변경된 파일 내용이 발견되면 자동으로
수정된 코드 내용을 병합함
- 하지만 모든 코드의 병합을 완벽하게 처리할 수 없음. 이를 충돌이라 함

### 병합 방식

- 깃은 병합을 위해 두 가지 기본적인 알고리즘 방식을 제공
  - Fast-Forward 병합
  - 3-way 병합

------------

## Fast-Forward 병합

- 빨리 감기 병합
- 보통 혼자 개발할 때 사용
- 브랜치가 분기되지만 전체 커밋 그림으로 보면 모든 변경 사항은 순차적으로 진행됨.
- 순차적 커밋에 맞추어 병합을 처리하는 방법이 Fast-Forward 병합
- 서로 다른 브랜치이지만 순차적으로 커밋을 했기 때문에 브랜치 경로가 일직선으로 1개만 있음.
- 이런 모양의 브랜치에서 병합 작업을 할 때는 Fast-Forward 방식의 알고리즘이 적용

### 병합 위치

- 깃의 merge 명령어는 브랜치를 병합함
- 현재 브랜치를 기준으로 다른 브랜치의 모든 커밋을 병합함
- git merge 브랜치이름
- Fast-Forward 병합은 작업한 브랜치를 원본 브랜치에 병합할 때 작업한 브랜치의 시작 커밋을 원본 브랜치 이후의 커밋으로
가리킴
- 단순히 커밋 위치를 최신으로 옮기는 것과 비슷함

-------------

## 3-way 병합

- 여러 개발자와 협업으로 작업하는 경우 대부분 3-way 병합을 사용
- 기준 커밋에서 서로 다른 브랜치의 커밋이 연결됨.

### 공통 조상

- 브랜치별로 각각 커밋하면 두 브랜치로 갈라짐
- 브랜치 모양이 갈라지는 형태로 나뉠 때는 3-way 방식을 이용해야 함
- 두 브랜치를 병합하려면 분할 기준인 공통 커밋을 찾아야 하는데 이를 공통 조상 커밋이라고 함
- 공통 조상 커밋을 포함하는 브랜치, 새로운 두 브랜치 이렇게 3개를 하나로 병합해야 해서 3-way 병합이라고 함
- 깃은 3-way 병합을 할 때 공통 조상 커밋을 자동으로 찾아줌

### 병합 커밋

- 3-way 병합은 두 브랜치에서 공통 조상 커밋을 자동으로 찾아 주며, 공통 조상 커밋을 기준으로 브랜치를 병합함
- 병합을 성공적으로 완료한 후에는 새로운 커밋을 추가로 하나 생성함.
- 새로 생성된 커밋을 병합 커밋이라고 한다
- 병합 커밋의 부모는 2개(master, feature) 브랜치

### 병합 메시지

- 3-way 병합을 할 때는 새로운 병합 커밋이 생성됨.
- 커밋 메시지는 자동으로 삽입함
- 직접 작성할 수도 있음
- git merge 브랜치이름 -e or --edit

------------------

## 브랜치 삭제

- 일반적으로 병합한 이후에는 병합된 브랜치를 삭제함.
- 지속적인 통합과 개발을 해야 하는 브랜치라면 병합 후에도 계속 남겨 둠

### 깃 플로

- 깃 플로(git flow)는 브랜치 관리 기법
- 기본적으로 master, feature, develop, release, hotfix 브랜치가 있음.
- develop 브랜치는 master 브랜치에 병합한 후에도 삭제하지 않고 계속 유지함
- 오랫동안 유지하는 브랜치를 long-running 브랜치라고 함

### 병합 후 삭제

- 브랜치 삭제
- git branch -d 브랜치이름
- -d 옵션은 병합을 완료한 브랜치만 삭제할 수 있음
- 병합하지 않은 브랜치를 삭제하고 싶다면 -D 옵션 사용

---------------

## 충돌

### 충돌이 생기는 상황

- 같은 위치의 코드를 동시에 수정했기 때문
- 같은 위치를 동시에 수정하면 두 수정 중 어떤 것이 맞는지 깃에서 자동으로 알 수 없기 때문에 충돌이 발생함
- 깃은 충돌 오류라고 알려 주고, 개발자에게 직접 수정하여 충돌을 해결하라고 요청함
- 자동으로 병합하는 과정에서 충돌이 발생되면 깃은 "Merge Conflicts" 메시지를 출력하고 커밋되지 않은 변경 사항이 추가됨

### 수동으로 충돌 해결

- 병합 충돌이 발생하면 수동으로 해결해야 함
- 충돌은 두 부분으로 표시
  - '<<<<HEAD' : 현재 변경 사항
  - '>>>>브랜치이름' : 병합하려는 브랜치
- 충돌 내용을 수정할 때는 깃에서 표시한 충돌 기호도 함께 삭제해야 함
- 충돌이 발생하면 병합 커밋을 자동으로 생성하지 않기 때문에 충돌을 해결한 후 병합 커밋을 직접 만들어야 함
- 병합 커밋을 생성하면 충돌 마크가 사라짐(master|MERGING)

------------

## 브랜치 병합 여부 확인

- 병합한 브랜치와 병합하지 않은 브랜치 구분 옵션
  - git branch --merged
  - 병합한 브랜치는 별표 기호로 표시
- 병합하지 않은 브랜치
  - git branch --no-merged

---------------

## 리베이스

- 리베이스는 커밋의 트리 구조를 재배열하는 것
- 커밋을 재배열하는 변경 결과가 병합과 유사
- 실무에서는 merge 명령어보다 커밋을 재배열하는 리베이스를 더 선호함

### 베이스

- 마스터 브랜치를 제외한 모든 브랜치는 뿌리가 있음
- 브랜치는 특정 커밋을 가리키는 포인터
- 가리키는 특정 커밋은 파생된 기준
- 브랜치가 파생되는 커밋을 베이스라고 함(병합에서는 공통 조상 커밋)

### 베이스 변경

- 파생된 브랜치의 기준이 되는 베이스 커밋을 변경하는 것
  - 커밋의 진행 모습을 단순화하기 위함
- 브랜치가 많아지면 커밋을 관리하고 파악하기 어려움. 꼬여 있는 기찻길처럼 단계별로 커밋을 따라가면서 코드를 확인해야 하는데
한 눈에 파악하기 힘듬
- 리베이스는 코드의 분기점을 변경하여 하나의 기찻길처럼 만듬
- 진행 사항 쉽게 파악 가능
- 공통 조상 커밋을 master 브랜치의 마지막 커밋으로 변경하고 재정렬하는 것

### 리베이스 vs 병합

- 병합은 두 브랜치를 하나로 합치는 과정
- 병합하는 두 브랜치는 순차적으로 커밋을 비교하면서 마지막 최종 커밋을 생성함
- 리베이스는 두 브랜치를 서로 비교하지 않고 순차적으로 커밋 병합을 시도함

### 리베이스 명령어

- git rebase 브랜치

### 리베이스 병합

- 리베이스는 병합 기준 브랜치가 merge 명령어랑 반대
- 리베이스 명령이 실행되면 파생 브랜치의 커밋들은 기준 브랜치의 마지막 커밋으로 재정렬됨

### 리베이스되었는지 확인

- 베이스 커밋을 변경하는 과정에서 커밋들은 재배치 작업을 함
- 커밋의 해시 값이 변경됨

### 리베이스 후 브랜치

- 리베이스 병합 이후 커밋은 정리되었지만 브랜치 모양이 다름
- 리베이스는 커밋 위치를 재조정할 뿐 브랜치의 HEAD 포인터까지 옮겨 주지는 않음.
- 리베이스한 후에는 병합 브랜치의 HEAD를 맞추어야함
- 리베이스된 브랜치를 병합해야 함
  - Fast-forward로 됨

### 리베이스 충돌과 해결

- 리베이스는 병합 과정에서 충돌이 발생할 수 있음
- 충돌 또한 직접 수동으로 해결해야 함
- merge와 동일하게 충돌 기호가 있음
- 충돌을 수정한 후엔 --continue 옵션을 사용
- git rebase --continue

### rebase 명령어로 커밋 수정

- 마지막 커밋은 --amend 옵션으로 수정할 수 있음
- 실제 병합은 아니지만 리베이스는 커밋 위치를 재조정하여 병합과 유사한 효과를 보이기 때문에 최종 커밋을 수정할 수 있음.
- 리베이스는 커밋을 재조정하는 것 외에도 여러 커밋을 한 커밋으로 묶을 수 있는데 이때는 -i 옵션을 사용함

### 리베이스할 때 주의점

- 리베이스는 커밋 위치와 해시 값을 변경하므로 저장소를 외부에 공개했다면 공개된 순간부터 커밋은 리베이스를 사용하지 안흔ㄴ 것이 원칙
- 외부로 코드를 푸시하거나 공개하기 전에 로컬에서만 실행하는 것이 좋음
- 공개된 커밋을 변경할 때는 revert 명령어를 사용
- 