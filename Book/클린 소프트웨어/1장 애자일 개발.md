# 애자일 개발

- 프로그래머들의 팀은 프로세스에 의해 제어되는 컴포넌트들로 구성된 시스템처럼 다룰 수 없다.
- 인간은 호환성 있는 프로그래밍 단위가 아님
- 프로젝트가 성공하기 위해서는 협력적이고 자율 조직적인 팀을 구성해야 함

--------

## 애자일 실천 방법

### 애자일 연합

- 많은 회사의 소프트웨어 팀이 계속 늘어나기만 하는 프로세스의 수렁에 빠져 있다는 관찰에 자극받아, 소프트웨어 팀이
빠르게 일하고 변화에 반응할 수 있도록 하는 가치와 원칙을 세우기 위해 이 분야의 전문가들이 모임을 함
- 몇 달 동안 가치 성명서를 작성하기 위해 연구했는데 그 결과가 애자일 소프트웨어 개발 선언문

#### 애자일 소프트웨어 개발 선언문

- 프로세스와 툴보다 개인과 상호작용이 우선이다.
  - 사람은 성공의 가장 중요한 요소.
  - 뛰어난 팀원이란 꼭 에이스 프로그래머만을 말하는 것이 아닌 다른 동료와 함께 조화롭게 일할 수 있는 사람
  - 동료와 함께 일하고, 대화하고, 상호작용하는 능력은 다듬어지지 않은 프로그래밍 실력보다 더 중요함
  - 팀을 구성하는 일은 환경을 구축하는 일보다 더 중요하다.
- 포괄적인 문서보다 동작하는 소프트웨어가 우선이다.
  - 문서화되어 있지 않은 소프트웨어는 재앙이지만, 지나친 문서화는 안 하느니만 못하다.
  - 문서와 코드가 동기화되지 않는다면 서로 내용이 맞지 않아 그릇된 방향으로 프로그래머를 유도하는 주요 원인이 될 것이다.
  - 팀에서 설계 원리와 구조에 대한 문서를 쓰고 유지하는 것은 바람직하지만 그 문서는 짧고 요약적이어야 한다.
    - 새로운 팀원이 시스템에 적응하도록 훈련은 친밀하게 일하는 것. 옆에서 가르쳐주지
- 계약 협상보다 고객 협력이 우선이다.
  - 성공적인 프로젝트를 위해서는 규칙적으로 자주 고객의 피드백을 받아야 한다.
- 계획을 따르는 것보다 변화에 대한 반응이 우선이다.
  - 요구사항은 점점 발전하고 다양해지기 때문에 계획을 크게 세우는 것은 의미가 없다.
  - 바람직한 계획 전략은 다음 2주간의 세부적인 계획을 수립하고, 3개월간의 개략적인 계획, 그 이후는 대강의 계획을 세우는 것

### 원칙

- 우리의 최고 가치는 유용한 소프트웨어의 빠르고 지속적인 공개를 통해 고객을 만족시키는 것이다.
  - 자주 공개할수록, 최종 품질도 좋아짐
  - 애자일 실천방법은 빨리, 자주 공개하는 것
    - 기본적인 시스템을 프로젝트 시작 후 처음 몇 주 안에 공개
    - 2주마다 기능성을 증가시킨 시스템을 계속 공개하려고 노력
- 개발 후반부에 접어들었다 할지라도, 요구사항 변경을 환영하라. 애자일 프로세스는 고객의 경쟁 우위를 위해 변화를 이용한다.
  - 태도의 선언
  - 애자일 프로세스의 일원은 변화를 걱정하지 않음
  - 애자일 팀은 소프트웨어의 구조를 탄력적으로 유지하기 위해 노력하고, 요구사항이 변경됐을 때 시스템에 미치는 영향은 최소한의 것이 됨
- 개발 중인 소프트웨어를 2주에서 2달 사이, 혹은 더 짧은 시간 간격으로 자주 공개하라.
  - 문서와 계획 꾸러미를 공개하는 것만으로 만족하지 않음
    - 진짜 공개가 아님
  - 고객의 요구를 만족시키는 소프트웨어를 공개
- 업무를 하는 사람과 개발자는 프로젝트를 통틀어 계속 함께 일해야 한다.
  - 프로젝트를 빠르게 진행하기 위해서는 고객과 개발자, 이해당사자 사이에 상당한 양의 빈번한 상호작용이 있어야 함
- 의욕적인 개인들을 중심으로 프로젝트를 구성하라. 환경과 필요로 하는 자원을 제공하고, 그들이 그 일을 해낼 것이라 믿고 맡겨둬라.
  - 애자일 프로젝트에서는 사람이 성공의 가장 중요한 요소.
- 개발 팀 내에서 정보를 전달하고 공유하는 가장 효율적이고 효과적인 방법은 직접 일대일로 대화하는 것이다.
  - 애자일 프로젝트 팀은 문서로 작성된 명세, 계획, 설계를 필요로 하지 않는다.
  - 꼭 필요한 것은 대화다.
- 개발 중인 소프트웨어가 진척 사항의 일차적 척도다.
  - 진척 사항을 현재 고객의 요구를 충족시키고 있는 소프트웨어의 비율로 측정
  - 필수적인 기능 30%가 제대로 되어 있다면 30% 완료된 것
- 애자일 프로세스는 지속 가능한 개발을 촉진한다. 스폰서, 개발자, 그리고 사용자는 무한히 지속적인 페이스를 유지할 수 있어야 한다.
  - 팀은 빠르지만 지속 가능한 속도로 나아가야 한다.
- 우수 기술과 좋은 설계에 대한 지속적인 관심은 속도를 향상한다.
  - 높은 품질은 빠른 속도에 있어 중요한 요소다.
  - 프로젝트를 빠르게 진행하는 방법은 소프트웨어를 가능한 한 깨끗하고 튼튼한 상태로 유지하는 것
  - 애자일 팀원은 철저하게 자신이 작성할 수 있는 가장 높은 품질의 코드만 만들고 나중에 문제를 해결할 것이라고 합리화하지 않음
- 단순성(아직 끝내지 않은 일의 양을 최대화하는 예술)은 필수적이다.
  - 항상 목표와 일치하는 가장 단순한 길을 택한다.
  - 내일의 문제를 예상하는데 지나친 관심을 두지 않고 오늘 그 모든 문제에 대한 방지책을 세우려 하지 않음
- 최고의 아키텍처, 요구사항, 그리고 설계는 자기 조직적인 팀에서 나온다.
  - 팀원 한 명이 아키텍처나 요구사항, 또는 테스트를 담당하는 것이 아니라 팀 전체가 이 책임을 공유한다.
- 규칙적으로 팀은 좀 더 효과적인 방법을 반영해야 하고, 적절히 그 행위를 조율하고 조정해야 한다.
  - 애자일 팀은 자신들을 둘러싼 환경이 계속 변하고 있다는 사실을 알고, 빠른 속도를 유지하기 위해 그 환경과 함께 변화해야 한다는 점도 이해한다.

### 결론

- 애자일 소프트웨어 개발의 원칙과 가치는 개발 팀이 프로세스 증가 악순환을 깨고 그들의 목표에 다다르기 위해 간단한 테크닉에 초점을 맞추는 것을
돕기 윟나 방법으로서 만들어졌다.

-----------

## 익스트림 프로그래밍 소개

### 익스트림 프로그래밍 실천방법

- 익스트림 프로그래밍(XP: Extreme Programming)은 애자일 방법 중에서도 가장 유명한데 단순하면서도 서로 의존적인 실천방법의 집합으로
구성되어 있다.
- 각 부분보다는 큰 전체를 구성하기 위한 프로그래밍 방법이다.

#### 고객 팀 구성원

- XP 팀의 고객은 기능 요소를 정의하고 우선순위를 매기는 개인 또는 그룹
  - 같은 회사에서 일하는 업무 분석가나 마케팅 전문가
  - 사용자를 대신하는 대리인
  - 현금을 지급하는 고객
- 고객이 누구든 간에 팀의 멤버이며 팀에서 일할 수 있다.
- 고객이 가까운 공간에 일하면 같은 팀으로 일하기 쉬워지며, 멀어지면 멀어질수록 팀으로 끌어들여 통합하기는 어려워진다.
- 고객이 가까운 곳에 있을 수 없다면 실제 고객을 대신할 수 있고 그럴 의지가 있는 사람을 찾아라

#### 사용자 스토리

- 프로젝트 일정 계획을 세우기 위해서는 요구사항에 대해 알아야 하지만 아주 자세히 알 필요는 없음
  - 요구사항의 구체적인 세부 내용은 시간이 지남에 따라 바뀌기 쉽기 때문.
  - 고객이 시스템이 동작하는 것을 보면서부터 더욱 그럼
- XP를 사용할 때는 고객과 대화함으로써 요구사항의 세부 내용에 대한 감을 잡지만, 세부 사항을 기록하지는 않음
- 사용자 스토리란 현재 진행 중인 요구사항에 관한 대화의 연상 기호

#### 짧은 반복

- XP 프로젝트는 개발 중인 소프트웨어를 2주마다 공개함
- 2주마다 반복되는 작업은 이해당사자의 어떤 요구를 처리하는 소프트웨어를 만들어내고, 각 반복 끝마다 이해당사자의 피드백을 받기 위한 시연을 함
- 반복 계획
  - 보통 2주 단위
  - 최종 제품에 반영될 수도, 그렇지 않을 수도 있는 마이너 공개
  - 이전 반복에서 얼마나 완성할 수 있었는가를 측정하여 각 반복의 예산을 세움
  - 반복이 시작되면 고객은 그 반복 동안에는 스토리 정의나 우선순위를 바꾸지 않는다고 동의함
  - 개발자는 스토리를 자유롭게 태스크에 나눠 넣고 기술적, 업무적으로 가장 합리적인 순서로 그 태스크를 수행함
- 릴리즈 계획
  - 보통 6번의 반복 일정을 정밀하게 표현하는 릴리즈 계획을 만듬
  - 대략 3개월 동안을 의미
  - 보통 최종 제품에 포함되는 메이저 공개
  - 이전 릴리즈에서 얼마나 완성할 수 있었는가를 측정하여 릴리즈의 예산을 세움

#### 인수 테스트

- 사용자 스토리의 세부 사항은 고객이 명시한 인수 테스트의 형태로 기록됨
- 시스템이 인수 테스트를 통과하면, 통과한 테스트의 본문에 추가되고 다시 실패하는 것이 허용되지 않음.
- 인수 테스트가 실패하면 그 빌드는 실패를 선언함

#### 짝 프로그래밍

- 각 짝의 한 멤버는 키보드를 잡고 코드를 입력하고, 다른 한 멤버는 입력되는 코드를 보면서 에러와 개선점을 찾음
- 두 프로그래머는 아주 긴밀히 상호작용함
- 짝의 역할은 자주 바뀔 수 있음
- 짝도 적어도 하루에 한 번 바뀌어 모든 프로그래머가 매일 서로 다른 두 짝으로서 일할 수 있게 해야 함
- 이런 방식은 팀 내부에서 지식이 더 빨리 확산되게 함

#### 테스트 주도 개발

- 모든 운영 코드는 실패하는 단위 테스트를 통과하기 위해 작성됨
- 실패하는 단위 테스트 프로그램을 작성하고, 그 다음 테스트를 통과하는 코드를 작성함
- 테스트 케이스와 코드는 함께 진화한다.
- 이런 방식은 리팩토링을 굉장히 용이하게 만듬

#### 공동 소유권

- 아무도 어떤 모듈이나 기술에 대해 다른 사람보다 더한 권한을 갖지 않음.
- 전문성을 부정한다는 뜻이 아님

#### 지속적인 통합

- 프로그래머는 자신의 코드를 체크인(커밋)하고 하루에 몇 번씩 그것을 통합함
- 첫 번째로 체크인한 사람을 우선으로 하여 나머지 사람의 코드를 병합함

#### 지속 가능한 속도

- 팀이 지속 가능한 페이스로 달려서 에너지와 경각심을 보존해야만 함
  - 꾸준히, 적당한 속도
- XP 규칙은 팀이 초과 근무를 하지 않도록 해야 한다는 것
  - 유일한 예외는 릴리즈의 마지막 주
  - 릴리즈라는 골에서 아주 가까운 거리라면 전력 질주

#### 열린 작업 공간

- 팀은 열린 공간에서 함께 일함
- 생산성을 저하하지 않음

#### 계획 세우기 게임

- 각 릴리즈와 반복을 시작할 때 개발자는 가장 최근의 반복이나 릴리즈에서 완성할 수 있었던 양을 기준으로 예산을 세워 고객에게 제출
- 고객은 총비용의 합이 예산을 넘지 않는 정도로 스토리를 선택
- 고객은 개발자가 얼마나 빨리 진행할 수 있는지에 대한 감을 잡고 이를 기반으로 프로젝트의 소요 기간과 비용을 정할 수 있음

#### 단순한 설계

- XP 팀은 설계를 가능한 한 단순하고 표현적으로 만듬
- 현재 반복에서 작업하기로 계획했던 스토리에만 초점을 맞추어 공략함
- 다음에 작업할 스토리에 대해 걱정하지 않는 대신 한 반복에서 다음 반복으로 넘어갈 때 시스템의 설계를 마이그레이션해서, 시스템이 현재 구현하고 있는
스토리에 가장 적합한 설계가 되도록 함
- 세 가지 XP 지침
  - 어떻게든 동작하는 가장 단순한 것을 생각한다.
    - 항상 현재의 스토리 묶음에 적용할 수 있는 가장 간단한 설계 옵션을 찾으려 노력
    - 실제로 구현할 수 있을 정도로 최대한 단순한 솔루션을 선택
  - 필요하지 않을 것이라는 가정에서 시작한다.
    - 확실히 필요해지기 전에 기반구조를 추가하고 싶은 유혹에 저항해야 함
    - 팀은 지금 기반구조를 추가하는 것이 기다리는 것보다 비용 면에서 효과적이라는 확실한 증거가 있을 때 혹은 강한 근거가 있을 때 비로소
    기반구조를 추가함
  - 코드를 중복해서 쓰지 않는다.
    - 중복의 원인이 무엇이든 간에 발견되면 그대로 두지 않는다.

#### 리팩터링

- 코드는 부패하기 쉽다.
- 망가진 코드는 온통 엉키고 유지보수할 수 없는 엉망진창인 코드가 되어버리고 만다.
- 행위에 영향을 주지 않고 시스템의 구조를 개선하는 일련의 작은 변환을 만드는 방식인 리팩토링을 XP 팀은 자주 사용한다.

#### 메타포

- 메타포(metaphor)는 XP의 모든 방식 중 가장 이해하기 어려운 것에 속함
- 메타포는 전체 시스템을 하나로 묶는 큰 그림

### 결론

- 익스트림 프로그래밍은 애자일 개발 프로세스를 구성하는 단순하고 구체적인 방식의 집합

------------

## 계획 세우기

### 초기 탐색

- 프로젝트를 시작하면서 개발자와 고객은 중요한 사용자 스토리를 가능한 한 모두 확정하려고 하지만 전부 확정하려고 하지는 않는다.

#### 스파이크, 분할, 속도

- 너무 크거나 너무 작은 스토리는 추정하기 어렵다.
- 사용자는 계좌에 안전하게 돈을 넣고, 꺼내고, 이체할 수 있어야 한다는 스토리는 너무 큰 스토리
  - 여러 개의 스토리로 분할해야 함
  - 로그인
  - 로그아웃
  - 입금
  - 인출
  - 이체 등
- 스토리가 분할되거나 합쳐지면 다시 추정해야 한다.
  - 추정사항을 단순히 더하거나 빼는 것은 좋지 않다.
- 스토리의 정확한 크기를 알기 위해서는 속도라는 요소가 필요하다
  - 속도가 스토리의 포인트당 2일
  - 4개의 포인트
  - 스토리를 구현하는 데는 8일
- 프로젝트가 진행됨에 따라 각 반복마다 완료한 스토리의 포인트 수를 측정할 수 있기 때문에 속도는 점점 더 정확하게 측정됨
  - 처음에는 개발자가 속도를 정확히 알 수 없음
  - 며칠만 투자해도 한두 개의 스토리로 프로타입을 만들어보면서 팀의 속도를 알 수 있는데 이 단계를 스파이크라 함

### 릴리즈 계획 세우기

- 개발자와 고객이 프로젝트의 첫 번째 릴리즈 날짜를 정하는데 보통은 2~4달 후 정도다.
- 고객은 그 릴리즈에 구현되었으면 하는 스토리와 대략적인 구현 순서를 선택한다.
- 처음에는 속도가 정확하지 않기 때문에 이 선택은 완벽하지 않으나 이 시점에서 정확성은 그리 중요치 않다.
- 릴리즈 계획은 속도가 점점 더 정확해짐에 따라 조정될 수 있다.

### 반복 계획 세우기

- 보통 2주
- 첫 반복에 구현되었으면 하는 스토리를 선택
- 모든 스토리 구현이 완료되지 않은 경우에도 반복은 정해진 날짜에 끝난다.
- 속도를 계산하고, 다음 반복의 계획을 세우는 데 이용된다.

### 태스크 계획 세우기

- 개발자는 스토리를 분할해 개발 태스크로 만드는데, 이때 태스크는 한 개발자가 4~16시간 동안 구현할 수 있는 것
- 개발자는 구현하려는 각 태스크에 하나씩 참여하여 작업

### 반환점

- 반복이 반쯤 진행됐을 때 팀은 미팅을 가짐
  - 이 시점에서 반복에 계획한 스토리의 반 정도가 완료되어 있어야 함
  - 스토리의 반이 완료되어 있지 않다면 팀은 태스크와 책임을 재분배
- 태스크만 완료하는 것이 아닌 스토리를 완료해야 함

### 반복

- 2주
- 각 반복의 마지막에는 현재 동작을 실행 가능한 부분을 고객 앞에서 시연

### 결론

- 반복에서 반복, 릴리즈에서 릴리즈로 넘어가면서 프로젝트는 예측 가능하고 안정적인 리듬을 찾아감
- 개발자는 스스로 추정한 소요 시간에 기반하여 스스로 측정한 속도에 의해 제어된느 합리적인 계획을 알 수 있음.
- 관리자는 각 반복마다 데이터를 얻어내고, 이 데이터를 이용해 프로젝트를 제어하고 관리함

------------

## 테스트

- 하나의 단위 테스트를 작성하는 일은 단순한 검증이라기보다는 설계, 문서화의 문제이다.

### 테스트 주도 개발

- 테스트 주도 개발의 가장 명백한 효과는 프로그램의 모든 단일 함수가 동작을 작을 검증하는 테스트를 갖게 된다는 것
- 테스트 집합은 그 이후의 개발을 위한 뒷받침이 되어 프로그래머가 기존의 어떤 기능을 부주의하게 망가뜨릴 때마다 그 사실을 알려준다.
- 테스트를 먼저 작성할 경우 프로그래머가 다른 관점에서 문제를 해결할 수 있다.
  - 호출자 관점에서 봐야 하기 때문에 프로그램의 함수만큼이나 인터페이스에도 바로 관심을 가져야 한다.
  - 편리하게 호출할 수 있는 소프트웨어를 설계할 수 있음
- 테스트를 먼저 작성함으로써 프로그래머는 자신이 반드시 테스트 가능한 프로그램을 설계하도록 강제할 수 있음
  - 프로그래머가 소프트웨어를 다른 환경과 분리하도록 강제

### 테스트 분리

- 운영 코드를 만들기 전에 테스트를 먼저 작성할 경우 소프트웨어에서 분리해야 할 부분이 드러나곤 한다.
- 테스트 대상 관련 요소 사이에 인터페이슬르 추가하고 이 인터페이스를 구현하는 테스트 스텁을 생성한다.

### 운 좋게 얻은 분리

- 테스트에서 모듈 분리에 대한 필요성은 프로그래머가 프로그램 전체 구조에 이득이 되는 방식으로 분리 작업을 하도록 강제한다.
  - 코드보다 테스트를 먼저 작성하면 설계가 개선된다.

### 인수 테스트

- 단위 테스트는 필수적이지만 검증 툴로서는 불충분하다.
- 단위 테스트는 시스템의 개별적인 메커니즘을 검증하는 화이트박스 테스트(모듈의 내부 구조를 알고 그것에 의존)
- 인수 테스트는 고객의 요구사항이 충족되고 있는지를 검증하는 블랙박스 테스트(모듈의 내부 구조를 모르고 그것에 의존하지 않음)
- 인수 테스트를 먼저 작성하면 시스템의 아키텍처에 큰 영향을 준다.
  - 시스템을 테스트 가능하게 만들려면 시스템은 상위 아키텍처 수준에서 주위 환경으로부터 분리되어야 한다
    - UI는 인수테스트가 UI를 통하지 않고도 업무 규칙에 접근할 수 있는 것과 같은 식으로 업무 규칙으로부터 분리되어야 함
- 단위 테스트가 프로그래머로 하여금 작은 단위에서 뛰어난 설계 의사결정을 할 수 있게 만드는 것과 마찬가지로, 인수 테스트는 프로그래머로 하여금 큰 단위에서
뛰어난 아키텍처 의사결정을 할 수 있게 해준다.

### 결론

- 일련의 테스트를 실행하는 것이 간단할수록 테스트는 좀 더 자주 실행되며, 테스트를 많이 실행할수록 이 테스트에 어긋나는 것들을 좀 더 빨리 찾게 된다.
- 검증은 테스트 작성이 주는 이점 중 하나일 뿐 아키텍처와 설계에 미치는 효과가 가장 중요한 이점이다.

---------------------

## 리팩토링

- 리팩토링은 외부 행위를 바꾸지 않으면서 내부 구조를 개선하는 방법으로 소프트웨어 시스템을 변경하는 프로세스이다.
  - 왜 제대로 동작하는 코드의 구조를 개선해야 할까?
- 모든 소프트웨어 모듈에는 세 가지 기능이 있다.
  - 실행 중에 동작하는 기능
    - 모듈의 존재 이유
  - 변경 기능
    - 모듈이 생명주기 동안에 변경 과정을 겪게 되고, 가능하면 간단하게 그런 변경을 할 수 있도록 만드는 것이 개발자의 책임
    - 변경하기 어려운 모듈은 그것이 제대로 동작한다 하더라도 이미 망가진 것
  - 읽는 사람과의 의사소통 기능
- 읽기 쉽고 변경하기 쉽게 만들려면?
  - 주의력과 훈련, 미를 창조하기 위한 열정

### 결론

- 한 번만 호출되는 함수를 추출해낼 경우 성능에 부정적인 영향을 주는 건 아닌지 걱정하는 사람도 있는데 향상된 가독성이 몇 나노초 단위의 가치가
있다.
  - 성능의 손해는 무시할 수 있다 가정하고, 그것이 틀렸다는 것이 증명될 때까지 기다림
- 리팩토링은 저녁식사 후에 부엌을 청소하는 것과 비슷
- 코드의 깔끔함은 아무리 강조해도 부족