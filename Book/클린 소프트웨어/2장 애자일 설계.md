# 애자일 설계

- 기민성(agility)이 아주 조금씩 소프트웨어를 만들어나가는 것을 의미한다면 소프트웨어 설계는?
- 애자일 팀에서 큰 그림은 소프트웨어와 함께 발전한다.
  - 반복에서 팀은 시스템의 설계를 개선해 지금 그대로도 충분히 가능한 한 제일 좋은 시스템이 되도록 한다
  - 나중의 요구사항과 필요에 대해서는 그리 오래 생각하지 않는다

### 잘못된 설계의 증상

- 경직성(Rigidity)
  - 설계를 변경하기 어려움
- 취약성(Fragility)
  - 설계가 망가지기 쉬움
- 부동성(Immobility)
  - 설계를 재사용하기 어려움
- 점착성(Viscosity)
  - 제대로 동작하기 어려움
- 불필요한 복잡성(Needless Complexity)
  - 과도한 설계
- 불필요한 반복(Needless Repetition)
  - 마우스 남용
- 불투명성(Opacity)
  - 혼란스러운 표현

### 원칙

- SRP: 단일 책임 원칙(Single Responsibility Principle)
- OCP: 개방 폐쇄 원칙(Open-Closed Principle)
- LSP: 리스코프 치환 원칙(Liskov Substitution Principle)
- ISP: 인터페이스 분리 원칙(Interface Segregation Principle)
- DIP: 의존 관계 역전 원칙(Dependency Inversion Principle)

### 악취와 원칙

- 설계의 악취는 하나의 증상이고 대개 이런 악취는 하나 이상의 원칙을 위반했을 때 발생
  - 경직성의 악취는 많은 경우 개방 폐쇄 원칙에 충분히 주의를 기울이지 않았기 때문에 발생
- 애자일 팀은 악취를 제거하기 위해 원칙을 적용함
  - 아무 악취도 나지 않으면 원칙을 적용하지 않음
  - 원칙이라는 이유만으로 무조건 따르는 것은 좋지 않음
- 원칙에 대한 맹종은 불필요한 복잡성이란 설계의 악취로 이어짐

----------------

## 애자일 설계란 무엇인가?

- 설계는 소스 코드에 의해 문서화되며, 소스 코드를 표현하는 다이어그램은 설계에서 부수적인 것일 뿐 설계 그 자체가 아니다.
  - 설계는 코드와는 별개의 UML 다이어그램을 뜻하는 것이 아니다.
  - 일련의 UML 다이어그램이 설계의 일부를 나타낼 수는 있지만 설계 자체는 아니다.
- 설계는 추상적인 개념으로, 구체적인 각 모듈, 클래스, 메서드의 형태와 구조뿐만 아니라 프로그램의 전체 형태와 구조와도 관련되어 있다.
- 소스 코드가 바로 설계다.

### 소프트웨어에서 어떤 것이 잘못되는가?

- 기존 시스템은 계속 발전하고 변경되며, 새로운 설계는 그것을 쫓아가야 한다.
- 새로운 설계가 첫 번째 릴리즈에 이르기도 전에 혹과 궤양이 새로운 설계에 생기는 셈

### 설계의 악취: 부패하고 있는 소프트웨어 냄새

- 경직성
  - 시스템을 변경하기 어렵다.
  - 변경 하려면 시스템의 다른 부분들까지 많이 변경해야 하기 때문.
- 취약성
  - 변경을 하면 시스템에서 그 부분과 개념적으로 아무런 관련이 없는 부분이 망가진다.
- 부동성
  - 시스템을 다른 시스템에서 재사용할 수 있는 컴포넌트로 구분하기가 어렵다.
- 점착성
  - 옳은 동작을 하는 것이 잘못된 동작을 하는 것보다 더 어렵다.
- 불필요한 복잡성
  - 직접적인 효용이 전혀 없는 기반구조가 설계에 포함되어 있다.
- 불필요한 반복
  - 단일 추상 개념으로 통합할 수 있는 반복적인 구조가 설계에 포함되어 있다.
- 불투명성
  - 읽고 이해하기 어렵다
  - 그 의도를 잘 표현하지 못한다.

#### 무엇이 소프트웨어의 부패를 촉진하는가?

- 애자일이 아닌 환경에서는 초기 설계에서 예상하지 않았던 요구사항의 변경 때문에 설계가 퇴화하게 됨
  - 이런 변경은 빠르게 이루어져야 하고, 설계 철학에 익숙하지 않은 개발자들이 맡음
  - 설계를 변경할 수는 있지만 기존의 설계를 위반하는 일

#### 애자일 팀은 소프트웨어가 부패하도록 내버려두지 않는다

- 애자일 팀은 변경을 보람으로 삼기 때문에 팀은 약간 미리 노력을 쏟는다.
  - 노화된 초기 설계에 귀속되는 것이 아닌 시스템의 설계를 가능한 한 명료하고 단순하게 유지
    - 단위 테스트와 인수 테스트로 뒷받침

### 가능한 한 좋은 상태로 설계 유지하기

- 애자일 개발자는 몇 주마다 한 번씩 설계를 청소하지 않고, 매 시간, 소프트웨어를 간으한 명료하고 간단하고 표현적인 상태로 유지한다.
- 설계는 명료한 상태로 유지되어야 하고, 설계의 가장 중요한 표현인 소스 코드 역시 명료한 상태로 유지되어야 한다.

### 결론

- 애자일 설계는 과정이지 결과가 아니다.
- 원칙, 패턴, 소프트웨어의 구조와 가독성을 향상하기 위한 방식의 연속적인 적용

----------------

## 단일 책임 원칙(SRP)

### 단일 책임 원칙(SRP)

- 한 클래스는 단 한가지의 변경 이유만을 가져야 한다.
- 하나의 책임은 변경의 축이다.
  - 요구사항이 변경될 때 이 변경은 클래스 안에서의 책임 변경을 통해 명백해진다.
    - 한 클래스가 하나 이상의 책임을 맡는다면, 그 클래스를 변경할 하나 이상의 이유가 있는 것
- 한 클래스가 하나 이상의 책임을 맡는다면, 그 책임들은 결합되어 한 책임에 대한 변경은 다른 책임을 충족시키는
클래스의 능력을 떨어뜨리거나 저하시킬 수도 있다.
  - 이러한 결합은 변경했을때 예상치 못한 방식으로 잘못 동작하는 취약한 설계를 유발

#### 책임이란 무엇인가?

- 책임(responsibility)는 '변경을 위한 이유'
  - 한 클래스를 변경하기 위한 한 가지 이상의 이유를 발견한다면 한 가지 이상의 책임을 갖고 있음
- 책임을 알아차리기 어려운 이유는 우리가 책임을 묶어서 생각하는 데 익숙해져 있기 때문

```java
interface Modem {
    void dial(String pno);
    void hangup();
    void send(char c);
    char recv();
}
```

- 이 인터페이스는 매우 타당해보이나 연결 관리와 데이터 통신이라는 2개의 책임이 있음
  - dial과 hangup 함수는 모뎀의 연결을 관리
  - send와 recv 함수는 데이터 통신
- 애플리케이션이 어떻게 바뀌느냐에 따라 두 책임이 분리되어야 할수도 아닐수도 있음
  - 애플리케이션이 연결 함수의 시그니처에 영향을 주는 방식으로 바뀐다면 send와 recv를 호출하는 클래스는
  좀 더 자주 재컴파일, 재배포되어야 할 것이므로 이 설계는 경직성의 악취를 풍김
  - 애플리케이션이 서로 다른 시간에 두 가지 책임의 변경을 유발하는 방식으로 바뀌지 않는다면 이들은 불리할 필요가 없음
    - 오히려 분리하면 불필요한 복잡성이란 악취를 풍김
- 변경의 축은 변경이 실제로 일어날 때만 변경의 축
- 아무 증상도 없는데 SRP나 다른 원칙을 적용하는 것은 현명하지 못함

#### 영속성

- 업무 규칙은 자주 바뀌는 경향이 있고 영속성은 자주 바뀌지 않는 경향이 있지만, 바뀌는 이유가 완전히 다르다.
- 업무 규칙과 영속성 서브시스템을 묶는 것은 문제를 부른다.

### 결론

- SRP는 가장 간단한 원칙 중 하나임과 동시에 제대로 적용하기 가장 어려운 원칙 중 하나다.
- 책임을 결합하는 것은 인간이 자연스럽게 하는 일이다.
- 책임을 찾고 하나씩 분리하는 것이 소프트웨어 설계에서 실제로 하는 일의 대부분이다.

-----------

## 개방 폐쇄 원칙(OCP)

- 모든 시스템은 생명주기 동안에 변화한다. 이것은 개발 중인 시스템이 첫 번째 버전보다 오래 남길 원한다면 반드시 염두에 두어야 할 사실이다.

### 개방 폐쇄 원칙

- 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- 프로그램 한 군데를 변경한 것이 의존적인 모듈에서 단계적인 변경을 불러일으킬 때, 이 설계는 경직성의 악취를 풍긴다.
- OCP에서는 시스템을 리팩토링하여 나중에 일어날 그와 같은 종류의 변경이 더 이상 수정을 유발하지 않도록 하라 충고한다.
- OCP가 잘 적용된다면 이미 제대로 동작하고 있던 원래 코드를 변경하는 것이 아니라 새로운 코드를 덧붙임으로써 변경을 할 수 있다.

### 상세 설명

- 확장에 대해 열려 있다.
  - 모듈의 행위가 확장될 수 있음을 의미
  - 애플리케이션의 요구사항이 변경될 때, 이 변경에 맞게 새로운 행위를 추가해 모듈을 확장할 수 있음
  - 모듈이 하는 일을 변경
- 수정에 대해 닫혀 있다
  - 어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않음

### 해결책은 추상화다

- 추상화는 추상 기반 클래스이자, 모든 가능한 파생 클래스를 대표하는 가능한 행위의 제한되지 않은 묶음
- 모듈은 추상화를 조작할 수 있으며, 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있다.
- 추상 클래스는 자신을 구현하는 클래스보다도 클라이언트에 더 밀집하게 관련되어 있다
- 전략 패턴과 템플릿 메소드 패턴이 OCP를 따르는 가장 흔한 수단이다.

#### 예상과 '자연스러운' 구조

- 모든 상황에서 자연스러운 모델은 없다.
- 폐쇄는 완벽할 수 없기 때문에 전략적이어야 한다.
  - 설계자는 자신의 설계에서 닫혀 있는 변경의 종류를 선택해야 한다.
  - 가장 그럴 법한 종류의 변경을 추측하고, 그 변경에 대해 보호할 수 있는 추상화를 작성해야 한다
  - 경험으로 얻은 통찰력이 어느 정도 필요함
- OCP를 따르자면 비용이 많이 든다.
  - 적절한 추상화를 만들기 위해서는 개발 시간과 노력이 들 뿐만 아니라, 이런 추상화는 소프트웨어 설계의 복잡성을 높이기도 함
  - 개발자가 감당할 수 있는 추상화의 정도에는 한계가 있음

#### '올가미' 놓기

- 변경으로부터 우리 자신을 보호할 수 있는 방법은 생각되는 변경에 올가미를 놓는것이라고 생각하였다.
- 그러나 올가미는 종종 틀리고, 사용되지 않음에도 불구하고 유지보수 되어야 하는 불필요한 복잡성의 악취를 풍겼다.
- 차라리 변경이 일어나면 나중에 일어날 그런 종류의 변경으로부터 보호하는 추상화를 구현하는 것이 낫다.
- 변경을 촉진할 필요가 있는데 아래의 방법을 통해 가능하다
  - 테스트를 먼저 작성
    - 테스트는 시스템을 사용하는 방법 중 하나
    - 테스트 가능한 변경은 우리를 놀라게 하지 않음
  - 아주 짧은 주기로 개발(주 보다는 일 단위)
  - 기반구조보다 기능 요소를 먼저 개발하고, 자주 이 기능 요소를 이해당사자에게 설명
  - 가장 중요한 기능 요소를 먼저 개발
  - 소프트웨어를 빨리, 그리고 자주 릴리즈한다. 가능한 한 빠르게, 가능한 한 자주 고객과 사용자 앞에서 그것을 시연

### 결론

- OCP는 객체 지향 설계의 심장
- 이 원칙을 따르면 객체 지향 기술에서 당연하게 요구되는 최상의 효용을 낳음
  - 유연성, 재사용성, 유지보수성
- 애플리케이션의 모든 부분에 마구 추상화를 적용하는 것도 좋은 생각은 아님
- 프로그램에서 자주 변경되는 부분에만 추상화를 적용하기 위한 개발자의 헌신이 필요
  - 어설픈 추상화를 피하는 일은 추상화 자체만큼이나 중요

-----------------

## 리스코프 치환 원칙(LSP)

- OCP가 내포하는 일차적인 메커니즘은 추상화와 다형성
- 정적으로 형이 결정되는 C++나 자바 같은 언어에서 추상화와 다형성을 지원하는 주요 메커니즘 중 하나가 상속
- 상속의 특별한 사용을 규율하는 설계 법칙

### 리스코프 치환 원칙

- 서브타입은 그것의 기반 타입으로 치환 가능해야 한다.
- 타입 S의 각 객체 o1과 타입 T의 각 객체 o2가 있을 때, T로 프로그램 P를 정의했음에도 불구하고, o2를 o1으로 치환할 때
P의 행위가 변하지 않으면 S는 T의 서브타입이다.
- 이 원칙의 중요성은 이것을 위반한 결과를 생각해보면 분명해짐
  - 어떤 함수 f가 그 인자로 포인터나 어떤 기반 클래스 B의 참조값을 갖는다 가정
  - B의 파생 클래스 D가 B를 가장해 f에 넘겨져서 f가 잘못된 동작을 하게 만든다면 D는 LSP를 위반
  - D는 f에 대해 취약함
  - f의 작성자는 D에 대한 어떤 테스트를 집어넣어 D를 넘겨받아도 f가 제대로 동작할 수 있도록 하고 싶은데 이 경우
  이런 테스트는 f가 B의 모든 파생 클래스에 닫혀 있기 않기 때문에 OCP를 위반

### LSP 위반의 간단한 예

- LSP 위반은 대개 심각하게 OCP를 위반하는 런타임 타입 정보 사용으로 이어진다.

```java
class Point {
    double x;
    double y;
}

enum ShapeType{
    SQUARE, CIRCLE
}

class Shape {
    ShapeType itsType;
    public Shape(ShapeType t) {
        this.itsType = t;
    }
}

class Circle extends Shape {
    public Circle() {
        super(ShapeType.CIRCLE);
    }
    void Draw() {
      ...
    }
}

class Square extends Shape {
    public Square() {
        super(ShapeType.SQUARE);
    }
    void Draw() {
      ...
    }
}

void DrawShape(Shape s) {
  if (s.itsType == ShapeType.CIRCLE) {
    ...
  } else if (s.itsType == ShapeType.SQUARE) {
    ...
  }
}
```
- DrawShape 함수는 OCP를 위반한다.
  - 이 함수는 Shape 클래스의 파생 클래스를 모두 알아야 하고, 새로운 파생 클래스가 생길 때마다 변경되어야 한다.
- Square와 Circle이 Shape를 대체할 수 없다는 것은 LSP 위반이며 잠재적인 OCP 위반이다.

### 정사각형과 직사각형, 좀 더 미묘한 위반

```java
class Rectangle {
  void setWidth(double w) {
    this.width = w;
  }

  void setHeight(double h) {
    this.height = h;
  }

  double getHeight() {
    return height;
  }

  double getWidth() {
    return width;
  }
}

class Square extends Rectangle {
  @Override
  void setWidth(double w) {
    this.width = w;
    this.height = w;
  }
}

void f(Rectangle r) {
    r.setWidth(32);
}
```

- f 함수에 Square 객체에 대한 참조값을 이 함수에 넣어준다면 세로 값이 가로 값에 맞춰 바뀌지 않기 때문에 문제가 생김
  - Rectangle.setWidth를 호출하기 때문

#### 유효성은 본래 갖추어진 것이 아니다

- LSP는 모델만 별개로 보고 그 모델의 유효성을 충분히 검증할 수 없다라는 아주 중요한 결론을 내린다.
  - Square와 Rectangle 클래스의 최종 버전을 각각 별개로 검사한다면 자체 모순이 없고 유효하다는 결론을 내림
  - 기반 클래스에 대해 합리적인 가정을 택한 프로그래머의 관점에서 이 클래스들을 본다면 모델이 깨지고 맘
- 이러한 가정은 예상하기가 쉽지 않음
  - 예상하려고 시도한다면 시스템은 불필요한 복잡성의 악취로 찌듬
- 관련된 취약성의 악취를 맡을 때까지 가장 명백한 LSP 위반을 제외한 나머지의 처리는 연기

#### 'IS-A' 는 행위에 대한 것

- Square is Rectangle이 맞는 말이지만 행위의 관점에서 보아야 한다.
- LSP는 IS-A 관계는 합리적으로 가정할 수 있고, 클라이언트가 의존하는 행위와 관련이 있다는 점을 분명히 한다.

### 결론

- LSP는 OCP를 가능하게 하는 주요 요인 중 하나다
  - OCP가 효력을 가질 때 애플리케이션은 좀 더 유지보수 가능하고, 재사용 가능하고, 견고해진다.
- IS-A 라는 용어는 서브타입의 정의가 되기엔 힘들다.

--------------

## 의존 관계 역전 원칙(DIP)

### 의존 관계 역전 원칙

- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
- 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
- 어떤 애플리케이션의 중요한 정책 의사결정과 업무 모델을 포함하고 있는 것은 상위 수준의 모듈로서 이것이 하위 수준의 모듈에 의존하면
하위 수준 모듈의 변경은 상위 수준의 모듈에 직접적인 영향을 미친다.

#### 소유권의 역전

- 역전은 의존성에 대해서만이 아니라 인터페이스 소유권에 대한 것도 의미함
- DIP가 적용된 경우에는 클라이언트가 추상 인터페이스를 소유하는 경향이 있다.

#### 추상화에 의존하자

- DIP의 해석은 추상화에 의존하자라는 간단한 경험적 접근 방식이다.
  - 구체 클래스에 의존해서는 안 되고
  - 어떤 프로그램의 모든 관계는 어떤 추상 클래스나 인터페이스에서 맺어져야 한다
- 어떤 변수도 구체 클래스에 대한 포인터나 참조값을 가져서는 안 된다.
- 어떤 클래스도 구체 클래스에서 파생되어서는 안 된다
- 어떤 메소드도 그 기반 클래스에서 구현된 메소드를 오버라이드해서는 안 된다.
- 하지만 비휘발적인 클래스에는 이 경험적 접근 방식을 적용할 이유가 없다.
  - 구체 클래스가 너무 많이 변경되지 않고, 다른 비슷한 파생 클래스가 만들어지지 않는다면 이것에 의존하는 것은 그리 큰 해가 되지 않는다.
  - String 클래스

### 간단한 예

```java
public class Button {
    private Lamp itsLamp;
    public void poll() {
        if (...) {
            itsLam.turnOn();
      }
    }
}
```
- 이것은 DIP를 위반한다.
  - 애플리케이션의 상위 수준 정책은 하위 수준 구현에서 분리되어 있지 않다.
  - 추상화는 구체적인 것에서 분리되어 있지 않다

#### 내재하는 추상화를 찾아서

- 무엇이 상위 수준의 정책인가?
  - 애플리케이션에 내재하는 추상화이자 구체적인 것이 변경되더라도 바뀌지 않는 진실
- Button/Lamp 예에서 내재하는 추상화는 사용자로부터 켜고 끄는 동작을 탐지해 그 동작을 대상 객체에 전해주는 것
  - 동작을 탐지하는 매커니즘은 상관없음
  - 대상 객체는 상관없음

### 결론

- 절차 지향 프로그래밍 방식은 정책이 구체적인 것에 의존하는 의존성 구조
- 객체 지향 프로그래밍은 의존성 구조를 역전시켜 구체적인 사항과 정책이 모두 추상화에 의존하고, 대개 그 클라이언트가
서비스 인터페이스를 소유하게 만듬
- 추상화와 구체적 사항이 서로 분리되어 있기 때문에 이 코드는 유지보수하기가 훨씬 쉬움

-----------

## 인터페이스 분리 원칙(ISP)

- 비대한 인터페이스의 단점을 해결
  - 비대한 인터페이스를 가지는 클래스는 응집력이 없는 인터페이스를 가지는 클래스
  - 이러한 클래스의 인터페이스는 메서드의 그룹으로 분해될 수 있고, 각 그룹은 각기 다른 클라이언트 집합을 지원
    - 몇몇 클라이언트는 하나의 멤버 함수 그룹을 사용하고 다른 클라이언트는 다른 멤버 함수 그룹을 사용
- 인터페이스 분리 원칙은 응집력이 없는 인터페이스를 필요로하는 객체가 있다는 것은 인정하지만 클라이언트는 그것을 하나의 단일 클래스로 생각해서는
안 됨을 시사함
- 클라이언트는 응집력 있는 인터페이스를 가지는 추상 기반 클래스에 대해 알고 있어야 함

### 인터페이스 오염

```java
public abstract class Door {
    abstract void lock();
    abstract void unLock();
    abstract boolean isDoorOpen();
}

public class Timer {
    void register(int timeout, Timerclient client);
}
public abstract class TimerClient {
    abstract void timeOut();
}
```
- TimerClent 클래스가 TimedDoor 클래스와 통신하여 TimedDoor 코드에서 제한 시간 초과 여부를 통지 받게 하려면?
  - Door, TimedDoor가 TimerClient를 상속
  - 하지만 Door은 TimerClient에 의존하게 됨
- 모든 Door가 Timer 기능이 필요한 것은 아님
- 인터페이스 오염 의 한 사례

### 클라이언트 분리는 인터페이스 분리를 의미한다

- Door와 TimerClient는 완전히 다른 클라이언트가 사용하는 인터페이스
  - Timer는 TimerClient
  - 문을 조작하는 클래스는 Door
- 클라이언트가 분리되어 있기 때문에 인터페이스도 분리된 상태로 있어야 함
  - 클라이언트가 자신이 사용하는 인터페이스에 영향을 끼치기 때문

#### 클라이언트가 인터페이스에 미치는 반대 작용

- 보통은 인터페이스 변경이 어떻게 그 클라이언트에게 영향을 미칠 수 있는지 생각하나
- 때로는 사용자가 인터페이스 변경을 불러일으킨다

### 인터페이스 분리 원칙

- 클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안 된다
- 만약 의존한다면 메소드의 변경에 취약해지고, 모든 클라이언트 간의 의도하지 않은 결합을 불러일으킨다.

### 클래스 인터페이스와 객체 인터페이스

- 객체의 클라이언트는 그 객체의 인터페이스를 통해 객체에 접근할 필요가 없다.
  - 위임이나 그 객체의 기반 클래스를 통해 접근할 수 있다.

#### 위임을 통한 분리

```java
public abstract class TimedDoor extends Door {
    abstract void doorTimeOut(int timeOutId);
}

public abstract class DoorTimeAdapter extends TimerClient {
    private TimedDoor itsTimedDoor;
    
    public DoorTimeAdapter(TimedDoor theDoor) {
        this.itsTimedDoor = theDoor;
    }
    
    abstract void timeOut(int timeOutId) {
        itsTimedDoor.doorTimeOut(timeOutId);
    }
}
```

- 이 해결책은 ISP를 따름과 동시에 Door 클라이언트의 Timer에 대한 결합을 방지한다.
- Timer 변경이 있더라도 Door의 사용자는 아무도 영향을 받지 않는다.
- TimedDoor는 TimerClient와 똑같은 인터페이스를 가질 필요가 없다.

- 하지만 다소 세련되지 못하다.
  - 타이머 사용자 등록을 하려고 할 때마다 새 객체를 생성
  - 위임 과정은 아주 작긴 하지만 실행 시간과 메모리를 필요로 하는데 이런 문제를 걱정해야 할 정도로 작은 영역도 존재

### 결론

- 비대한 클래스는 클라이언트들 간에 기이하고 해가 되는 결합도를 유발함
- 비대한 클래스의 인터페이스를 클라이언트 고유의 인터페이스 여러 개로 분해해야 함
- 이렇게 하면 호출하지 않는 메소드에 대한 클라이언트의 의존성을 끊고, 클라이언트가 서로에 대해 독립적이 되게 만들 수 있음
