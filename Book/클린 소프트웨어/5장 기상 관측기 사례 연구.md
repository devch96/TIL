# 기상 관측기 사례 연구

-----

## 컴포지트 패턴

```java
public interface Shape {
    void draw();
}

public class CompositeShape implements Shape {
    private Vector itsShapes = new Vector();
    public void add(Shape s) {
        itsShapes.add(s);
    }
    
    public void draw() {
        for (int i = 0; i < itsShapes.size(); i++) {
            Shape shape = (Shape) itsShapes.elementAt(i);
            shape.draw();
        }
    }
}
```

- Command 패턴이 합쳐진 것과 비슷하다. 
- Command를 하나 이상 실행하는 경우에 사용하면 좋다.

### 다수성이냐 아니냐

- 컴포지트 패턴을 사용해 일대다 관계를 일대일 관계로 바꾸는 것 처럼 보인다.
  - 일대일 관계가 일대다보다 이해하기도 쉽고 유지보수하기 쉬우므로 올바른 것처럼 보인다
- 그러나 얼마나 많은 일대다 관계를 일대일로 바꿀 수 있을까?
- 컴포지트를 사용한다고 모든 일대다 관계를 일대일 관계로 돌릴 수 있는 것은 아님
  - 목록에 들어 있는 모든 객체가 동일하게 취급받을 때만 이것이 가능
  - 직원 목록을 유지하면서 월급날이 오늘인 직원을 찾기 위해 그 목록을 검색한다면 컴포지트 패턴 X
  - 모든 직원이 동일하지 않기 때문

----------

## 옵저버 패턴: 패턴으로 돌아가기

- 패턴을 넣는다고 기정 사실화하고 코드를 짜는건 바람직하지 않음

### 옵저버 패턴

- 옵저버 패턴에는 두 가지 기본적인 방식이 있다
  - 데이터를 끌어오는 방식(pull-model)
    - 장점은 구현이 단순하다는 점과 Subject와 Observer 클래스를 재사용 가능한 표준 요소로 라이브러리에 포함시킬 수 있다는 점
    - 단점은 수천 명이 들어있는 직원 기록을 관찰하고 있는데 update 메시지를 받았다고 했을 때 수천 개의 필드 가운데 어떤 것이 변경?
  - 데이터를 밀어내는 방식(push-model)
- 관찰 대상 객체가 복잡해서 관찰자가 단서를 받아야 한다면 데이터를 밀어내느 방식이 적절, 반대라면 데이터를 끌어오는 방식으로도 충분

----------------

## 추상 서버, 어댑터, 브리지 패턴

### 추상 서버 패턴

- 구체 클래스 사이에 인터페이스를 도입
- DIP와 OCP 충족

### 어댑터 패턴

- 객체의 인터페이스와 인터페이스 사이에 어댑터 역할을 하는 패턴
- 어댑터는 싸게 먹히지 않음
  - 새로운 클래스 작성
  - 어댑터를 인스턴스화한 다음 어댑터가 중개할 객체와 어댑터를 연결
  - 어댑터를 호출할 때마다 위임 때문에 필요한 추가적인 시간과 공간
- 
