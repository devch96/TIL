# 기상 관측기 사례 연구

-----

## 컴포지트 패턴

```java
public interface Shape {
    void draw();
}

public class CompositeShape implements Shape {
    private Vector itsShapes = new Vector();
    public void add(Shape s) {
        itsShapes.add(s);
    }
    
    public void draw() {
        for (int i = 0; i < itsShapes.size(); i++) {
            Shape shape = (Shape) itsShapes.elementAt(i);
            shape.draw();
        }
    }
}
```

- Command 패턴이 합쳐진 것과 비슷하다. 
- Command를 하나 이상 실행하는 경우에 사용하면 좋다.

### 다수성이냐 아니냐

- 컴포지트 패턴을 사용해 일대다 관계를 일대일 관계로 바꾸는 것 처럼 보인다.
  - 일대일 관계가 일대다보다 이해하기도 쉽고 유지보수하기 쉬우므로 올바른 것처럼 보인다
- 그러나 얼마나 많은 일대다 관계를 일대일로 바꿀 수 있을까?
- 컴포지트를 사용한다고 모든 일대다 관계를 일대일 관계로 돌릴 수 있는 것은 아님
  - 목록에 들어 있는 모든 객체가 동일하게 취급받을 때만 이것이 가능
  - 직원 목록을 유지하면서 월급날이 오늘인 직원을 찾기 위해 그 목록을 검색한다면 컴포지트 패턴 X
  - 모든 직원이 동일하지 않기 때문

----------

## 옵저버 패턴: 패턴으로 돌아가기

- 패턴을 넣는다고 기정 사실화하고 코드를 짜는건 바람직하지 않음

### 옵저버 패턴

- 옵저버 패턴에는 두 가지 기본적인 방식이 있다
  - 데이터를 끌어오는 방식(pull-model)
    - 장점은 구현이 단순하다는 점과 Subject와 Observer 클래스를 재사용 가능한 표준 요소로 라이브러리에 포함시킬 수 있다는 점
    - 단점은 수천 명이 들어있는 직원 기록을 관찰하고 있는데 update 메시지를 받았다고 했을 때 수천 개의 필드 가운데 어떤 것이 변경?
  - 데이터를 밀어내는 방식(push-model)
- 관찰 대상 객체가 복잡해서 관찰자가 단서를 받아야 한다면 데이터를 밀어내느 방식이 적절, 반대라면 데이터를 끌어오는 방식으로도 충분

----------------

## 추상 서버, 어댑터, 브리지 패턴

### 추상 서버 패턴

- 구체 클래스 사이에 인터페이스를 도입
- DIP와 OCP 충족

### 어댑터 패턴

- 객체의 인터페이스와 인터페이스 사이에 어댑터 역할을 하는 패턴
- 어댑터는 싸게 먹히지 않음
  - 새로운 클래스 작성
  - 어댑터를 인스턴스화한 다음 어댑터가 중개할 객체와 어댑터를 연결
  - 어댑터를 호출할 때마다 위임 때문에 필요한 추가적인 시간과 공간

### 브리지 패턴

- 타입 계층 구조의 자유도가 하나 이상인 상황이라면 브리지 패턴이 종종 도움이 된다.
- 계층 구조를 합치는 대신 각각을 분리해놓고 브리지를 통해 서로를 하나로 연결할 수 있음.

-----------

## 프록시와 천국으로의 계단 패턴: 서드파트 API 관리

- 소프트웨어 시스템에는 많은 장벽이 있다
  - 프로그램에서 데이터베이스로 데이터 전송할 땐 데이터베이스의 장벽
  - 컴퓨터에서 다른 컴퓨터로는 네트워크의 장벽
- 해결하려는 문제보다 장벽 자체에 더 신경을 쓰게 만드는 소프트웨어가 될 수도 있음
- 아래 패턴은 해결하려는 문제에 대한 초점을 잃지 않은 채로 이런 장벽을 넘는 일을 도와줌

### 프록시 패턴

- 프록시는 협력적으로 동작하는 두 객체 양쪽에 알리지 않고 그 사이에 들어가는 것이 가능함
  - 데이터베이스나 네트워크 같은 장벽을 넘으면서 구성원이 이를 눈치채지 못하게 하는 일에 사용될 수 있음
- 프록시를 적용하기는 까다로우나 관심사의 분리라는 매우 강력한 이점이 있다.
- 업무 규칙과 데이터베이스 구현부의 분리가 아주 중요한 인스턴스에서는 프록시가 적용하기 좋은 패턴일 수 있다.

#### 데이터베이스, 미들웨어, 서드파티 인터페이스 다루기

- 기본적으로는 자신의 애플리케이션 코드에서 직접 호출하는 방식으로 이런 API를 사용하게 된다.
- 이건 서드파티 API가 변경될 때 문제가 됨
- 애플리케이션과 레이어 종속성을 뒤집을 때 프록시 패턴을 사용하기 좋음
  - 애플리케이션은 프록시에 의존하지 않고, 프록시가 애플리케이션과 API에 의존함
  - 애플리케이션과 API 사이의 관계 정보는 프록시에 집중
- 대부분의 애플리케이션에는 프록시가 필요 없다
  - 프록시는 아주 무거운 솔루션
  - 프록시 솔루션보다는 다른 해결책 찾아봐야 함
  - 하지만 프록시가 제공하는 애플리케이션과 API의 철저한 분리가 이로울 때가 있다
    - 스키마와 API 둘 모두 또는 어느 한쪽에서 잦은 변화가 발생하는 아주 큰 시스템
    - 많은 데이터베이스 엔진이나 미들웨어 엔진 위에 얹힐 수 있는 시스템

### 천국으로의 계단 패턴

- 프록시와 같은 종속성 뒤집기의 효과를 얻을 수 있는 또 다른 패턴
- 어댑터 패턴의 클래스 형식이 변형된 형태를 취하고 있음

### 결론

- 일단 파사드로 시작하고, 필요하면 리팩토링할 것을 권한다.

----------------

