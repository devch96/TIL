# 급여 관리 시스템 패키징

---------

## 패키지 설계의 원칙

- 큰 애플리케이션을 조직화할 때는 클래스보다 더 큰 무엇이 필요한데 이것을 패키지라고 한다.

### 패키지를 이용한 설계?

- 클래스를 패키지로 묶어놓으면 더 높은 추상화 차원에서 설계에 대한 논의를 할 수 있다.
- 패키지를 사용하는 목적은 애플리케이션 내부의 클래스들을 어떤 기준에 따라 분류한 다음 패키지에 할당하는 것
- 하지만 클래스가 다른 클래스에 의존 관계를 갖는 경우도 많으며 이러한 관계가 패키지 경계를 넘어서는 일도 많다.
- 의문점
  - 클래스를 패키지로 할당할 때 따를 원칙은?
  - 어떤 설계 원칙들이 패키지 사이의 의존 관계를 지배?
  - 클래스보다 패키지를 먼저 설계? 반대?
  - 패키지는 물리적으로 어떻게 표현?
  - 패키지를 어떤 목적으로 사용?

### 단위 크기: 패키지 응집도의 원칙

- 패키지 응집도 원칙 세 가지는 개발자가 어떻게 클래스를 패키지에 분류해 넣을지 결정할 때 도움이 됨.
- 이 원칙을 적용하기 전 클래스와 클래스 상호 관계가 일부분이라도 밝혀져 있어야 함
  - 상향식 접근 방법

#### 재사용 릴리즈 등가 원칙(REP)

- 재사용의 단위가 릴리즈의 단위
- 재사용 단위는 릴리즈 단위보다 작을 수 없다
  - 재사용하는 모든 것은 반드시 릴리즈된 다음 추적되어야 함
  - 개발자가 클래스 하나 달랑 만들고 재사용 가능하다고 주장하는 것은 현실적이지 않음
  - 잠재적 사용자들에게 필요한 통보, 안전성, 지원에 대한 보장을 제공하는 추적 시스템이 먼저 있은 다음에야 재사용성 말 할 수 있음
- 재사용성은 반드시 패키지에 기반을 두어야 하기 때문에 재사용 가능한 패키지는 재사용 가능한 클래스를 포함해야 함
  - 패키지의 모든 클래스가 재사용 가능하든지, 모두 그렇지 않든지 해야 함

#### 공통 재사용 원칙(CRP)

- 패키지 안의 클래스들은 함께 재사용되어야 한다. 어떤 패키지의 클래스 하나를 재사용한다면 나머지도 모두 재사용한다.
- 자주 함께 재사용되는 클래스들은 동일한 패키지에 속해 있다.
  - 컨테이너 클래스와 그에 딸린 반복자(iterator)들의 예

#### 공통 폐쇄 원칙(CCP)

- 같은 패키지 안의 클래스들은 동일한 종류의 변화에는 모두 폐쇄적이어야 한다. 패키지에 어떤 변화가 영향을 미친다면, 그 변화는 그 패키지의 모든
클래스에 영향을 미쳐야 하고 다른 패키지에는 영향을 미치지 않아야 한다.
- 대상이 패키지인 단일 책임 원칙

#### 패키지 응집도에 대한 요약

- 같은 패키지에 넣을 클래스를 결정하려면 재사용성과 개발 용이성에 관련된 상충하는 힘들을 모두 검토해야 하지만,
애플리케이션의 필요에 맞춰 이 힘들의 균형을 잡는 일은 쉽지 않음
  - 이러한 균형은 동적임
  - 오늘은 좋았던 클래스 분할이 내년에는 그렇지 않을 수도 있음

### 안정성: 패키지 결합도의 원칙

- 패키지 상호 관계에 대해 다룸

#### 의존 관계 비순환 원칙(ADP)

- 패키지 의존성 그래프에서 순환을 허용하지 말라
- 의존 관계 그래프에서 순환이 있을 경우 특정 패키지의 개발자는 순환 내 모든 패키지와 연관되고, 릴리즈하기 상당히 어려워진다.
- 테스트를 하려해도 전체 빌드를 해야 한다.

#### 안정된 의존 관계 원칙(SDP)

- 의존은 안정적인 쪽으로 향해야 한다.
- 의존을 하면 변경의 이유가 생기는 것
- 따라서 안정적인 쪽은 의존을 많이 안하고있는 것이고 변경의 이유가 없는 쪽
- 그렇게한다면 자기 자신도 변경이 될 확률이 적을 것

-------------

## 팩토리 패턴

- 의존 관계 역전 원칙(DIP)에 따르면 구체 클래스에 의존하는 것은 피하고 추상 클래스에 의존하는 것을 선호해야 한다.
- DIP 위반이 거의 해롭지 않은 경우도 있다
  - String
- 구체 클래스가 변경될 가능성이 크면 클수록 그 클래스에 의존할 때 문제가 생길 가능성도 커진다.
- 하지만 구체 클래스가 쉽게 변경되는 종류의 클래스가 아니라면 그 클래스에 의존하는 것이 그렇게 걱정거리가 아니다.
- 팩토리 패턴을 사용하면 추상 인터페이스에만 의존하면서도 구체적 객체들의 인스턴스를 만들 수 있으므로 개발하느라 생성할 구체 클래스의 변경이 잦을 때 이 패턴이 큰 도움이 된다.

```java
public interface ShapeFactory {
    Shape makeCircle();
    Shape makeSquare();
}

public class ShapeFactoryImplementation implements ShapeFactory {
    public Shape makeCircle() {
        return new Circle();
    }
    public Shape makeSquare() {
        return new Square();
    }
}
```

### 의존 관계 순환

- ShapeFactory 클래스는 Shape의 파생형마다 메서드가 하나씩 있는데, 이렇게 할 경우 Shape에 새로운 파생형을 추가하는 일을 매우 어렵게 만든다
  - 새로 컴파일, 배포해야함
- String을 받는 make 함수 하나에 if/else 문을 사용하면 해결 가능
- 하지만 Shape 파생형의 이름을 잘못 쓴 호출자가 컴파일 에러가 아닌 런타임 에러를 받게 됨

### 대체할 수 있는 팩토리

- 팩토리를 사용해서 생기는 큰 장점 중 하나는, 어떤 팩토리의 구현을 다른 구현으로 대체할 수 있다는 점

### 팩토리 사용이 얼마나 중요한가?

- 보통은 팩토리를 사용하지 않고 시작하며, 팩토리의 필요성이 충분히 커지면 그제야 시스템에 팩토리를 도입한다.
- 팩토리가 당연히 필요할 것이라고 가정하고 시작하지는 않는다.
- 팩토리는 피하려면 피할 수 있는 복잡함이다.
- 팩토리를 기본으로 사용한다면 설계를 확장하기가 급격히 어려워진다.
  - 팩토리를 사용해 클래스를 하나 만들면 인터페이스 클래스 2개, 구체 클래스 2개 총 4개가 새로 만들어져야 하기 때문

### 결론

- 팩토리는 DIP를 지키려고 할 때 큰 도움이 되며 높은 차원의 정책 모듈이 클래스들의 구체적인 구현에 의존하지 않고도
그 클래스들의 인스턴스를 생성하게 해준다.
- 하지만 팩토리는 피하려면 피할 수 있는 복잡함이다.
- 기본으로 팩토리를 사용하는 것이 최선의 방법인 경우는 드물다.