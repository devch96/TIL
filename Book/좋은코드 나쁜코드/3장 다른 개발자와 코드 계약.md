# 다른 개발자와 코드 계약

- 소프트웨어를 작성하고 유지보수하는 일은 대개 팀 단위에서 수행하는 작업
- 자신이 작성한 코드를 다른 개발자가 작업해야 하고, 반대로 다른 개발자가 작업한 코드를 자신이 작업해야 할 때도 있음

---------

## 자신의 코드와 다른 개발자의 코드

- 코드를 작성할 때 다음 세 가지를 고려하는 것이 유용하다
  - 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다
  - 다른 개발자는 무의식중에 내 코드를 망가뜨릴 수 있다
  - 시간이 지남에 따라 자신의 코드를 기억하지 못한다

### 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다

- 코드를 작성하기 시작하면 해결하려는 문제에 대해 생각해보면서 몇 시간 혹은 며칠을 보냄
- 자신의 로직에 너무 익숙해서 모든 것이 분명해 보이기 때문에 어떤 것이 왜 그런 방식인지, 문제를 왜 그방식으로
해결하고 있는지에 대해서는 거의 생각하지 않아도 됨
- 하지만 어느 시점에 이르면 다른 개발자가 내가 작성한 코드와 상호작용하거나, 코드를 변경하거나, 코드가 의존하고 있는 코드를
변경해야 할 수 있다

### 다른 개발자는 무의식중에 내 코드를 망가뜨릴 수 있다

- 내가 작성한 코드는 독립적으로 존재하지 않음
  - 다른 코드에 의존하고 그 코드는 또 다른 코드에 의존함
- 다른 개발자가 기능을 추가하고 리팩터링하고 수정함에 따라 코드는 계속 변함

### 시간이 지나면 자신의 코드를 기억하지 못한다

- 1년 후 혹은 그 이상 이하의 시간이 흐르면 코드의 자세한 내용을 더 이상 기억하지 못할 수도 있다

--------------

## 내가 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?

- 코드를 어떻게 사용해야 하는지 그 코드가 무슨 일을 하는지 파악해야 한다
  - 여러 가지 상황에서 어떤 함수를 호출해야 하는지
  - 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지
  - 어떤 값을 인수로 사용해야 하는지
  - 코드가 수행하는 동작이 무엇인지
  - 어떤 값을 반환하는지
- 미래의 자신은 본질적으로 다른 개발자라고 간주해야 한다
- 작성한 코드를 어떻게 사용해야 하는지 알아내기 위해 다른 개발자가 할 수 있는 일
  - 함수, 클래스, 열거형 등의 이름을 살펴봄
  - 함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터 유형을 살펴봄
  - 함수/클래스 수준의 문서나 주석문을 읽음
  - 직접 물어봄
  - 함수와 클래스의 자세한 구현 코드를 읽음
- 처음 세가지만 실제로 사용할만함

### 이름 확인

- 코드를 사용할 때 이름을 무시하기는 매우 어려움
  - removeEntry()라는 이름의 함수는 addEntry()라는 이름의 함수와 혼동할 수 없음
- 이름을 잘 지어야함

### 데이터 유형 확인

- 컴파일이 필요한 정적 유형의 언어에서는 데이터 유형을 인식하고 올바르게 사용해야 함
- 유형 시스템을 사용하는 언어로 코드를 작성하는 것은 다른 개발자가 코드를 오용하거나 오작동할 수 없도록 하기 위한 좋은 방법

### 문서 읽기

- 코드를 사용하는 방법에 관한 문서는 두 가지 이상의 형태로 존재할 수 있음
  - 함수 및 클래스 수준의 비공식적인 주석문
  - 자바독(JavaDoc)과 같은 좀 더 공식적인 코드 내 문서
  - 외부 문서(README.md, 웹 페이지, 지침 문서 등)
- 어느 정도까지만 신뢰할 수 있음
  - 문서를 읽는다는 보장이 없음
  - 읽더라도 잘못 해석할 수 있음
  - 문서의 업데이트가 제대로 안 될 수 있음

### 직접 물어보기

- 코드의 사용법을 설명하기에는 다음과 같은 이유로 신뢰하기 어려운 방법
  - 코드를 많이 작성할수록 질문에 답하는 데 더 많은 시간을 써야 함
  - 작성자가 휴가를 간다면?
  - 1년이 지나면 자기 자신도 코드를 기억하지 못함
  - 회사를 떠난다면?

### 코드를 살펴보는 것

- 사용 방법에 대한 가장 확실한 답을 얻을 수 있는 방법은 자세한 구현 세부 사항을 살펴보는 것
- 코드의 양이 많으면 효과를 얻기 힘듬

-----------

## 코드 계약

- 계약에 의한 프로그래밍(programming by contract) 또는 계약에 의한 디자인(design by contract)
- 코드의 계약에 대한 용어의 세 가지 범주
  - 선결 조건(precondition)
    - 코드를 호출하기 전에 사실이어야 하는 것
    - 시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 입력을 공급해야 하는지와 같은 사항
  - 사후 조건(postcondition)
    - 코드가 호출된 후에 사실이어야 하는 것
    - 시스템이 새로운 상태에 놓인다든지 반환되는 값과 같은 사항
  - 불변 사항(invariant)
    - 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항

### 계약의 세부 조항

- 코드에서 계약을 정의할 때도 명확한 부분과 세부 조항이 있음
- 계약의 명확한 부분
  - 함수와 클래스 이름
  - 인자 유형
  - 반환 유형
  - 검사 예외(호출하는 코드가 이것을 처리하지 않으면 코드는 컴파일되지 않음)
- 세부 조하
  - 주석문과 문서
  - 비검사 예외

### 세부 조항에 너무 의존하지 말라

- 코드 계약을 전달할 때 세부 조항을 사용하는 것은 신뢰할 만한 방법이 아님
  - 다른 개발자들이 해당 코드를 사용할 때 몯느 세부 조항을 다 알지 못할 가능성이 큼

#### 세부 조항을 제거하는 방법

- 다른 개발자가 코드를 올바르게 사용하기 위해 세부 조항(주석문 등)에 의존하기보다 잘못된 일을 하는 것을 처음부터
불가능하게 만드는 것이 좋음
- 코드가 오용되거나 잘못 설정되면 컴파일조차 되지 않도록 하는 것

```java
class UserSettings {
  private UserSettings() {
  }

  static Optional<UserSettings> create(File location) {
    UserSettings settings = new UserSettings();
    if (!settings.loadSettings(location)) {
      return Optional.empty();
    }
    settings.init();
    return settings;
  }
}
```

- 상태(state)나 가변성(mutability)이 클래스 외부로 노출되는 것을 없앤다는 점
  - 객체의 상태는 객체가 담고 있는 어떤 값이나 데이터
  - 객체를 만든 후 이러한 객체의 상태를 수정할 수 있으면 가변적, 변경할 수 없다면 불변적이라 함

-----------

## 체크 및 어서션

- 컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있음
  - 컴파일 타임 확인만큼 강력하지 않음
  - 발생하는 문제에 대한 테스트에 의존하기 때문
- 컴파일러를 사용하여 계약을 강제할 수 있는 실질적인 방법이 없는 상황이 더러 있기 때문에 런타임 검사를 통해 계약을 확인하는 것이
아예 확인하지 않는 것보다 나음

### 체크

- 코드 계약이 준수되었는지(입력 매개변수에 대한 제약 조건 또는 수행해야 할 설정에 대한 제약 등) 확인하기 위한 추가적인 로직
- 준수되지 않을 경우 체크는 실패를 유발하는 오류를 생성하는데 명백해서 놓치고 넘어가는 것이 불가능
- 체크는 시행 중인 계약 조건에 따라 다음과 같은 범주로 구분됨
  - 전제 조건 검사
    - 입력 인수가 올바르거나, 초기화가 수행되었거나, 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인하는 경우
  - 사후 상태 검사
    - 반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인하는 경우

```java
void init() {
    if(!haveSettingsBeenLoaded()) {
        throw new StateException("Settings not loaded");
    }
}

Optional<Color> getUiColor() {
    if(!hasBeenInitialized()) {
        throw new StateException("Setting not initialized");
    }
}
```

- 코드 계약에서 세부 조항을 피할 수 없으며, 계약이 준수되는지 확인하기 위해 체크를 추가하는 것이 좋음
- 하지만 가능하다면 처음부터 세부 조항은 피하는 것이 바람직함
- 코드에 체크가 많이 있으면 세부 조항을 없애는 것에 대해 고려해봐야 한다는 신호

### 어서션

- 코드 계약을 준수하도록 강제하기 위한 방법이라는 점에서 체크와 매우 유사
- 어서션과 체크 사이의 주요 차이점은 배포를 위해 빌드할 때 어서션은 보통 컴파일에서 제외됨

```java
Optional<Color> getUiColor() {
    assert(hasBeenInitializeD(), "UserSettings가 초기화되지 않음");
}
```

------------

## 요약

- 코드베이스는 계속 변하고 일반적으로 여러 개발자에 의해 변경됨
- 다른 개발자가 어떻게 해석하고 오용할 수 있을지 생각해보고 가능성을 최소화하거나 오용이 불가능하게 만드는 방식으로 코드를 작성하는 것이 유용
- 코드를 작성할 때 일종의 코드 계약이 항상 만들어짐
- 코드 계약의 세부 조항은 다른 개발자가 계약을 준수하도록 하기 위한 방법이지만 신뢰할만한 방법은 아님
- 컴파일러를 사용하여 계약을 확인하는 것이 가장 신뢰할 수 있는 방법
