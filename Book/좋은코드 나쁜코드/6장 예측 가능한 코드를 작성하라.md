# 예측 가능한 코드를 작성하라

- 궁극적으로 개발자는 코드를 사용하는 방법에 대한 정신 모델을 구축함
  - 정신 모델은 코드 계약에서 발견한 것, 사전 지식, 적용할 수 있다고 생각하는 공통 패러다임에 근거해 만들어짐
- 코드가 실제로 하는 일이 이 정신 모델과 일치하지 않는다면 예측과 벗어나는 기분 나쁜 일이 일어날 가능성이 큼
- 예측 가능한 코드를 작성하는 것은 무언가를 분명하게 하는 것일 때가 많음
  - 함수가 아무것도 반환하지 않을 때가 있거나 처리해야 할 특별한 시나리오가 있는 경우 다른 개발자에게 확실히 알려야함
  - 그러지 않으면 코드의 동작이 다른 개발자에게 실제 일어날 것이라고 생각하는 것과 일치하지 않을 위험이 있음

-----------

## 매직값을 반환하지 말아야 한다

- 매직값(magic value)은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가지고 있는 것
- 매직값의 일반적인 예는 값이 없거나 오류가 발생했음을 나타내기 위해 -1을 반환하는 것
- 매직값은 함수의 정상적인 반환 유형에 들어맞기 때문에 이 값이 갖는 특별한 의미를 인지하지 못하고 정상적인 반환값으로 오인하기 쉬움

### 매직값은 버그를 유발할 수 있다

- 일부 레거시 코드와 언어의 내장된 함수들(javascript의 배열에 대해 indexOf()를 호출할 때)중에 매직값을 리턴하는 경우가 있음
- 과거에는 명시적인 오류 전달 기법이나 널 또는 옵셔널 타입을 반환하는 것이 가능하지 않거나 실용적이지 않기 때문에 매직값을 반환하는 것이 어느 정도 합리적인
이유가 있었음
- 레거시 코드로 작업 중이거나, 신중하게 최적화해야 하는 코드가 있다면 여전히 이렇게 할 이유가 있을 수 있지만 일반적으로는
매직값을 반환하면 예측을 벗어날 위험이 있으므로 사용하지 않는 것이 가장 바람직함

### 해결책: 널, 옵셔널 또는 오류를 반환하라

- 함수에서 매직값을 반환할 때의 문제점은 호출하는 쪽에서 함수 계약의 세부 조항을 알아야 하지만 어떤 개발자들은 이 세부 조항을 확인하지 않거나
확인하고나서 잊어버리기 때문에 예측을 벗어나는 일이 생길 수 있음
- 널 안전성을 지원하는 경우에는 널이 가능한 유형을 반환하고, 널 안전성을 지원하지 않는 경우에는 옵셔널 값을 반환하면 됨

### 때떄로 매직값이 우연히 발생할 수 있다

- 개발자가 자신의 코드에 주어지는 모든 입력과 이러한 입력값들이 어떤 영향을 미칠 수 있을지에 대해 충분히 생각하지 않을 때도 매직값은 반환될 수 있음

```java
Integer minValue(List<Integer> values) {
    Integer minValue = Integer.MAX_VALUE;
    for (Integer value : values) {
        minValue = Math.min(value, minValue);
    }
    return minValue;
}
```

- Integer.MAX_VALUE는 values 리스트가 비어 있으면 반환됨
  - 우연히 반환되는 것이 아닐 수 있음

---------------

## 널 객체 패턴을 적절히 사용하라

- 값을 얻을 수 없을 때 널값이나 빈 옵셔널을 반환하는 대신 널 객체 패턴을 사용할 수 있음
- 널 객체 패턴을 사용하는 이유는 널값을 반환하는 대신 유효한 값이 반환되어 그 이후에 실행되는 로직에서 널값으로 인해 시스템에
피해가 가지 않도록 하기 위함

### 빈 컬렉션을 반환하면 코드가 개선될 수 있다

- 함수가 리스트, 집합, 배열과 같은 컬렉션을 반환할 때 컬렉션의 값을 얻을 수 없는 경우 널 값을 반환하는 것

```java
Set<String> getClassNames(HtmlElement element) {
    String attribute = element.getAttribute("class");
    if (attribute == null) {
        return null;
    }
    return new Set(attribute.split(" "));
}

Boolean isElementHighlighted(HtmlElement element) {
    Set<String> classNames = getClassNames(element);
    if (classNames == null) {
        return false;
    }
    return classNames.contains("highlighted");
}
```

- 널값이 아닌 널이 가능한 유형을 반환하면 getClassNames()를 호출하는 쪽에서는 반환된 값이 널인지 여부를 확인한 후 사용해야 함
  - 별 이점 없이 코드만 지저분하게 만듬
- 널 객체 패턴을 사용해서 코드를 개선할 수 있음

```java
Set<String> getClassNames(HtmlElement element) {
    String attribute = element.getAttribute("class");
    if (attribute == null) {
        return new Set();
    }
    return new Set(attribute.split(" "));
}

Boolean isElementHighlighted(HtmlElement element) {
    return getClassNames(element).contains("highlighted");
}
```
- 호출하는 쪽의 코드는 간단해지고 코드가 예측을 벗어나는 작도응ㄹ 할 가능성이 매우 낮음

### 빈 문자열을 반환하는 것도 때로는 문제가 될 수 있다

- 널 대신 빈 컬렉션을 반환함으로써 코드 품질을 향상시킬 수 있는 방법을 보여줌
- 문자열에도 적용되어야 한다고 주장하는데 널 대신 빈 문자열이 반환되어야 한다는 것
- 어떤 경우에는 널 대신 빈 문자열을 반환하는 것이 적절할 수 있음(문자열이 문자들을 모아 놓은 것에 지나지 않음)

#### 문자들의 모음으로서의 문자열

- 문자열이 단지 문자를 모아 놓은 것에 불과하고 코드에서 그 외의 별다른 의미가 없다면 문자열이 없을 때 널 객체 패턴(빈 문자열)을 반환하는 것은
일반적으로 문제가 없음

```java
class UserFeedback {
    private String additionalComments;
    
    String getAdditionalComments() {
        if(additionalComments == null) {
            return "";
        }
        return additionalComments;
    }
}
```

#### ID로서의 문자열

- 문자열이 ID로 사용되는 경우 문자열이 없는지를 파악하는 것이 중요할 수 있는데 이에 따라 실행할 논리에 영향을 미칠 수 있기 때문

```java
class Payment {
    private final String cardTransactionId;
    
    String getCardTransactionId() {
        return cardTransactionId;
    }
}
```

- cardTransactionId가 널일 때 널을 반환하는 것이 나은 이유는 호출하는 쪽에서는 결제가 카드 거래를 수반하지 않을 수도 있다는 점을
명확하게 알 수 있기 때문에 코드는 예측을 벗어나지 않기 때문임

### 더 복잡한 널 객체는 예측을 벗어날 수 있다

- 함수를 호출할 때 널 객체 패턴을 사용하는 것은 본질적으로 빈 상자를 파는 것과 같음
- 호출하는 쪽에서 빈 상자를 받고 놀라거나 황당해할 가능성이 있다면 널 객체 패턴을 피하는 것이 가장 좋음
- 널 객체 패턴의 더 복잡한 형태 중 하나는 클래스를 만들고 무해한( 무해하다고 가정하는 ) 값을 클래스 안에 두는 것

```java
class CoffeeMug {
  ...
}

class CoffeeMugInventory {
    private final List<CoffeeMug> mugs;
    
    CoffeeMug getRandomMug() {
        if (mugs.isEmpty()) {
            return new CoffeeMug(0,0);
        }
        return mugs[Math.randomInt(0, mugs.size())];
    }
}
```

- getRandomMug()를 호출할 때 머그잔처럼 보이는 것을 받기 때문에 재고에 머그잔이 있다고 가정하지만 실제로는 그렇지 않음
- 무작위로 선택할 수 있는 머그잔이 없는 경우 널을 반환하는 것이 더 나을 수 있음

### 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다

- 일부 개발자들은 인터페이스나 클래스가 단순히 무언가를 반환하는 기능보다는 무언가를 수행하는 기능을 가지고 있을 때
널 객체 전용의 인터페이스나 클래스를 정의한다

------------

## 예상치 못한 부수 효과를 비파라

- 부수 효과(side effect)는 어떤 함수의 호출이 함수 외부에 초래한 상태 변화를 의미
- 함수가 반환하는 값 외에 다른 효과가 있다면 이는 부수 효과가 있는 것
- 일반적인 부수 효과 유형
  - 사용자에게 출력 표시
  - 파일이나 데이터베이스에 무언가를 저장
  - 다른 시스템을 호출하여 네트워크 트래픽 발생
  - 캐시 업데이트 혹은 무효화
- 부수 효과가 예상되고 코드를 호출한 쪽에서 그것을 원한다면 괜찮지만 부수 효과가 예상되지 않을 경우엔 버그로 이어질 수 있음

### 분명하고 의도적인 부수 효과는 괜찮다

```java
class UserDisplay {
    private final Canvas canvas;
    
    void displayErrorMessage(String message) {
        canvas.drawtext(message, Color.RED);
    }
}
```

- 클래스를 UserDisplay라고 명명하고 함수를 displayErrorMessage()라고 하는 경우 사용자에게 표시되는 캔버스를 업데이트하는 부수 효과가 발생할
것이라는 점이 명백하고 예상을 벗어나는 동작은 없다

### 예기치 않은 부수 효과는 문제가 될 수 있다

```java
class UserDisplay {
    private final Canvas canvas;
    
    Color getPixel(int x, int y) {
        canvas.redraw();
        PixelData data = canvas.getPixel(x,y);
        return new Color(
                data.getRed(),
                data.getGreen(),
                data.getBlue());
    }
}
```
- 픽셀 색상을 읽기 전에 캔버스를 다시 그리는 동작을 수행하는 것은 부수 효과이며 getPixel() 기능의 구현에 익숙하지 않은 사람이라면
예상을 벗어나는 결과가 된다
- 예상치 못한 부수 효과가 문제의 소지가 될 수 있는 몇 가지 경우가 있다

#### 부수 효과는 비용이 많이 들 수 있다

- canvas.redraw()를 호출하는 작업은 잠재적으로 비용이 상당히 많이 들 수 있으며 사용자의 디스플레이가 깜박거릴 수도 있다

#### 다중 스레드 코드의 버그

- 프로그램이 상대적으로 독립적인 여러 작업을 수행할 필요가 있는 경우 각 작업을 자체 스레드에서 실행한다
- 서로 다른 스레드가 종종 동일한 데이터에 엑세스할 수 있기 때문에 한 스레드로 인한 부수 효과는 때때로 다른 스레드에 문제를 일으킬 수 있다
- 함수에 대한 개별 호출에는 멀티스레딩 문제가 발생할 확률이 일반적으로 매우 낮으나 함수를 수천 번 혹은 수천만 번 호출할 경우 발생 확률이 누적되어
상당히 높아지고, 다중 스레드 문제와 관련된 버그는 디버깅과 테스트가 어렵다

### 해결책: 부수 효과를 피하거나 그 사실을 분명하게 하라

- 픽셀을 읽기 전에 canvas.redraw()를 호출하는 것이 정말로 필요한지를 가장 먼저 질문해야 함
- 예측 가능한 코드를 작성하기 위한 가장 좋은 방법은 애초에 부수 효과를 일으키지 않는 것
- 픽셀을 읽기 전에 canvas.redraw()를 호출해야 하는 경우 getPixel() 함수의 이름을 변경하여 부수 효과가 발생할 것이라는 점을
분명히 나타내야 한다.
  - redrawAndGetPixel()
- 함수의 이름을 바꿈으로써 호출자는 생각이 달라진다
  - 다시 그리기는 비용이 높기 때문에 for 루프에서 수천 번 호출하는 것이 과연 필요한지 한 번 더 생각해볼 수 있음
  - 해당 함수를 사용하는 다른 함수의 작성자 또한 부수 효과를 분명히 하기 위해 함수의 이름 역시 수정할것임
  - 화면 공유 기능을 구현하는 개발자는 다중 스레드 환경에서 이 함수를 호출할 때의 위험성을 즉시 인식할 수 있음

------------

## 입력 매개변수를 수정하는 것에 주의하라

### 입력 매개변수를 수정하면 버그를 초래할 수 있다

- 어떤 객체를 다른 함수에 입력으로 넘기는 것은 함수가 호출된 뒤에도 해당 객체를 다른 용도로 사용할 가능성이 큼
- 호출하는 쪽에서는 일반적으로 객체를 빌려준다고 생각하고 함수에 전달함
- 입력 매개변수를 수정하는 것은 함수가 외부의 무언가에 영향을 미치기 떄문에 부수 효과의 또 다른 예

### 해결책: 변경하기 전에 복사하라

- 입력 매개변수 내의 값을 어쩔 수 없이 변경해야 하는 경우에는 변경 전에 새 자료구조에 복사하는 것이 최상의 방법
- 값을 복사하면 메모리나 CPu 혹은 두 가지 모두와 관련해 성능에 영향을 미칠 수 있으나 입력 매개변수의 변경으로 인해 발생할
수 있는 예기치 못한 동작이나 버그와 비교하면 성능이 크게 문제되지 않는 경우가 많음

------------

## 오해를 일으키는 함수는 작성하지 말라

- displayLegalDisclaimer()라는 이름의 함수를 접한다면 이 함수의 호출 시 법적 고지 사항이 표시될 것이라고 가정한다

### 중요한 입력이 누락되었을 때 아무것도 하지 않으면 놀랄 수 있다

### 해결책: 중요한 입력은 필수 항목으로 만들라

- 중요한 매개변수가 널이 가능한 값을 받아들일 수 있게 하면 호출하는 쪽에서는 호출하기 전에 널값 여부를 확인할 필요가 없음

----------

## 미래를 대비한 열거형 처리

- 열거형에 대해서 개발자들 사이에 논쟁이 있음
  - 형 안전성을 제공하고 함수나 시스템에 유효하지 않은 입력을 방지할 수 있는 훌륭하고 간단한 방법이라는 주장
  - 열거형의 특정 값을 처리하기 윟나 논리가 코드 전반에 퍼져 있게 되기 때문에 간결한 추상화 계층을 막는다는 주장
- 열거형을 처리해야 하는 경우 나중에 열거형에 더 많은 값이 추가될 수 있다는 점을 기억해야 함

### 미래에 추가될 수 있는 열것값을 암묵적으로 처리하는 것은 문제가 될 수 있다

- 열거형 내의 현재 값을 보고 로직 처리를 할땐 나중에 다른 값이 추가되면 문제가 생길 수 있음

### 해결책: 모든 경우를 처리하는 스위치 문을 사용하라

- 열것값을 사용하여 함수 호출을 수행하는 단위 테스트와 결합할 수 있음
- 값에 대해 예외가 발생하면 테스트가 실패하기 때문에 함수도 변경해야 함을 알게 됨

### 기본 케이스를 주의하라

- 스위치 문은 일반적으로 기본(default) 케이스를 지원함
- 열거형을 처리하는 스위치 문에 기본 케이스를 추가하면 향후 열거형 값이 암시적으로 처리될 수 있음

----------

## 이 모든 것을 테스트로 해결할 수는 없는가?

- 코드를 작성하는 그 시점에는 코드를 어떻게 테스트할지 제어할 수 있지만 예상을 벗어나는 코드를 피하는 것은
작성한 코드에 대한 기술적 정확성 때문이 아닌 다른 개발자가 코드 작성을 할 때 그 코드가 올바르게 작동하도록 하기 위한 작업
- 예상을 벗어나는 코드에 숨어 있는 오류를 테스트만으로는 방지하기 어려움

----------

## 요약

- 다른 개발자가 작성하는 코든느 종종 우리가 작성하는 코드에 의존함
- 우리가 사용하는 코드에 대해 허술하게 가정을 하면 예상을 벗어나는 또 다른 결과를 볼 수 있음
- 테스트만으로는 예측을 벗어나는 코드의 문제를 해결할 수 없음
