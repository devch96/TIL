# 코드를 오용하기 어렵게 만들라

- 코드가 오용하기 쉽게 작성된다면 오용될 가능성이 있고 소프트웨어가 올바르게 작동하지 않을 것
- 코드를 잘못 사용할 수 있는 몇 가지 일반적인 경우
  - 호출하는 쪽에서 잘못된 입력을 제공
  - 다른 코드의 부수 효과(입력 매개변수 수정 등)
  - 정확한 시간이나 순서에 따라 함수를 호출하지 않음
  - 관련 코드에서 가정과 맞지 않게 수정이 이루어짐

------------

## 불변 객체로 만드는 것을 고려하라

- 객체가 생성된 후에 상태를 바꿀 수 없다면 불변(불가변, immutable)
- 불변성이 바람직한 이유를 이해하기 위해서는 반대인 가변 객체가 어떻게 문제를 일으킬 수 있는지 고려해보아야 함
- 가변 객체는 추론하기 어렵다
- 가변 객체는 다중 스레드에서 문제가 발생할 수 있다
- 객체를 불변으로 만드는 것이 항상 가능하지도 않고, 또 항상 적절한 것도 아님
  - 필연적으로 상태 변화를 추적해야 하는 경우가 있고 이때는 가변적 자료구조가 필요함
- 기본적으로는 불변적인 객체를 만들되 필요한 곳에서만 가변적이 되도록 하는 것이 바람직함

### 가변 클래스는 오용하기 쉽다

- 클래스를 가변적으로 만드는 가장 일반적인 방법은 세터(setter) 함수를 제공하는 것
- 가변 인스턴스를 전달받는 모든 코드는 인스턴스를 변경할 수 있고 이로 인해 오용의 위험성이 있다

### 해결책: 객체를 생성할 때만 값을 할당하라

- 모든 값이 객체의 생성 시에 제공되고 그 이후로는 변경할 수 없도록 함으로써 클래스를 불변적으로 만들 수 있고 오용도 방지할 수 있다.
- 클래스 내에서 변수를 정의할 때 심지어 클래스 내에서도 변수의 값이 변경되지 않도록 할 수 잇다
  - const, final, readonly 등
- 어떤 함수는 객체에 대해서 변수를 재정의할 수 있는 방법이 필요한데 이를 위해 쓰기 시 복사(copy-on-write) 패턴을 사용할 수 있다.

### 해결책: 불변성에 대한 디자인 패턴을 사용하라

- 클래스에 세터 함수를 제거하고 멤버 변수를 파이널로 표시하면 클래스가 불변적이 되고 버그를 방지할 수 있다.
  - 하지만 이렇게하면 클래스가 별로 쓸모없어질 수 있다
- 일부 값이 반드시 필요하지 않거나 불변적인 클래스의 가변적 버전을 만들어야 하는 경우 클래스를 보다 다용도로 구현해야 할 필요가 있다.

#### 빌더 패턴

- 클래스를 구성할 수 있는 일부 값이 선택 사항인 경우 생성자를 통해 해당 값을 모두 설정하는 것은 상당히 까다롭다.
- 세터 함수를 추가하여 클래스를 변경하는 것 보다는 빌더 패턴을 사용하는 것이 낫다
- 빌더 패턴은 한 클래스를 두 개로 나누는 효과를 갖는다
  - 값을 하나씩 설정할 수 있는 빌더 클래스
  - 빌더에 의해 작성된 불변적인 읽기 전용 클래스

```java
class TextOptions {
    private final Font font;
    private final Double fontSize;
    
    TextOptions(Font font, Double fontSize) {
        this.font = font;
        this.fontSize = fontSize;
    }
    
    Font getFont() {
        return font;
    }
    
    Double getFontSize() {
        return fontSize;
    }
}

class TextOptionsBuilder {
    private final Font font;
    private Double fontSize;
    
    TextOptionBuilder(Font font) {
        this.font = font;
    }
    
    TextOptionBuilder setFontSize(Double fontSize) {
        this.fontSize = fontSize;
        return this;
    }
    
    TextOptions build() {
        return new TextOptions(font, fontSize);
    }
}
```

- 빌더 패턴은 값의 일부가 선택 사항일 때 불변적 객체를 만드는 매우 유용한 방법
- 생성 후 클래스의 인스턴스 복사본을 약간 수정해야 하는 경우 역시 빌더 패턴을 사용할 수 있음(클래스에서 미리 값이 채워진 빌더를 만드는 함수 제공)

#### 쓰기 시 복사 패턴

- 클래스의 인스턴스를 변경해야 하는 경우도 있음

```java
TextOptions withFont(Font newFont) {
    return new TextOptions(newFont, fontSize);
}

TextOptions withFontSize(Double newFontSize) {
    return new TextOptions(font, newFontSize);
}
```

--------------

## 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

- 클래스가 무심코 가변적으로 될 수 있는 좀 더 미묘한 경우를 간과하기 쉬움
  - 깊은 가변성 때문
- 멤버 변수 자체가 가변적인 유형이고 다른 코드가 멤버 변수에 엑세스할 수 있는 경우에 발생할 수 있음

```java
class TextOptions {
    private final List<Font> fontFamily;
    private final Double fontSize;
    
    List<Font> getFontFamily() {
        return fontFamily;
    }
}
```

- 클래스가 글꼴 리스트를 완전히 제어할 수 없기 때문에 무의식중에 클래스가 가변적이 될 수 있음
- 글꼴 목록을 가지고 있는 것이 아닌 참조(reference)를 가지고 있다는 점을 기억해야 함
- 다른 코드에 해당 글꼴 목록에 대한 참조를 가지고 있다면 동일한 리스트를 참조하기 때문에 영향을 미침