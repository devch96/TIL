# 추상화 계층

- 코드 작성의 목적은 문제 해결
- `사용자들이 사진을 공유할 수 있는 기능이 필요` 와 같은 상위 수준의 문제부터 `두 숫자를 더하는 코드가 필요`와 같은 하위 수준의 문제까지 내려올 수 있음
- 상위 수준의 문제를 풀 때는 의식하지 못하지만 보통 여러 개의 작은 하위 문제들로 나눔
  - 사진 저장, 사진과 사용자의 연결, 사진 보여주기 등
- 코드를 구성하는 방법은 코드 품질의 기본적인 측면 중 하나이며, 코드를 잘 구성한다는 것은 간결한 추상화 계층(layers of abstraction)을 만드는 것으로
귀결될 때가 많음

------------

## 널값 및 의사코드 규약

- 많은 프로그래밍 언어에는 값(참도/포인터 등)이 없다는 개념을 가지고 있음
  - 개념을 표현하기 위해 null(널)값을 사용
- 유용하면서 문제가 많은 양극단의 역사
  - 값이 제공되지 않거나 함수가 원하는 결과를 반환할 수 없는 경우가 자주 발생하기 때문에 값이 없다 또는 부재한다는 개념은 유용
  - 값이 널일 수 있거나 널이면 안 되는 경우가 항상 명백한 것은 아니라 개발자들이 오류를 많이 접함
- 최근 몇 년 동안 널 안전성 혹은 보이드 안전성에 대한 생각이 점점 더 많은 추진력을 얻고 있음
  - 사용 중인 언어가 널 안전성을 지원한다면 사용하는 것이 좋음

```java
Optional<Element> getFifthElement(List<Element> elements) {
    if (elements.size() < 5) {
        return Optional.empty();
    }
    return Optional.of(elements.get(4));
}
```

-------------

## 왜 추상화 계층을 만드는가?

- 코드 작성은 복잡한 문제를 계속해서 더 작은 하위 문제로 세분화하는 작업
- 서버에 메시지를 보내는 코드

```java
HttpConnection connection = HttpConnection.connect("http://example.com/server");
connection.send("hello server");
connection.close();
```

- 높은 층위에서는 간단한 문제처럼 보이고 해결책도 간단하다
- 하지만 클라이언트 장치에서 서버로 문자열을 보내는 데는 복잡한 일이 일어남
  - 다행스럽게도 다른 개발자들이 모든 하위 문제를 이미 해결했음
- 하나의 문제가 있을 때 이 문제와 하위 문제에 대한 해결책이 일련의 층을 형성하고 있는 것으로 생각할 수 있음
- 최상위 계층에서는 HTTP 프로토콜이 어떻게 구현되는지 알 필요도 없이 메시지를 보내는 것에만 신경을 쓰면서 코드를 작성할 수 있음
  - 이것을 추상화 계층이라고 함

### 추상화 계층 및 코드 품질의 핵심 요소

#### 가독성

- 코드베이스에 있는 코드의 모든 세부 사항을 이해하는 것은 불가능하지만 몇 가지 높은 계층의 추상화를 이해하고 사용하기는 쉬움
- 깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한 번에 한두 개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미

#### 모듈화

- 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장하면 다른 계층이나 코드의
일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 쉬워짐

#### 재사용성 및 일반화성

- 하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기 쉬워짐
- 문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 큼
- HttpConnection 예에서 TCP/IP 및 네트워크 연결을 처리하는 시스템의 대부분은 웹소켓과 같은 다른 유형의 연결에
필요한 하위 문제를 해결하는 데도 사용될 수 있음

#### 테스트 용이성

- 코드가 추상화 계층으로 깨끗하게 분할되면 각 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 훨씬 쉬워짐

---------

## 코드의 계층

- 대부분의 프로그래밍 언어는 코드를 다른 단위로 나누기 위해 몇 가지 언어 요소를 자유롭게 사용할 수 있음
  - 함수
  - 클래스(및 구조체나 믹스인과 같이 클래스와 비슷한 요소)
  - 인터페이스
  - 패키지, 네임스페이스, 모듈 등

### API 및 구현 세부 사항

- 코드를 작성할 때 고려해야 할 측면 두 가지
  - 코드를 호출할 때 볼 수 있는 내용
    - 퍼블릭 클래스, 인터페이스 및 함수
    - 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
    - 코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 추가 정보(순서 등)
  - 코드를 호출할 때 볼 수 없는 내용
    - 구현 세부 사항
- API는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 서비스의 모든 구현 세부사항은 이 API 뒤에 감춘다
- API는 호출하는 쪽에 공개할 개념만 정의하면 되고 그 이외의 모든 것은 구현 세부사항이기 때문에 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게
만드는 데 도움이 됨
- 코드의 일부를 작성하거나 수정할 때, API에 이 수정 사항에 대한 구현 세부 정보가 새어 나간다면 추상화 계층이 명확하게 구분되어 이루어진 것이 아님

### 함수

- 어떤 로직을 새로운 함수로 구현하면 대부분 유익함
- 각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적임
- 함수가 하는 일을 다음 중 하나로 제한하면 이해하기 쉽고 단순한 문장으로 표현되는 함수를 작성하기 위한 좋은 전략이 될 수 있음
  - 단일 업무 수행
  - 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성

```java
SentConfirmation sendOwnerALetter(Vehicle vehicle, Letter letter) {
    Address ownersAddress = getOwnersAddress(vehicle);
    if (ownersAddress == null) {
        return null;
    }
    return sendLetter(ownersAddress, letter);
}

private Address getOwnersAddress(Vehicle vehicle) {
    if (vehicle.hasBeenScraped()) {
        return SCRAPYARD_ADDRESS;
    }
    Purchase mostRecentPurchase = vehicle.getMostRecentPurchase();
    if(mostRecentPurchase == null) {
        return SHOWROOM_ADDRESS;
    }
    return mostRecentPurchase.getBuyerAddress();
}
```

- 함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아짐

### 클래스

- 개발자들은 단일 클래스의 이상적인 크기에 대해 논의하고 많은 이론과 경험 법칙을 제시함
  - 줄 수 (number of lines)
    - 300줄보다 긴 클래스는 너무 많은 개념을 다루므로 분리해야 한다는 것은 항상은 아니지만 아주 많은 경우에 사실임
    - 경고의 역할만 할 뿐 어떤 것이 옳다는 보장은 아님
  - 응집력(cohesion)
    - 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도로 좋은 클래스는 응집력이 강함
  - 관심사의 분리(separation of concerns)
    - 시스템이 각각 별개의 문제(관심사)를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙
- 이러한 경험칙을 전혀 알지 못하거나 동의하지 않는 개발자들은 거의 없지만 알고 있음에도 불구하고 많은 개발자가
여전히 크고 관련없는 클래스를 작성함
- 기존 코드를 수정할 때나 완전히 새로운 코드를 작성할 때 클래스가 너무 커지는 것은 아닌지 주의해야 함

### 인터페이스

- 계층 사이를 뚜렷이 구분하고 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해 사용할 수 있는 한 가지 접근법은 어떤 함수를
외부로 노출할 것인지를 인터페이스를 통해 결정하는 것
- 하나의 추상화 계층에 대해 두 가지 이상의 다른 방식으로 구현을 하거나 향후 다르게 구현할 것으로 예상되는 경우
인터페이스를 정의하는 것이 좋음

```java
interface TextImportanceScorer {
    Boolean isImportant(String text);
}

class WordBasedScorer implements TextImportanceScorer {
  ...
  @Override
  Boolean isImportant(String text) {
      return calculateImportance(text) >= IMPORTANCE_THRESHOLD;
  }
}

class ModelBasedScorer implements TextImportanceScorer {
  ...
  @Override
  Boolean isImportant(String text) {
    return calculateImportance(text) >= IMPORTANCE_THRESHOLD;
  }
}
```

- 주어진 하위 문제에 대해 둘 이상의 서로 다른 구체적인 구현이 가능하고 이들 구현 클래스 사이에 전환이 필요할 때는
추상화 계층을 나타내는 인터페이스를 정의하는 것이 가장 좋음

#### 모든 것을 위한 인터페이스?

- 주어진 추상화 계층에 대해 한 가지 구현만 있고 향후에 다른 구현을 추가할 계획이 없더라도 여전히 인터페이스를 통해 추상화 계층을 표현해야 하는가는
팀이 결정할 사안
- 구현이 하나고, 향후 다르게 구현할 필요가 있을지 현재 알 수 없더라도 몇 가지 장점이 있음
  - 퍼블릭 API를 매우 명확하게 보여줌
    - 계층에서 사용해야 하는 기능과 사용하지 말아야 하는 기능에 대해 혼동할 일이 없음
    - 개발자가 Impl 클래스에 새 퍼블릭 함수를 추가하더라도 상위 계층은 인터페이스에만 의존하기 때문에 이 함수는 상위 계층에 노출되지 않음
  - 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다
    - 원래 코드를 작성할 때는 미래를 알지 못한다
  - 테스트를 쉽게 할 수 있다
    - 구현 클래스가 특별히 복잡하거나 네트워크 I/O에 의존하는 작업을 수행한다면 테스트 중에 목(mock)이나 페이크 객체로 대체할 수 있음
    - 이렇게하려면 프로그래밍 언어에 따라 반드시 인터페이스를 정의해야 할 수도 있다
  - 같은 클래스로 두 가지 하위 문제를 해결할 수 있음
    - 한 클래스가 두 개 이상의 서로 다른 추상화 계층에 구현을 제공할 수 있음
    - LinkedList 구현 클래스는 List 및 Queue 인터페이스를 모두 구현함
    - 코드의 일반화 가능성을 크게 높일 수 있음
- 인터페이스를 정의할 때 단점 역시 존재함
  - 더 많은 작업이 필요하다
    - 코드를 더 작성해야 함
  - 코드가 복잡해질 수 있다
    - 다른 개발자가 코드를 이해하려고 할 때 논리를 탐색하는 것이 어려울 수 있음
    - 하위 계층을 구현하는 클래스로 직접 이동하는 대신 인터페이스로 이동한 다음 구현하는 구체 클래스를 찾아야 함

### 층이 너무 얇아질 때

- 코드를 별개의 계층으로 세분화하면 장점이 많지만 추가 비용이 발생함
  - 클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는 코드(boilerplate code)로 인해 코드 양이 늘어남
  - 로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요
  - 인터페이스 뒤에 계층을 숨기게 되면 어떤 구현이 사용되는지 파악하는 데 더 많은 노력이 필요
    - 로직을 이해하거나 디버깅하는 것이 더 어려워질 수 있음

-----------

## 마이크로서비스는 어떤가?

- 마이크로서비스 아키텍처에서는 개별 문제에 대한 해결책이 단지 단일 프로그램으로 컴파일되는 라이브러리 수준이 아니라
독립적으로 실행되는 서비스로 배포됨
  - 시스템이 여러 개의 소규모 프로그램으로 분할되어 특정 작업만 전문적으로 수행함
- 마이크로서비스는 일반적으로 간결한 추상화 계층을 제공하는 것이 사실이긴 하지만 대개 크기와 범위를 기준으로 나누기 때문에 내부에서 적절한
추상화 계층을 고려하는 것이 유용함

----------

## 요약

- 코드를 깨끗하고 뚜렷한 추상화 계층으로 세분화하면 가독성, 모듈화, 재사용, 일반화 및 테스트 용이성이 향상됨
- 특정 언어에 국한된 기능뿐만 아니라 함수, 클래스 및 인터페이스를 사용하여 코드를 추상화 계층으로 나눌 수 있음
- 코드를 추상화 계층으로 분류하는 방법을 결정하려면 해결 중인 문제에 대한 판단과 지식을 사용해야 함
- 너무 비대한 계층 때문에 발생하는 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각함
  - 확실하지 않은 경우에는 남용의 위험에도 불구하고 계층을 얇게 만드는 것이 좋음
