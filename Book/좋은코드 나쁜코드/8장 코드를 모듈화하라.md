# 코드를 모듈화하라

- 모듈화의 주된 목적 중 하나는 코드가 향후에 어떻게 변겨오디거나 재구성될지 정확히 알지 못한 상태에서
변경과 재구성이 용이한 코드를 작성하는 것
- 이를 달성하기 위한 핵심 목표는 각각의 기능이 코드베이스의 서로 다른 부분에서 구현되어야 한다는 것
  - 요구 사항 중 하나가 변경된다면 코드베이스에서 그 요구 사항이나 기능과 관련된 부분만 수정하면 됨
- 코드를 모듈화하는 것은 종종 하위 문제에 대한 해결책의 자세한 세부 사항들이 독립적이고 서로 밀접하게 연관되지 않도록 하는 것으로 귀결됨
- 모듈화된 코드는 재사용과 테스트에 더 적합하기 때문에 많은 이점을 갖고 있음

----------

## 의존성 주입의 사용을 고려하라

- 일반적으로 클래스는 다른 클래스에 의존함
- 잘 구성된 코드에서는 하위 문제가 자신의 전용 클래스를 통해 해결되는 경우가 많지만 하위 문제에 대한 해결책이 항상 하나만 존재하는 것은 아니므로
하위 문제를 재구성할 수 있는 방식으로 코드를 작성하는 것이 유용함
- 의존성 주입(dependency injection)은 이를 달성하는 데 도움이 될 수 있음

### 하드 코드화된 의존성은 문제가 될 수 있다

```java
class RoutePlanner {
    private final RoadMap roadMap;
    
    RoutePlanner() {
        this.roadMap = new NorthAmericaRoadMap();
    }
}
```

- RoutePlanner 클래스는 RoadMap 인스턴스에 대한 의존성을 갖지만 생성자에 NorthAmericaRoadMap으로 하드 코드 되어 있음
  - 북미 여행 계획에만 사용될 수 있고 그 외의 다른 지역을 여행하는 데 전혀 쓸모가 없음

### 해결책: 의존성 주입을 사용하라

```java
class RoutePlanner {
    private final RoadMap roadMap;
    
    RoutePlanner(RoadMap roadMap) {
        this.roadMap = roadMap;
    }
}
```

- RoutePlanner 클래스의 인스턴스를 생성할 때 다른 로드맵도 허용된다면 클래스는 훨씬 더 모듈화되고 다용도로 쓰일 수 있다

```java
RoutePlanner europeRoutePlanner = new RoutePlanner(new EuropeRoadMap());
RoutePlanner northAmericaRoutePlanner = new RoutePlanner(new NorthAmericaRoadMap(true, false));
```

- 로드맵을 주입하면 생성자가 좀 더 복잡해진다는 단점이 있음
- 팩토리 함수를 제공하면 훨씬 더 쉽게 될 수 있음

```java
class RoutePlannerFactory {
    static RoutePlanenr createEuropeRoutePlanner() {
        return new RoutePlanenr(new EuropeRoadMap());
    }
    
    static RoutePlanner createDefaultNorthAmericaRoutePlanner() {
        return new RoutePlanner(new NorthAmericaRoadMap(true, false))
    }
}
```

- 팩토리 함수를 직접 작성하는 것의 대안으로 의존성 주입 프레임워크를 사용할 수 있음

#### 의존성 주입 프레임워크

- 의존성 주입은 클래스를 좀 더 유연하게 만드는 장점이 있지만 생성하는 부분의 코드는 더 복잡해진다는 단점도 있음
- 팩토리 함수를 만들면 되지만 많은 클래스에 대해 만들어야 한다면 그것 또한 힘든 작업이고 보일러플레이트 코드가 많아짐
- 의존성 주입 프레임워크를 사용한다면 의존성 주입과 관련된 많은 작업을 수동으로 하지 않아도 되기 때문에 개발 작업이 쉬워짐

### 의존성 주입을 염두에 두고 코드를 설계하라

- 코드를 작성하다 보면 나중에 의존성 주입을 사용하고 싶어도 사용이 거의 불가능한 코드가 짜여질 수 있기 때문에 미리 염두에 두고 설계해야 한다
- 하위 문제를 해결하기 위해 코드를 작성할 때 문제에 대한 유일한 해결책이고, 모든 사람이 그 해결책을 원할 것이라고 생각하기 쉬워 정적 함수를 작성하면
충분한 것처럼 보일 때가 많지만 상위 코드 계층에서 하위 문제에 대해 설정을 달리하고자 한다면 문제가 될 수 있음
- 하위 문제에 대한 해결책이 여러 개 있는 경우에는 의존성 주입이 특별히 중요할 수 있음

---------

## 인터페이스에 의존하라

- 어떤 클래스에 의존하고 있는데 그 클래스가 어떤 인터페이스를 구현하고 필요한 기능이 그 인터페이스에 모두 정의되어 있으면,
클래스에 직접 의존하기보다는 인터페이스에 의존하는 것이 일반적으로 더 바람직함

### 구체적인 구현에 의존하면 적응성이 제한된다

```java
class RoutePlanner {
    private final NorthAmericaRoadMap roadMap;
    
    RoutePlanner(NorthAmericaRoadMap roadMap) {
        this.roadMap = roadMap;
    }
}
```

- 의존성 주입의 이점을 여전히 갖고 있다
  - NorthAmericaRoadMap 인스턴스를 생성하는 방법에 대해 알고 있을 필요가 없음
- 하지만 RoutePlanner 클래스를 RoadMap을 구현하는 다른 클래스에 대해서는 사용할 수 없음

### 해결책: 가능한 경우 인터페이스에 의존하라

---------

## 클래스 상속을 주의하라

- 클래스 상속은 강력한 도구지만 몇 가지 단점이 있고 야기하는 문제가 치명적일 수 있기 때문에 한 클래스가 다른 클래스를 상속하는
코드를 작성하는 것에 대해서는 신중하게 생각해야 한다
- 상속을 사용할 수 있는 상황에서 많은 경우 구성(composition)을 상속 대신 사용할 수 있다

### 클래스 상속은 문제가 될 수 있다

- 