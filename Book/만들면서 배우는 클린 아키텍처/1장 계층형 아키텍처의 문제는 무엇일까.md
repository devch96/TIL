# 계층형 아키텍처의 문제는 무엇일까?

- 맨 위의 웹 계층에서는 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보냄
- 서비스에서는 필요한 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트를 호출함
- 계층형 아키텍처는 견고한 아키텍처 패턴
  - 계층을 잘 이해하고 구성한다면 웹 계층이나 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있음
  - 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술을 변경할 수 있음
  - 새로운 기능을 추가할 수 있음
- 계층형 아키텍처의 문제점은 코드에 나쁜 습관들이 스며들기 쉽게 만들고 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는
수많은 허점들을 노출함

----------

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다


- 전통적인 계층형 아키텍처의 토대는 데이터베이스
  - 웹 계층은 도메인 계층에 의존, 도메인 계층은 영속성 계층에 의존하기 때문에
  의존성 전이로 데이터베이스에 의존
- 모든 것은 영속성 계층을 토대로 만들어지는데 다양한 이유로 문제를 초래함
- 우리는 상태(state)가 아니라 행동(behavior)을 중심으로 모델링함
  - 애플리케이션의 상태가 중요한 요소이긴 하지만 행동이 상태를 바꾸는 주체이기 때문
- 하지만 의존성의 방향에 따라 자연스럽게 데이터베이스 구조먼저 생각하고 도메인 로직을 생각함
  - 비즈니스 관점에서는 전혀 맞지 않음
- 데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크를 사용하기 떄문
  - ORM 프레임워크를 계층형 아키텍처와 결합하면 비즈니스 규칙을 영속성 관점과 섞고 싶은 유횩을 쉽게 받음
- ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 두고, 계층은 아래 방향으로만 접근 가능하기 때문에 도메인 계층에서는 이러한 엔티티에 접근할 
수 있고, 접근하면 분명 사용되기 마련
- 하지만 이러면 도메인 계층과 영속성 계층에 강한 결합이 생김
- 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라 즉시로딩(eager loading)/지연로딩(lazy loading), 트랜잭션
, 캐시 플러시 등등 영속성 계층과 관련된 작업들을 해야 함
- 영속성 코드가 사실상 도메인 코드에 녹아들어가서 둘 중 하나만 바꾸는 것이 어려워지는데 이는 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와는 정확히
반대됨

---------

## 지름길을 택하기 쉬워진다

- 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근이 가능한 것
  - 팀, 도구에 따라 다르겠지만 아키텍처 자체는 이 규칙외의 규칙은 없음
- 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 계층 아래로 내려버리면 됨
  - 하지만 이런 방식이 아키텍처를 망침
  - 어떤 계층에도 속하지 않는 것처럼 보이는 헬퍼 컴포넌트나 유틸리티 컴포넌트들이 아래 계층으로 내릴 가능성이 큼
- 지름길 모드를 끄고 싶다면 아키텍처 규칙을 강제하지 않는 한 계층은 최선의 선택이 아님
  - 강제란 코드리뷰가 아닌 빌드 실패

----------

## 테스트하기 어려워진다

- 계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것
  - 엔티티의 필드 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층에 접근
- 이런 일이 자주 일어난다면 두 가지 문제점이 생김
  - 단 하나의 필드를 조작하는 것에 불과하더라도 도메인 로직을 웹 계층에서 구현
    - 유스케이스가 확장된다면?
    - 더 많은 도메인 로직을 웹 계층에 추가해서 애플리케이션 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼져나갈 확률이 높음
  - 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹(mocking)해야 함
    - 단위 테스트의 복잡도가 올라감
    - 테스트 설정이 복잡해지는 것은 테스트를 전혀 작성하지 않는 방향으로 가는 첫걸음

-------------

## 유스케이스를 숨긴다

- 계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽기 때문에 새로운 기능을 추가할 적당한 위치를
찾는 일이 어려워질 수 있다.
  - 유스케이스가 간단해서 도메인 계층을 생략한다면 로직이 웹 계층에 존재
  - 도메인 계층과 영속성 계층 모두에서 접근할 수 있도록 특정 컴포넌트를 아래로 내렸다면 로직이 영속성 계층에 존재

------------

## 동시 작업이 어려워진다

- 애플리케이션에 새로운 유스케이스를 추가할 때 개발자마다 다른 계층에 기능을 추가할 수 있나?
- 계층형 아키텍처에서는 이렇게 작업할 수 없다
  - 모든 것은 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야하고, 다음은 도메인, 다음은 웹 계층을 만들어야 한다.
  - 특정 기능은 동시에 한 명의 개발자만 작업할 수 있다.

--------------

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 올바르게 구축하고 몇 가지 추가적인 규칙들을 적용하면 계층형 아키텍처는 유지보수하기 매우 쉬워지며 코드를 쉽게 변경하거나 추가할 수 있다.
- 하지만 계층형 아키텍처는 많은 것들이 잘못된 방향으로 흘러가도록 용인한다.
  - 엄격한 자기 훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수하기 어려워짐
