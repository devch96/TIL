# 영속성 어댑터 구현하기

- 계층형 아키텍처에서는 모든 것이 영속성 계층에 의존하게 되어 데이터베이스 주도 설계가 됨
- 의존성을 역전시키기 위해 영속성 계층을 애플리케이션 계층의 플러그인으로 만듬

----------

## 의존성 역전

- 애플리케이션 서비스에서는 영속성 기능을 사용하기 위해 포트 인터페이스를 호출
  - 이 포트는 실제로 영속성 작업을 수행하고 데이터베이스와 통신할 책임을 가진 영속성 어댑터 클래스에 의해 구현
- 헥사고날 아키텍처에서 영속성 어댑터는 '주도되는','아웃고잉' 어댑터
  - 애플리케이션에 의해 호출되지만 애플리케이션을 호출하진않음
- 포트는 사실상 서비스와 영속성 코드 사이의 간접 계층

-----------

## 영속성 어댑터의 책임

- 영속성 어댑터의 책임
  - 입력을 받는다
    - 포트 인터페이스를 통해 입력을 받음
    - 입력 모델은 인터페이스가 지정한 도메인 엔티티나 특정 데이터베이스 연산 전용 객체
  - 입력을 데이터베이스 포맷으로 매핑한다
    - JPA를 사용할 때는 입력 모델을 데이터베이스 테이블 구조를 반영한 JPA 엔티티 객체로 매핑
  - 입력을 데이터베이스로 보낸다
  - 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다
  - 출력을 반환한다

------------

## 포트 인터페이스 나누기

- 서비스를 구현하면서 생기는 의문은 데이터베이스 연산을 정의하고 있는 포트 인터페이스를 어떻게 나눌 것인가
  - 특정 엔티티가 필요로 하는 모든 데이터베이스 연산을 하나의 리포지토리 인터페이스에 넣어 두는 게 일반적인 방법
  - 하지만 이렇게 하면 모든 서비스가 실제로 필요하지 않은 메서드에 의존하게 됨
- 인터페이스 분리 원칙을 적용해야 함
  - 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리해야 함
- 매우 좁은 포트를 만드는 것은 코딩을 플러그 앤드 플레이(plug-and-play) 경험으로 만듬
- 물론 모든 상황에 포트 하나당 하나의 메서드를 적용하지는 못하지만 응집성이 높고 함께 사용될 때가 많기 때문에 하나의 인터페이스에 묶고 싶은
데이터베이스 연산들이 있음

----------

## 영속성 어댑터 나누기

- 영속성 포트는 하나 이상의 클래스 생성을 금지하는 규칙은 없음
- 영속성 연산이 필요한 도메인 클래스(DDD에서의 애그리거트) 하나당 하나의 영속성 어댑터 구현 방식 OK
- 더 많은 클래스로 나눌 수도 있음
  - ORM을 이용한 영속성 포트도 구현하면서 성능을 개선하기 위해 평범한 SQL을 이용하든 다른 종류의 포트도 함께 구현하는 경우
  - JPA 어댑터 하나와 평이한 SQL 어댑터 하나를 만들고 각각이 영속성 포트의 일부분을 구현하면 됨
- 도메인 코드는 영속성 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지 관심 없음

----------

## 데이터베이스 트랜잭션은 어떻게 해야 할까?

- 트랜잭션은 하나의 특정한 유스케이스에 대해서 일어나는 모든 쓰기 작업에 걸쳐 있어야 한다.
  - 하나라도 실패할 경우 다 같이 롤백될 수 있기 때문
- 영속성 어댑터는 어떤 데이터베이스 연산이 같은 유스케이스에 포함되는지 알지 못하기 때문에 언제 트랜잭션을 열고 닫을지 결정할 수 없다.
  - 영속성 어댑터 호출을 관장하는 서비스에 위임
- 자바와 스프링에서 가장 쉬운 방법은 @Transactional 애너테이션을 애플리케이션 서비스 클래스에 붙여서 스프링이 모든 public 메서드를 트랜잭션으로 감싸게 하는 것
- 서비스가 @Transactional 애너테이션으로 오염되지 않고 깔끔하게 유지되길 원한다면 AspectJ 같은 도구를 이용하 관점 지향 프로그래밍으로 트랜잭션 경계를 코드에 위빙하면 됨

------------

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 도메인 코드에 플러그인처럼 동작하는 영속성 어댑터를 만들면 도메인 코드가 영속성과 관련된 것들로부터 분리되어 풍부한 도메인 모델을 만들 수 있음
- 좁은 포트 인터페이스를 사용하면 포트마다 다른 방식으로 구현할 수 있는 유연함이 생김
