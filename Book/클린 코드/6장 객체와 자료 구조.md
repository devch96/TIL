# 객체와 자료 구조

- 변수를 비공개(private)으로 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다.
- 하지만 왜 조회 함수(get)와 설정 함수(set)을 당연하게 외부에 노출할까?

-----------

## 자료 추상화

- 구현을 감추려면 추상화가 필요하다. 그저 조회 함수와 설정 함수로 변수를 다룬다고 클래스가 되지 않는다.
- 그보다는 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.

----------

## 자료/객체 비대칭

- 객체는 추상화 뒤로 자룔르 숨긴 채 자료를 다루는 함수만 공개하고 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
- 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우 클래스와 객체 지향 기법이 적합하고, 새로운 함수가 필요한 경우엔 절차적인 코드와 자료 구조가 좀 더 적합하다.
- 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.

--------------

## 디미터 법칙

- 디미터 법칙은 잘 알려진 휴리스틱으로 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.
- `클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다`
  - 클래스 C
  - f가 생성한 객체
  - f 인수로 넘어온 객체
  - C 인스턴스 변수에 저장된 객체

----------

## 자료 전달 객체

- 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스인데 이런 것을 때로는 자료 전달 객체(Data Transfer Object)라고 한다.
- 일반적인 형태는 bean 구조다.
- bean은 비공개 변수를 조회/설정 함수로 조작한다.

### 활성 레코드

- 활성 레코드는 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만 대게 save나 find와 같은 탐색 함수도 제공한다.
- 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.
- 활성 레코드에 비즈니스 규칙 메서드를 추가하는 것은 바람직하지 않다.

-----------

## 결론

- 객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다.
- 자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
- 시스템을 구현할 때 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하고, 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.