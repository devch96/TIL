# 좋은 코드 작성하기

------------

## 명명을 잘하는 방법

- 좋은 이름을 사용하면 LTM을 활성화하여 코드 도메인에 대해 이미 알고 있는 관련 정보를 찾을 수 있지만
나쁜 이름은 코드에 대한 잘못된 추측을 하게 하고 오개념을 유발할 수 있음

### 이름이 중요한 이유

- 클래스나 자료구조가 수행하는 모든 작업을 모호하지 않은 하나의 단어로 표현하는 것은 쉽지 않은 작업이다.

#### 명명이 중요한 이유

- 코드베이스에서 식별자(클래스, 인터페이스, 구조체, 대리자, 열거형)의 이름은 프로그래머가 명명하다.
- 식별자 이름이 중요한 이유
  - 이름은 코드베이스의 상당 부분을 차지한다
    - 코드베이스에서 읽을 내용의 상당 부분이 이름
    - 대부분 70%가 식별자에 해당
  - 코드 리뷰 시 이름의 역할
    - 코드 리뷰 4건 중 1건이 명칭과 관련된 언급을 포함할 만큼 큼
  - 이름은 문서화의 가장 쉬운 형태
  - 이름이 표식 역할을 할 수 있음

#### 명명에 대한 다양한 관점

- 좋은 이름은 문법적으로 정의할 수 있다.(사이먼 버틀러)
  - 문법에 기초한 몇 가지 규칙을 지켜야 한다는 관점
    - 비정상적인 대문자 사용
      - 식별자는 대문자를 올바르게 사용해야 함
      - paGecoUnter(X)
    - 연속된 두 개의 밑줄
      - 식별자는 연속된 여러 개의 밑줄을 가져선 안됨
      - page__counter(X)
    - 사전 등재 단어
      - 식별자는 단어로 만들어야 하고 약어는 원래의 명칭보다 더 자주 사용될 경우에만 사용해야 함
      - page_countr(X)
    - 단어의 수
      - 식별자에 사용되는 단어는 두 개에서 네 개 사이여야 함
      - page_counter_converted_and_normalized_value(X)
    - 너무 많은 단어
      - 식별자에 사용되는 단어는 네 개를 초과하면 안 됨
    - 짧은 이름
      - 식별자의 길이는 c,d,e,g,i,in,inOUt,j,k,m,n,o,out,t,x,y,z 를 제외하고 8글자보다 작으면 안 됨
      - P, page(X)
    - 열거형 식별자 선언 순서
      - 분명한 이유가 없다면 열거형은 알파벳 순서로 선언되어야 함
      - CardValue = {ACE, EIGHT, FIVE, FOUR, JACK, KING...} (X)
    - 외부 밑줄
      - 식별자는 밑줄로 시작하거나 끝나서는 안 됨
      - __page_counter(X)
    - 식별자 인고딩
      - 헝가리언 표기법 등으로 식별자 이름에 타입 정보를 나타내면 안 됨
      - int_page_coutner(X)
    - 긴 이름
      - 긴 식별자 이름은 가능한 한 피해야 함
    - 명명법 규약 이상
      - 식별자는 대문자와 소문자를 표준적이지 않은 방법으로 섞어서 사용하면 안 됨
      - Page_counter(X)
    - 숫자를 나타내는 식별자 이름
      - 식별자는 숫자만을 나타내는 단어나 수를 사용하면 안 됨
        - FIFTY(X)
- 이름은 코드베이스 내에서 일관성이 있어야 한다(알라마니스)
  - 코드베이스 전반에 걸쳐 비슷하게 명명하는 것
  - 코드베이스 전반에 걸쳐 유사한 객체에 동일한 단어를 사용하면 뇌가 LTM에 저장된 관련 정보를 더 쉽게 찾을 수 있음

#### 초기 명명 관행은 지속적인 영향을 미친다

- 새 프로젝트를 시작할 때는 초기 단계에서 이름을 만드는 방식이 그 이후로도 계속 사용될 가능성이 높기 때문에 좋은 이름을 선택하는 데 특히
주의를 기울여야 함
  - 테스트 사용 현황도 비슷

### 명명의 인지적 측면

#### 형식이 있는 이름은 STM을 도는다

- 문법적으로 비슷한 이름: 이름을 처리할 때 인지 부하가 낮음
  - 비슷한 이름들은 또한 관련 정보가 매번 같은 방식으로 제시되기 때문에 이름을 읽는 동안
  인지 부하가 낮아질 수 있음
- 코드베이스 내에서의 일관성: 청킹을 지원
  - 모든 이름의 형식이 다르다면 각각의 이름의 의미를 찾기 위해 많은 노력을 기울여야 함

#### 명확한 이름이 LTM에 도움이 된다

- 변수의 이름은 감각 기억에 의해 처리되고 STM으로 전송된다
- STM은 크기가 제한되어 있기 때문에 변수 이름을 단어별로 구분하려고 하는데 이때 이름이 체계적일수록 변수명의 각 부분을 식별하기 쉬움

#### 변수 이름은 이해에 도움이 되는 다양한 유형의 정보를 포함할 수 있다

1. 코드의 도메인에 대해 생각할 때 이름이 도움이 됨
2. 프로그래밍에 대해 생각할 때도 이름이 도움이 됨
3. 경우에 따라 변수에 LTM이 이미 알고 있는 규약에 대한 정보가 포함될 수 있음

#### 이름의 품질 평가 시기

- 코딩 이외의 시간에 이름의 품질을 숙고하는 것이 바람직
- 코드 리뷰는 식별자 이름의 품질을 검토하기에 좋은 기회

### 어떤 종류의 이름이 더 이해하기 쉬운가?

#### 축약할 것인가, 하지 않을 것인가?

- 단어 식별자를 사용한 코드 요약이 단일 문자 식별자를 사용한 코드 요약보다 더 이해하기 쉽다
- 하지만 단점도 있으니 변수 이름이 길수록 기억하기 어렵고 기억하는 데 더 많은 시간이 걸린다
- 변수 이름을 기억하기 어렵게 만드는 것은 길이 자첼가 아니라 이름에 포함된 음절의 수다.

#### 스네이크 케이스냐, 캐멀 케이스냐?

- 대부분의 프로그래밍 언어에는 변수 이름에 대한 스타일 가이드가 있지만 그 지침이 동일하지는 않는다.
  - C,C++,C#,자바는 캐멀 케이스
    - 첫글자는 소문자로 쓰고 이름 중간에 들어가는 각 새 단어는 대문자
      - customerPrice, nameLength
  - 파이썬은 스네이크 케이스
    - 식별자 이름의 단어를 밑줄로 구분
      - customer_price, name_length
- 식별자의 이름을 캐멀 케이스로 자주 작성하다 보면 이름을 청킹하고 의미 파악하는 일을 잘하게 된다

### 이름이 버그에 미치는 영향

#### 나쁜 이름을 가진 코드에 버그가 더 많다

- 코드베이스를 검사하여 잘못된 이름이 발생하는 위치를 찾아내는 일은 코드를 개선하고 버그 발생 가능성이 있는 위치를 찾는데 도움이 됨
- 이름을 개선하면 간접적으로 버그가 줄어들거나 더 나은 이름을 사용한 코드는 이해하기 쉬움

### 더 나은 이름을 선택하는 방법

#### 이름 틀

- 이름 틀은 변수 이름의 요소가 일반적으로 결합되는 패턴
  - 한 사람이 매달 최대로 받을 수 있는 혜택
    - max_benefit
    - max_benefit_per_month
    - max_benefit_num
    - ...

#### 더 나은 변수명에 대한 페이텔슨의 3단계 모델

1. 이름에 포함할 개념을 선택한다.
   - 개념은 도메인별로 아주 많이 다르며 어떤 차원을 포함할 것인지 결정하는 것이 가장 중요할 수 있음
   - 이름을 선택할 때 고려해야 할 주요 사항은 이름의 의도
   - 의도는 개체가 어떤 정보를 보유하고 있으며 무엇을 위해 사용되는지를 나타내야 하는 것
2. 각 개념을 나타낼 단어를 선택한다.
3. 이 단어들을 사용하여 이름을 구성한다.

### 요약

- 캐멀 케이스 같은 문법 규칙부터 코드베이스 내의 일관성까지 좋은 이름에 대한 다양한 관점이 존재
- 다른 차이가 없다면 스네이크 케이스로 작성된 변수보다 캐멀 케이스 변수가 기억하기 쉬움
  - 하지만 스네이크 케이스를 빨리 식별함
- 잘못된 이름이 있는 코드에서 버그가 발생할 가능성이 높음
  - 반드시 인과관계가 있는 것은 아님

-----------

## 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크

### 코드 스멜이 인지 부하를 초래하는 이유

- 코드 스멜은 작동은 하지만 개선의 여지가 있는 코드를 의미함.
  - 매우 긴 메서드나 지나치게 복잡한 스위치 문 등

#### 코드 스멜에 대한 간략한 소개

- 긴 메서드(메서드 수준)
  - 메서드는 여러 가지 다른 일을 수행하느라 라인이 길어져서는 안 됨
- 많은 인수(메서드 수준)
  - 메서드는 인수가 많으면 안 됨
- 스위치 문(메서드 수준)
  - 스위치 문이 길면 안 됨. 다형성을 통해 해결
- 다른 것처럼 보이나 같은 클래스(클래스 수준)
  - 처음 보면 다른 것처럼 보이지만 유사한 필드와 메서드를 갖는 클래스가 두 개 있으면 안 됨
- 원시 타입 집착(클래스 수준)
  - 클래스에서 원시 데이터 타입의 과도한 사용은 피해야 함
- 미완성 라이브러리 클래스(클래스 수준)
  - 메서드를 라이브러리 클래스가 아닌 임이의 클래스에 추가해서는 안 됨
- 너무 큰 클래스(클래스 수준)
  - 너무 많은 메서드와 필드를 가지고 있어 클래스가 제공하는 추상화를 불명확하게 만들어서는 안 됨
- 게으른 클래스(클래스 수준)
  - 클래스가 하는 일이 너무 적으면 존재 가치가 없음
- 데이터 클래스(클래스 수준)
  - 클래스는 데이터만 가지고 있으면 안 됨
- 임시 필드(클래스 수준)
  - 클래스는 불필요한 임시 필드를 가져서는 안 됨
- 데이터 그룹(클래스 수준)
  - 같이 사용되는 데이터는 같은 클래스나 구조체에 저장되어야 함
- 산재한 수정(코드베이스 수준)
  - 코드 수정은 한 클래스의 한 부분에서만 이루어져야 함
  - 여러 부분을 수정해야 한다면 코드 구조가 잘못된 것을 의미
- 기능 이전(코드베이스 수준)
  - 클래스 A의 많은 메서드가 클래스 B에 의해 참조된다면 그 메서드들은 B로 옮겨야 함
- 부적절한 연관(코드베이스 수준)
  - 클래스는 다른 클래스에 광범위하게 연관되지 않아야 함
- 중복 코드 또는 코드 클론(코드베이스 수준)
  - 같은 혹은 비슷한 코드가 코드베이스 내 여러 군데에서 중복돼서는 안 됨
- 주석문(코드베이스 수준)
  - 주석문은 그 코드가 무엇을 하는지가 아니라 왜 거기 있는지 설명해야 함
- 메시지 체인(코드베이스 수준)
  - 메시지 호출이 연속해서 꼬리에 꼬리를 무는 방식으로 이루어져서는 안 됨
- 미들맨(코드베이스 수준)
  - 클래스가 자신이 하는 일은 없이 위임을 많이 사용하면 클래스 존재 이규가 없음
- 평행 상속(코드베이스 수준)
  - 한 클래스의 서브 클래스를 만들 때마다 다른 클래스의 서브 클래스도 만들어야 한다면 두 클래스의 기능은 하나로 합쳐야 함
- 상속 거절(코드베이스 수준)
  - 클래스가 자신이 사용하지 않는 것을 상속받는다면 상속은 필요 없음
- 추측에 근거한 일반성(코드베이스 수준)
  - 만일의 경우를 대비한 코드를 추가하지 말고 필요한 기능만 추가해야 함
