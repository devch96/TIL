# 좋은 코드 작성하기

------------

## 명명을 잘하는 방법

- 좋은 이름을 사용하면 LTM을 활성화하여 코드 도메인에 대해 이미 알고 있는 관련 정보를 찾을 수 있지만
나쁜 이름은 코드에 대한 잘못된 추측을 하게 하고 오개념을 유발할 수 있음

### 이름이 중요한 이유

- 클래스나 자료구조가 수행하는 모든 작업을 모호하지 않은 하나의 단어로 표현하는 것은 쉽지 않은 작업이다.

#### 명명이 중요한 이유

- 코드베이스에서 식별자(클래스, 인터페이스, 구조체, 대리자, 열거형)의 이름은 프로그래머가 명명하다.
- 식별자 이름이 중요한 이유
  - 이름은 코드베이스의 상당 부분을 차지한다
    - 코드베이스에서 읽을 내용의 상당 부분이 이름
    - 대부분 70%가 식별자에 해당
  - 코드 리뷰 시 이름의 역할
    - 코드 리뷰 4건 중 1건이 명칭과 관련된 언급을 포함할 만큼 큼
  - 이름은 문서화의 가장 쉬운 형태
  - 이름이 표식 역할을 할 수 있음

#### 명명에 대한 다양한 관점

- 좋은 이름은 문법적으로 정의할 수 있다.(사이먼 버틀러)
  - 문법에 기초한 몇 가지 규칙을 지켜야 한다는 관점
    - 비정상적인 대문자 사용
      - 식별자는 대문자를 올바르게 사용해야 함
      - paGecoUnter(X)
    - 연속된 두 개의 밑줄
      - 식별자는 연속된 여러 개의 밑줄을 가져선 안됨
      - page__counter(X)
    - 사전 등재 단어
      - 식별자는 단어로 만들어야 하고 약어는 원래의 명칭보다 더 자주 사용될 경우에만 사용해야 함
      - page_countr(X)
    - 단어의 수
      - 식별자에 사용되는 단어는 두 개에서 네 개 사이여야 함
      - page_counter_converted_and_normalized_value(X)
    - 너무 많은 단어
      - 식별자에 사용되는 단어는 네 개를 초과하면 안 됨
    - 짧은 이름
      - 식별자의 길이는 c,d,e,g,i,in,inOUt,j,k,m,n,o,out,t,x,y,z 를 제외하고 8글자보다 작으면 안 됨
      - P, page(X)
    - 열거형 식별자 선언 순서
      - 분명한 이유가 없다면 열거형은 알파벳 순서로 선언되어야 함
      - CardValue = {ACE, EIGHT, FIVE, FOUR, JACK, KING...} (X)
    - 외부 밑줄
      - 식별자는 밑줄로 시작하거나 끝나서는 안 됨
      - __page_counter(X)
    - 식별자 인고딩
      - 헝가리언 표기법 등으로 식별자 이름에 타입 정보를 나타내면 안 됨
      - int_page_coutner(X)
    - 긴 이름
      - 긴 식별자 이름은 가능한 한 피해야 함
    - 명명법 규약 이상
      - 식별자는 대문자와 소문자를 표준적이지 않은 방법으로 섞어서 사용하면 안 됨
      - Page_counter(X)
    - 숫자를 나타내는 식별자 이름
      - 식별자는 숫자만을 나타내는 단어나 수를 사용하면 안 됨
        - FIFTY(X)
- 이름은 코드베이스 내에서 일관성이 있어야 한다(알라마니스)
  - 코드베이스 전반에 걸쳐 비슷하게 명명하는 것
  - 코드베이스 전반에 걸쳐 유사한 객체에 동일한 단어를 사용하면 뇌가 LTM에 저장된 관련 정보를 더 쉽게 찾을 수 있음

#### 초기 명명 관행은 지속적인 영향을 미친다

- 새 프로젝트를 시작할 때는 초기 단계에서 이름을 만드는 방식이 그 이후로도 계속 사용될 가능성이 높기 때문에 좋은 이름을 선택하는 데 특히
주의를 기울여야 함
  - 테스트 사용 현황도 비슷

### 명명의 인지적 측면

#### 형식이 있는 이름은 STM을 도는다

- 문법적으로 비슷한 이름: 이름을 처리할 때 인지 부하가 낮음
  - 비슷한 이름들은 또한 관련 정보가 매번 같은 방식으로 제시되기 때문에 이름을 읽는 동안
  인지 부하가 낮아질 수 있음
- 코드베이스 내에서의 일관성: 청킹을 지원
  - 모든 이름의 형식이 다르다면 각각의 이름의 의미를 찾기 위해 많은 노력을 기울여야 함

#### 명확한 이름이 LTM에 도움이 된다

- 변수의 이름은 감각 기억에 의해 처리되고 STM으로 전송된다
- STM은 크기가 제한되어 있기 때문에 변수 이름을 단어별로 구분하려고 하는데 이때 이름이 체계적일수록 변수명의 각 부분을 식별하기 쉬움

#### 변수 이름은 이해에 도움이 되는 다양한 유형의 정보를 포함할 수 있다

1. 코드의 도메인에 대해 생각할 때 이름이 도움이 됨
2. 프로그래밍에 대해 생각할 때도 이름이 도움이 됨
3. 경우에 따라 변수에 LTM이 이미 알고 있는 규약에 대한 정보가 포함될 수 있음

#### 이름의 품질 평가 시기

- 코딩 이외의 시간에 이름의 품질을 숙고하는 것이 바람직
- 코드 리뷰는 식별자 이름의 품질을 검토하기에 좋은 기회

### 어떤 종류의 이름이 더 이해하기 쉬운가?

#### 축약할 것인가, 하지 않을 것인가?

- 단어 식별자를 사용한 코드 요약이 단일 문자 식별자를 사용한 코드 요약보다 더 이해하기 쉽다
- 하지만 단점도 있으니 변수 이름이 길수록 기억하기 어렵고 기억하는 데 더 많은 시간이 걸린다
- 변수 이름을 기억하기 어렵게 만드는 것은 길이 자첼가 아니라 이름에 포함된 음절의 수다.

#### 스네이크 케이스냐, 캐멀 케이스냐?

- 대부분의 프로그래밍 언어에는 변수 이름에 대한 스타일 가이드가 있지만 그 지침이 동일하지는 않는다.
  - C,C++,C#,자바는 캐멀 케이스
    - 첫글자는 소문자로 쓰고 이름 중간에 들어가는 각 새 단어는 대문자
      - customerPrice, nameLength
  - 파이썬은 스네이크 케이스
    - 식별자 이름의 단어를 밑줄로 구분
      - customer_price, name_length
- 식별자의 이름을 캐멀 케이스로 자주 작성하다 보면 이름을 청킹하고 의미 파악하는 일을 잘하게 된다

### 이름이 버그에 미치는 영향

#### 나쁜 이름을 가진 코드에 버그가 더 많다

- 코드베이스를 검사하여 잘못된 이름이 발생하는 위치를 찾아내는 일은 코드를 개선하고 버그 발생 가능성이 있는 위치를 찾는데 도움이 됨
- 이름을 개선하면 간접적으로 버그가 줄어들거나 더 나은 이름을 사용한 코드는 이해하기 쉬움

### 더 나은 이름을 선택하는 방법

#### 이름 틀

- 이름 틀은 변수 이름의 요소가 일반적으로 결합되는 패턴
  - 한 사람이 매달 최대로 받을 수 있는 혜택
    - max_benefit
    - max_benefit_per_month
    - max_benefit_num
    - ...

#### 더 나은 변수명에 대한 페이텔슨의 3단계 모델

1. 이름에 포함할 개념을 선택한다.
   - 개념은 도메인별로 아주 많이 다르며 어떤 차원을 포함할 것인지 결정하는 것이 가장 중요할 수 있음
   - 이름을 선택할 때 고려해야 할 주요 사항은 이름의 의도
   - 의도는 개체가 어떤 정보를 보유하고 있으며 무엇을 위해 사용되는지를 나타내야 하는 것
2. 각 개념을 나타낼 단어를 선택한다.
3. 이 단어들을 사용하여 이름을 구성한다.

### 요약

- 캐멀 케이스 같은 문법 규칙부터 코드베이스 내의 일관성까지 좋은 이름에 대한 다양한 관점이 존재
- 다른 차이가 없다면 스네이크 케이스로 작성된 변수보다 캐멀 케이스 변수가 기억하기 쉬움
  - 하지만 스네이크 케이스를 빨리 식별함
- 잘못된 이름이 있는 코드에서 버그가 발생할 가능성이 높음
  - 반드시 인과관계가 있는 것은 아님

-----------

## 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크

### 코드 스멜이 인지 부하를 초래하는 이유

- 코드 스멜은 작동은 하지만 개선의 여지가 있는 코드를 의미함.
  - 매우 긴 메서드나 지나치게 복잡한 스위치 문 등

#### 코드 스멜에 대한 간략한 소개

- 긴 메서드(메서드 수준)
  - 메서드는 여러 가지 다른 일을 수행하느라 라인이 길어져서는 안 됨
- 많은 인수(메서드 수준)
  - 메서드는 인수가 많으면 안 됨
- 스위치 문(메서드 수준)
  - 스위치 문이 길면 안 됨. 다형성을 통해 해결
- 다른 것처럼 보이나 같은 클래스(클래스 수준)
  - 처음 보면 다른 것처럼 보이지만 유사한 필드와 메서드를 갖는 클래스가 두 개 있으면 안 됨
- 원시 타입 집착(클래스 수준)
  - 클래스에서 원시 데이터 타입의 과도한 사용은 피해야 함
- 미완성 라이브러리 클래스(클래스 수준)
  - 메서드를 라이브러리 클래스가 아닌 임이의 클래스에 추가해서는 안 됨
- 너무 큰 클래스(클래스 수준)
  - 너무 많은 메서드와 필드를 가지고 있어 클래스가 제공하는 추상화를 불명확하게 만들어서는 안 됨
- 게으른 클래스(클래스 수준)
  - 클래스가 하는 일이 너무 적으면 존재 가치가 없음
- 데이터 클래스(클래스 수준)
  - 클래스는 데이터만 가지고 있으면 안 됨
- 임시 필드(클래스 수준)
  - 클래스는 불필요한 임시 필드를 가져서는 안 됨
- 데이터 그룹(클래스 수준)
  - 같이 사용되는 데이터는 같은 클래스나 구조체에 저장되어야 함
- 산재한 수정(코드베이스 수준)
  - 코드 수정은 한 클래스의 한 부분에서만 이루어져야 함
  - 여러 부분을 수정해야 한다면 코드 구조가 잘못된 것을 의미
- 기능 이전(코드베이스 수준)
  - 클래스 A의 많은 메서드가 클래스 B에 의해 참조된다면 그 메서드들은 B로 옮겨야 함
- 부적절한 연관(코드베이스 수준)
  - 클래스는 다른 클래스에 광범위하게 연관되지 않아야 함
- 중복 코드 또는 코드 클론(코드베이스 수준)
  - 같은 혹은 비슷한 코드가 코드베이스 내 여러 군데에서 중복돼서는 안 됨
- 주석문(코드베이스 수준)
  - 주석문은 그 코드가 무엇을 하는지가 아니라 왜 거기 있는지 설명해야 함
- 메시지 체인(코드베이스 수준)
  - 메시지 호출이 연속해서 꼬리에 꼬리를 무는 방식으로 이루어져서는 안 됨
- 미들맨(코드베이스 수준)
  - 클래스가 자신이 하는 일은 없이 위임을 많이 사용하면 클래스 존재 이규가 없음
- 평행 상속(코드베이스 수준)
  - 한 클래스의 서브 클래스를 만들 때마다 다른 클래스의 서브 클래스도 만들어야 한다면 두 클래스의 기능은 하나로 합쳐야 함
- 상속 거절(코드베이스 수준)
  - 클래스가 자신이 사용하지 않는 것을 상속받는다면 상속은 필요 없음
- 추측에 근거한 일반성(코드베이스 수준)
  - 만일의 경우를 대비한 코드를 추가하지 말고 필요한 기능만 추가해야 함

#### 코드 스멜이 인지 과정에 악영향을 미치는 방식

- 긴 매개변수 목록, 복잡한 스위치 문: 작업 기억 공간의 용량 초과
  - 작업 기억 공간의 용량이 6개 정도로 작기 때문에 용량 초과가 쉬움
  - 물론 각각의 매개변수가 항상 개별 청크로 처리되는 것은 아님
    - public void line(int xOrigin, int yOrigin, int xDestination, int yDestination)
    - 이 경우 2개로 처리됨
  - 복잡한 스위치 문도 마찬가지로 작업 기억 공간이 과부하를 가질 가능성이 높음

- 신의 클래스, 긴 메서드: 효율적인 청킹이 불가능
  - 함수 및 클래스 이름의 이점은 코드를 청킹할 수 있도록 도와준다는 점
  - 하는 일이 많은 클래스인 신의 클래스와 긴 메서드는 청킹하기 힘듬
- 코드 클론: 청킹이 잘못됨
  - 유사한 코드를 보면 LTM에서 이전에 봤던 코드를 생각해냄
  - 오개념이 생길 수 있음

### 나쁜 이름이 인지 부하에 미치는 영향

- 코드 스멜은 구조적 안티패턴 문제가 있는 코드
  - 코드가 잘 작성되었지만 파악하기 어려운 구조로 만들어졌다는 것
- 언어적 안티패턴도 있음
  - 코드가 짧은 메서드와 깔끔한 클래스로 올바르게 구성되어 있지만 혼동되는 이름을 갖는 경우

#### 언어적 안티패턴

- 언어적 안티패턴은 코드의 언어적 요소와 그 역할 사이의 불일치로 묘사됨
  - 코드의 언어적 요소
    - 메서드 입출력 정의(시그니처)
    - 설명 문서
    - 속성 이름
    - 데이터 타입
    - 주석문
    - ...
  - initial_element 변수가 리스트의 요소가 아닌 원소의 인덱스인 경우
  - isValid같이 불리언 변수처럼 보이는 변수가 실제로는 정숫값을 갖는 경우
- 언어적 안티패턴은 일반적으로 메서드나 함수 이름에서도 발생하는데 메서드나 함수가 하지 않는 일이 이름에 나타날 수 있다.
  - 불리언 값을 반환하는 getCustomers
  - 이름으로는 컬렉션을 반환할 것 같지만 불리언 값을 반환함
- 6가지 언어적 안티패턴
  - 이름이 나타내는 것보다 더 많은 일을 하는 메서드
  - 이름이 나타내는 것보다 더 적은 일을 하는 메서드
  - 이름과 정반대의 일을 하는 메서드
  - 개체에 포함된 것보다 더 많은 것을 가지고 있는 것처럼 보이는 식별자 이름
  - 개체에 포함된 것을 누락하는 식별자 이름
  - 개체에 포함된 것과 반대되는 식별자 이름

#### 언어적 안티패턴이 혼란을 일으키는 이유

- 언어적 안티패턴이 포함된 코드를 읽을 때는 두 가지 인지적 문제가 발생할 수 있다.
  - 익숙치 않은 코드를 읽을 때, LTM은 관련 사실과 경험을 검색하는데 충돌하는 이름을 읽게 되면 잘못된 정보가 주어질 수 있음
  - 중복 코드처럼 잘못된 청킹이 발생할 수 있음

### 요약

- 코드 스멜은 인지 부하를 높인다.
- 언어적 안티패턴이란 코드가 실제 수행하는 작업과 맞지 않는 이름을 의미하며 높은 인지 부하를 초래한다.

---------------

## 복잡한 문제 해결을 더 잘하려면

### 문제 해결이란 무엇인가?

#### 문제 해결 요소

- 목표 상태, 즉 우리가 달성하고자 하는 것. 목표 상태에 도달하면 문제가 해결된 것으로 간주
- 문제를 해결해야 하는 시작 상태
- 시작 상태에서 목표 상태에 도달하는 방법을 규정하는 규칙

#### 상태 공간

- 프로그램을 해결할 때 고려할 수 있는 모든 단계를 문제의 상태 공간이라고 함
  - 틱택토 게임을 할 때 모든 가능한 칸의 경우가 상태 공간
  - 웹 사이트에 버튼을 추가하는 문제의 상태 공간은 모든 자바스크립트 프로그램

### 프로그래밍 문제를 해결할 때 LTM의 역할은 무엇인가?

#### 문제 해결은 그 자체로 인지 과정인가?

- 문제 해결 시 LTM 사용
  - 입력 문자열이 회문(palindrome)인지 여부를 확인하는 코드
    - 문제를 이해한다
    - 계획을 세운다(해석)
      - s.equals(reverse(s))
    - 계획을 실행한다(해결)
- 두뇌는 익숙한 문제를 해결하는 것이 더 쉽다
  - 일반적인 문제 해결 기술을 사용하면 인지 문제가 발생하는데 이때 LTM에서 전략을 인출하려고 한다.

#### 문제 해결을 위한 LTM 교육 방법

- 특정 문제에 대해 생각할 때 작업 기억 공간이 무엇을 구현할지 결정한다
  - STM으로부터 문제의 상황에 대한 정보를 가져옴
  - LTM은 관련 배경 지식 검색

#### 문제 해결에 역할을 하는 두 가지 유형의 기억

- LTM은 다양한 유형의 기억을 저장할 수 있다.
  - 절차적(암시적) 기억
    - 운동 능력이나 의식하지 않고 발휘하는 기술에 대한 기억
      - 신발 끈을 묶거나 자전거를 타는 법
  - 선언적(명시적) 기억
    - 기억할 수 있는 사실이 있고 그 사실을 자신이 알고 있다는 것을 아는 기억
    - 일화적 기억
      - 일상적으로 흔히 기억이라는 단어를 사용할 때 의미하는 기억
        - 여름 캠프에 갔거나, 배우자를 처음 만났거나 하는 등
    - 의미적 기억
      - 의미 개념 또는 사실에 대한 기억
        - 5곱하기 7은 35, 자바 클래스는 데이터와 기능을 결합하기 위해 사용한다는 것 등

- 문제를 해결할 떄 어떤 유형의 기억이 역할을 수행하는가?
  - 프로그래밍에 사용하는 기억에 관해 가장 먼저 떠오르는 것은 명시적 기억
    - 의미적 기억
      - 자바에서 루프를 구성하는 방법 기억
    - 일화적 기억
      - 계층구조와 관련된 문제를 해결해야 하는 경우 과거에 트리를 사용했었던 기억
  - 암시적 기억에도 의존함
    - 키보드 입력 시 알파벳 외에도 실수하면 곧바로 Ctrl+Z, 괄호를 열면 자동으로 닫는 괄호를 추가하는 등

### 자동화: 암시적 기억 생성

- 문제 해결 능력을 높이는 방법
  - 자동화
    - 걷기, 독서, 신발 끈 묶기와 같이 어떤 기술을 여러 번 연습한 후에 아무 생각 없이 할 수 있을 정도
    - 암시적 프로그래밍 기억을 강화해야 한다.

#### 시간 경과에 따른 암시적 기억

- 암시적 기억이 많을수록 인지 부하를 더 많이 절약할 수 있기 때문에 더 큰 문제를 해결하기 쉬움
  - 자전거를 타거나 터치 타이핑을 할 때 두뇌는 아무 노력 없이 그 일을 할 수 있음(암시적 기억이기 때문)
  - 그렇기에 자전거를 타면서 아이스크림을 먹거나 운전을 하면서 말 할 수 있음 (인지 부하를 절약)
- 두뇌에 명시적 기억으로 저장되려면 명시적 주의가 필요
- 암시적 기억은 다른 방식, 즉 반복에[ 의해 생성
- 암시적 기억은 세 가지 단계로 형성됨
  - 인지 단계
    - 무언가 새로운 것을 배우는 때
    - 새로운 정보를 더 작은 부분으로 나누고 당면한 작업에 대해 명시적으로 생각
  - 연상 단계
    - 응답 패턴이 나타날 때까지 새 정보를 적극적으로 반복해야 함
    - 작업이 어려울수록 연관 단계를 완료하는 데 시간이 더 많이 소요됨
  - 자율 단계
    - 자자율 단계에 도달하면 기술을 자동화했다고 볼 수 있음

#### 자동화를 통해 보다 신속하게 프로그램을 실행할 수 있는 이유

- LTM은 일상생활의 규칙적인 기억도 저장한다
  - 방정식을 소인수분해, 문자를 읽는 것
- 각가의 기억은 '인수분해에 대한 기억'이라는 클래스의 한 인스턴스로 간주되기에 이 이론을 인스턴스 이론이라고 함
- 유사한 작업을 마주했을 때 인스턴스 기억이 부족하면 그 작업에 대해 추론해야 하지만 인스턴스 기억을 많이 가직 ㅗ있다면
이전에 수행했던 방법을 기억하고 동일한 방법을 적용할 수 있음
- 추론을 전혀 사용하지 않고 순간적인 기억에 전적으로 의존할 때 자동화는 완전해진다고 함

#### 암시적 기억 개선

- 연습하고자 하는 기술이 필요한, 유사하지만 다른 프로그램을 많이 작성해보는 것
  - for 루프의 경우 정방향, 역방향, 단계가 다른 스테퍼 변수 사용 등 다양한 형식의 for 루프
- 복잡한 프로그래밍 개념을 이해하는 데 어려움을 겪는다면 처음부터 작성하는 것이 아닌 이미 작성된 프로그램을 수정하는 것도 고려

### 요약

- 프로그래밍에 대한 사전 지식이 현재 해결 중인 문제와 결합해 프로그래밍 문제를 얼마나 빨리 해결할 수 있는지에 영향을 미친다.
- 프로그래밍과 관련된 명시적 기억을 강화하려면 기존 코드, 코드 설계 방법에 대한 설명이 포함된 코드를 연구해야 한다.


