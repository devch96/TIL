# 코드에 대해 생각하기

-------------

## 코드를 더 깊이 있게 이해하기

- 코드가 하는 일이 무엇인지 이해하고 나면, 다음 단계는 코드에 대해 좀 더 깊이 생각하는 것이다.
  - 코드는 어떻게 작성되었고 새로운 기능은 어디에 추가해야 하며 다른 방식을 설계를 한다면? 등

### '변수 역할' 프레임워크

- 코드에 대해 추론할 때는 변수가 중심적인 역하을 한다.
  - 변수가 어떤 종류의 정보를 담고 있는지 이해하는 것은 코드를 추론하고 수정하는 데 결정적인 역할을 한다.
  - 이 때문에 적절한 변수명은 표식으로 사용될 수 있고 읽고 있는 코드를 깊이 이해하는 데도 도움이 된다.
- 변수를 이해하기 어려운 이유는 대부분의 프로그래머가 변수를 연관 지을 좋은 스키마를 자신들의 LTM에 가지고 있지 않기 때문이다
  - '변수'나 '정수'처럼 너무 많은 것을 포함하는 청크를 사용하거나 number_of_customer 같은 너무 구체적인 변수명처럼 너무 적은 것을
  포함하는 청크를 사용하는 경향이 있다고 함

#### 변수는 각자 다른 일을 한다

```
upperbound = int(input('Upper bound?'))
max_prime_factors = 0
for counter in range(upperbound):
    factors = prime_factors(counter)
    if factors > max_prime_factors:
        max_prime_factors = factors 
```
- upperbound, counter, factors, max_prime_facotrs 이렇게 4개의 변수를 갖는다.
- 변수 역할 프레임워크는 변수들의 동작에 존재하는 차이점을 포착함
  - upperbound는 최근값 보유자(most recent holder) 역할
    - 최근에 입력된 상한 값을 보유함
  - counter는 스테퍼(stepper) 역할
    - 루프를 따라 반복
  - max_prime_factors는 목적값 보유자(most wanted holder) 역할
    - 프로그램이 계산을 통해 찾고자 하는 값
  - factors도 최근값 보유자 역할
    - 가장 최근에 소인수분해된 수를 저장

#### 11가지 역할

- 어느 코드든 변수들이 하는 역할은 비슷
1. 고정값(fixed value)
   - 초기화를 통해 값이 할당된 이후 값이 변경되지 않는 변수
     - 값을 고정하는 것이 가능한 프로그래밍 언어라면 상수(constant) 아니라면 초기화 된 후 변경되지 않는 변수
     - 파이 같은 수학 상수 혹은 파일이나 데이터베이스에서 읽어 들인 데이터의 값
2. 스테퍼(stepper)
   - 루프를 반복 실행하며 값이 단계적으로 변하는 변수
     - 다음 단계가 시작할 때 그 값을 예측할 수 있음
   - for 루프를 반복할 때 사용하는 i 같은 정수
3. 플래그(flag)
   - 무엇인가 발생했거나 어떤 경우에 해당하는지를 나타내는 변수
   - is_set, is_available, is_error 등등
   - 주로 불리언 변수지만 정수 혹은 문자열도 가능
4. 워커(walker)
   - 스테퍼와 유사하게 자료구조를 순회함
   - 스테퍼와의 차이점은 자료구조를 순회하는 방식
     - 스테퍼: for i in range(0, n)처럼 항상 미리 정해진 값을 따라 반복
     - 워커: 루프가 시작되기 전에는 어떤 값을 가지게 될지 알 수 없음
   - 포인터나 정수 인덱스가 워커로 사용될 수 있음
5. 최근값 보유자(most recent holder)
   - 어떤 값이 변해갈 때 가장 최근에 변경된 값을 갖는 변수
6. 목적값 보유자(most wanted holder)
   - 찾고자 하는 값 혹은 현재까지 발견된 값 중에서 찾고자 하는 조건에 부합하는 값을 갖는 변수
     - 최솟값, 최댓값 혹은 어떤 조건을 만족하는 첫 번째 값 등
7. 모집자(gatherer)
   - 데이터를 모으거나 모은 데이터에 대해 어떤 연산을 수행하여 얻은 값을 저장하는 변수
   - for i in range(list): sum += list[i] 에서 sum이 모집자 변수
8. 컨테이너(container)
   - 값을 새로 추가하거나 삭제할 수 있는 자료구조라면 어떤 것이라도 컨테이너 변수
     - 리스트, 배열, 스택, 트리 ...
9. 추적자(follower)
   - 어떤 알고리즘에서 이전 값 혹은 다음 값을 추적해야 할 필요가 있을 때 이런 역할을 수행하는 변수
   - 항상 다른 변수와 연관되어 있음
     - 연결 리스트에서 이전 값에 대한 포인터나 이진 트리에서 이전에 방문한 원소의 인덱스
10. 조직자(organizer)
    - 다른 값을 저장하기 위한 목적으로 사용하는 변수
      - 문자열 내 개별 문자에 접근하려면 먼저 문자 배열로 변환해야 함
      - 주어진 리스트를 정렬한 결과를 따로 가지고 있어야 함
11. 임시(temporary)
    - 잠시만 사용하기 위한 변수로 temp나 t라는 변수명을 많이 사용
    - 데이터를 맞바꾸거나 메서드나 함수에서 여러 번 사용되는 계산의 결과를 저장할 때 사용

### 역할과 패러다임

- 역할은 특정한 프로그래밍 패러다임에 제한되지 않고 모든 패러다임에 나타난다.

```java
public class Dog {
    String name;
    int age;
    public Dog (String n) {
        name = n;
        age = 0;
    }
    public void birthday () {
        age++;
    }
}
```

- name은 속성이 초기화된 이후에는 변경되지 않기 때문에 '고정값' 변수
- age 속성은 0에서 시작해서 birthday() 메서드가 호출될 때마다 증가하기 때문에 스테퍼 역할

#### 역할의 이점

- 사야니에미의 프레임워크는 새로운 개념이라기보다는 변수에 대해 논의할 때 사용할 수 있는 새로운 용어를 제공해주는 정도로 생각
  - 같은 팀원끼리 공유하면 코드를 이해하고 의사소통하는 데 큰 도움이 될 것

#### 헝가리안 표기법

- 변수의 타입을 변수명에 나타내는 방식
  - strName(문자열 타입의 변수) , lDistance(롱 타입의 변수)
- 변수의 이름이 길어지므로 코드를 읽을 때 어떤 면에서는 어려움을 유발할 수 있음.
- 변수의 타입을 변경하게 되면 많은 변수에 영향을 미칠 수도 있음
- 오늘날에는 대부분의 에디터에서 변수의 타입을 쉽게 확인할 수 있고 변수명이 길어진다는 단점 때문에 그다지 유용하지 않음
  - 권장되지 않음

### 프로그램에 대해 깊이 있는 지식을 얻으려면

#### 텍스트 지식 대 계획 지식

- 패닝턴은 프로그래머가 소스 코드를 이해하는 두 개의 서로 다른 층위에 대한 모델을 제시
  - 텍스트 구조 지식
    - 키워드가 하는 일이나 변수의 역할 같은 프로그램의 표면적인 이해와 관련
  - 계획 지식
    - 프로그래머가 프로그램을 작성할 때 계획한 것이 무엇인지 혹은 무엇을 달성하려고 했는지를 나타냄

#### 프로그램 이해의 여러 단계

- 프로그램에 대한 계획 지식을 갖는다는 것은 코드의 각 부분이 다른 부분들과 어떤 방식으로 관련되어 있는지 이해하는 것을 의미
- 표면적 지식으로부터 더 깊은 이해로의 진행은 다음 4가지 단계를 거친다.

1. 초점을 찾는다.
   - 하나의 초점에서 코드 파악을 시작하라.
   - main() 메서드일 수도 있고, 런타임 오류나 프로파일러가 실행 시간이 오래 걸린다고 알려준 라인과 같이 깊은 이해가 필요한 코드일 수도 있다.
2. 초점으로부터 지식을 확장한다.
   - 코드에 존재하는 관계를 찾자.
   - 초점에서 부터 시작해 역할이 있는 관련 개체
3. 관련된 개체로부터 개념을 이해한다.
   - 코드에서 밀접하게 연결된 부분은 중요한 개념을 나타낼 가능성이 높기 때문에 이것들 역시 더 자세한 연구를 위한 초점이 될 수 있다.
   - 중요한 부분을 파악하고 나면 모든 관련 클래스를 나열하고 이들 관계에 대해 깊이 있게 생각
4. 여러 개체에 걸쳐 있는 개념을 이해한다.
   - 코드에 있는 서로 다른 개념들을 고수준에서 이해한다.
     - 자료구조 뿐 아니라 자료구조에 적용된 연산과 그 연산에 대한 제약 등

### 코드 읽기에 적용해볼 수 있는 텍스트 이해 전략

- 코드를 이해하려고 할 때 사용하는 인지적 능력은 자연언어를 읽을 때 사용하는 것과 유사하다.
- 자연언어 텍스트 이해에 대한 연구에서 얻은 통찰을 코드 읽기에도 적용할 수 있다.

### 요약

- 생소한 코드를 읽을 때는 스테퍼나 목적값과 같은 변수의 역할을 이해하는 것이 코드를 깊이 이해하는 데 도움이 된다.
- 코드를 읽는 것과 자연언어 텍스트를 읽는 것 사이에는 유사한 점이 많고, 자연언어를 배우는 능력으로 프로그래밍을 배우는 능력을 예측할 수 있다.

-----------

## 코딩 문제 해결을 더 잘하려면

- 하나의 문제에 대해 여러 가지의 해결책을 비교할 때가 있다.
  - 모든 고객을 간단한 리스트로 구성할 것인가?
  - 지점의 기본값을 기준으로 트리로 구성해 모델링할 것인가?
- 여러 가지 소프트웨어 설계에 관한 결정을 할 때 통찰력을 얻는 데 도움이 될 만한 두 가지 프레임워크
  - 문제 해결과 프로그래밍 작업 도중 두뇌가 생성하는 심적 표상
  - 문제를 풀 때 어떻게 컴퓨터에 대해 생각하는지

### 모델을 사용해서 코드에 대해 생각해보기

- 사람들은 문제를 풀 때 대부분 모델을 만듬
  - 모델은 실재를 간단하게 표현한 것
  - 주된 목적은 문제에 대해 생각해고 해결하는 데 도움을 주기 위한 것

#### 모델의 유익함

- 문제를 풀 때 코드의 모델을 명시적으로 사용하는 것은 두 가지 장점이 있음
  - 모델은 프로그램에 대한 정보를 다른 사람과 공유할 때 유용
    - 상태표를 만들 경우 각 단계에서의 변수의 값을 통해 코드가 어떻게 작동하는지 이해하는데 도움이 됨
    - 특히 대규모 시스템에 유용
  - 모델은 문제를 풀 때 도움이 됨
    - 모델을 만들면 인지 부하를 줄일 수 있음
    - 모델은 LTM이 관련된 기억을 찾는 데 도움이 되기 때문에 유용
- 하지만 모든 모델이 동일하게 유용한 것은 아님
  - 문제를 해결할 때 표현의 중요성과 효과에 대해 생각
    - 숫자 2로 나누려고 할때 이진수로 표현한 경우에는 오른쪽으로 한 비트씩 옮기기만 하면 됨
  - 문제에 대해 어떻게 생각하느냐가 문제를 해결하는 방식과 해결하기까지 들어가는 노력에 영향을 미침

### 정신 모델

- 다른 사람과 의사소통하거나 문제에 대해 좀 더 깊이 생각해야 할 때 두뇌 바깥에서 생성되는 모델을 만든다
  - 상태표, 의존 그래프, 개체 관계 도식 등(종이 or 화이트보이 or ..)
- 문제에 대해 생각할 때 두뇌 내부에서 만드는 모델을 사용할 수 있다
  - 정신 모델이라 함
  - 트리 순회 예시
    - 코드와 컴퓨터에 우리가 순회하는 실제 트리는 존재하지 않음. 메모리 내의 값이 있을 뿐
- 정신 모델은 풀어야 할 문제에 대해 추론하기 위해 사용할 수 있는 작업 기억 공간 내의 추상화

#### 새로운 정신 모델 배우기

- 프로그래밍을 배울 때 사람들은 종종 새로운 정신 모델을 점차적으로 배움
  - 하드 드라이브에 있는 문서를 실제 문서로 생각하다가 나중에 0,1만 저장된다는 사실을 암
  - 변수의 이름과 값에 대해 처음에는 주소록의 이름 및 전화번호로 생각하다 메모리 작동 방법에 대해 자세히 알게 되면 모델을 수정하기도 함
- 새로운 정신 모델을 배우면 이전의 정신 모델은 사라진다고 생각하지만 아니다.
  - 따라서 부정확하거나 불완전한 정신 모델을 사용할 위험이 항상 도사리고 있다.

#### 코드에 대해 생각할 때 정신 모델을 효율적으로 사용하는 방법

- 정신 모델이 작업 기억 공간 속에 자리 잡는다는 관점

1. 국지적 모델을 만든다
   - 상태표나 의존 그래프와 같이 손으로 직접 작성한 국지적 방법
   - 더 큰 규모의 코드에 대한 정신 모델을 만드는 데 두 가지 측면에서 도움이 됨 
     - 작업 기억 공간의 인지 부하를 낮추는 데 도움이 됨
     - 작은 모델들은 더 큰 규모의 정신 모델의 구성 요소로 사용될 수 있음
2. 코드에서 관련된 모든 객체와 객체 간의 관계를 나열한다
   - 코드 내에서 여러 구송 요소 간에 이루어지는 상호작용을 이해하려면 구성 요소를 나열한 다음 사이의 관계를 찾아야 함
   - 전체  시스템을 보다 명확하게 파악할 수 있음.
3. 시스템에 대한 질문을 만들고 이 질문의 답을 사용해서 모델을 개선한다
   - 시스템에서 가장 중요한 요소(클래스, 객체, 페이지)는 무엇인가? 모델에 그것들이 포함되었는가?
   - 이 중요한 요소들 사이의 관계는 무엇인가?
   - 프로그램의 주요 목표는 무엇인가?
   - 목표가 핵심 요소 및 그 관계와 어떻게 관련되어 있는가?
   - 일반적인 사용 사례는 무엇인가? 모델이 그것을 보여주는가?

- 정신 모델이 LTM에 저장된다는 관점
  - LTM의 스키마와 다소 유사
  - LTM에 저장된 정신 모델은 데이터를 구성하는 데 도움이 되며 이전에 본 것과 유사한 상황을 새로 접했을 때 사용할 수 있음
    - 한 번도 사용해본 적 없는 프로그래밍 언어로 작성된 트리 탐색 코드도 이해하는 예시

### 개념적 기계

- 정신 모델은 일반적으로 세상의 모든 것의 모델이 될 수 있지만, 개념적 기계는 컴퓨터가 코드를 실행하는 방법에 대해 추론할 때
사용하는 모델이다.
  - 개념적 기계는 컴퓨터가 무엇을 하고 있는지에 대한 추상적 표현

#### 개념적 기계는 무엇인가?

- 개념적 기계라는 용어에서 '개념적'이란 단어는 "제시, 추정, 이론에 근거하거나 존재하지만 실제로는 존재하지 않는다" 라는 뜻
- 컴퓨터가 어떻게 작동하는지에 대해 생각 할 때 모든 세부 사항에 관심이 있는 것은 아님
  - 어떤 가정하의 이상적인 상황에서 작동하는 것에 관심이 있음
    - 변수 x가 12라는 값을 가질 때 
      - 값이 저장된 메모리 주소와 이 주소를 변수에 연결하는 포인터에 관심이 있는 것이 아닌 x 자체에 관심

### 개념적 기계와 언어

- 프로그래밍에 관해 말할 때는 암시적으로 개념적 기계가 그 바탕에 까렬 있고 특정 정신 모델로 이어지는 경우가 많음
  - 파일이 열림, 닫힘 상태
  - 포인터가 특정 값을 가리킨다

### 개념적 기계와 스키마타

- 효과적인 개념적 기게는 프로그래밍 개념을 일상생활의 개념과 연관 짓는다
  - 일상생활의 개념에 대해서는 강한 스키마타가 이미 형성 되어 있기 때문

#### 왜 스키마타가 중요한가?

- 스키마타는 LTM이 정보를 저장하는 방식

### 요약

- 문제를 표현하는 방법은 문제에 대한 생각에 큰 영향을 미칠 수 있다.
  - 고객을 목록과 집합으로 생각하는 것은 고객 객체를 저장하고 분석하는 방법에 영향을 줌
- 정신 모델은 우리가 문제를 생각할 때 형성하는 정신적 표상. 서로 경쟁하는 여러 정신 모델을 가질 수 있음
- 개념적 기계는 실제 컴퓨터가 어떻게 기능하는지를 추상적으로 표현한 것
- 개념적 기계는 기존의 스키마타를 프로그래밍에 적용할 수 있기 때문에 이해하는데 도움이 됨

-------------

## 생각의 버그

- 버그는 일을 엉성하게 한 결과 발생하기도 한다.
  - 파일을 닫지 않거나, 이름에 오타가 생기는 것
- 더 많은 경우 버그는 생각에 착오가 있을 때 발생한다.
  - 파일 사용 후 닫아야하는 것을 모르거나 프로그래밍 언어가 자동으로 파일을 닫는다고 생각할 수 있음

### 왜 두 번째 프로그래밍 언어가 첫 번째보다 쉬울까?

- 때때로 무언가를 배울 때, 이미 배운 지식은 다른 영역에서도 유용하다
  - 전이(transfer)라고 부른다
- LTM에 저장된 프로그래밍 지식은 새로운 프로그래밍 개념을 배우는 데 두 가지 방식으로 도움이 될 수 있다.
  - 이미 많이 알고 있다면 그것에 대해 더 많이 학습하는 것이 쉬워진다.
    - LTM에 저장된 정보를 사용해서 새로운 내용을 쉽게 배우는 이 과정을 학습 도중 전이라고 부른다.
  - 완전히 낯선 상황에 이미 알고 있는 내용을 적용할 때
    - 학습 전이

#### 기존 프로그래밍 지식을 활용할 가능성을 높이는 방법

1. 숙달
   - LTM에 이미 저장되어 있는 지식과 관련한 작업을 얼마나 잘 숙달했는지
   - 작업을 더 잘 알수록 다른 도메인에 더 잘 적용할 수 있음
     - 전문 자바 프로그래머는 파이썬을 새로 배울 때 초보 자바 프로그래머보다 사전 지식의 혜택을 더 많이 받음
2. 유사성
   - 두 작업 간의 공통점
     - 새로운 프로그래밍 언어로 알고리즘을 구현하려고 할 때 알고리즘을 이미 알고 있으면 구현이 더 쉬움
3. 배경
   - 환경이 얼마나 비슷한지
     - 작업 간의 유사성뿐만 아니라 작업을 실행하는 환경 역시 중요
     - 동일한 IDE
     - 사무실에 앉아 같이 일하는 동료가 자신과 비슷한지도 중요할 수 있음
4. 중요 특성
   - 어떤 지식이 효과적인지에 대해 분명하게 알고 있는지
5. 연관
   - 두 작업이 비슷하다고 얼마나 강하게 느끼는지
6. 감정
   - 작업에 대해 어떻게 느끼는지

#### 전이의 다른 형태

- 고도 전이와 저도 전이
  - 자동화된 기술을 이전하는 것을 저도 전이(low-road transfer)
    - 새 편집기에서 아무 생각 없이 Ctrl+C, Ctrl+V
  - 복잡한 작업이 전이되는 것을 고도 전이(high-road transfer)
    - 프로그래밍 언어에서 변수를 사용하려면 먼저 선언을 해야 하기 때문에 새로운 프로그래밍 언어에서도 그렇게 해야 한다고 가정할 수 있음
- 근거리 전이와 원거리 전이
  - 가까운 영역 사이에서 지식이 전이될 때 근거리 전이(near transfer)
    - 미적분학과 대수학, C#와 자바
  - 서로 먼 영역 간에 일어나는 전이를 원거리 전이(far transfer)
    - 라틴어와 논리학, 자바와 프롤로그

#### 이미 알고 있다는 것은 저주인가 축복인가?

- 무언가를 알고 있어 새로운 것을 배우거나 새로운 작업을 할 때 도움이 되는 전이를 긍정적 전이라고 부름
  - 긍정적 전이가 일어나면 새로운 정신 모델을 처음부터 만들 필요 없이 기존 모델을 바탕으로 새로운 상황에 대한 정신 모델을 형성
- 기존 지식이 새로운 것을 배우는 데 방해가 될 때 부정적 전이라고 부름
- 부정적 전이가 깊은 악영향을 미치는 예는 많음
  - 객체 지향 언어에 익숙해진 상태에서 함수형 언어를 배울 대 어려움을 겪음

### 오개념: 생각의 버그

- 버그는 작업 중인 코드에 대해 잘못된 가정을 할 때 일어날 수 있다.

#### 개념 변화를 통한 오개념 디버깅

- 오개념은 강한 확신 속에 있는 잘못된 사고방식
  - 너무 강한 확신 떄문에 교정하기가 어려울 수 있음
- 오개념을 현재 학습 중인 언어에 맞는 정신 모델로 대체하는 과정을 개념 변화라고 함
  - 이미 학습한 지식을 LTM에서 변경해야 하기 때문에 개념 변화 학습은 일반적인 학습보다 더 어려움

#### 프로그래밍 언어에 대한 오개념

- 오개념 15: 원시 데이터 타입 변수에 대한 할당은 수식 또는 아직 연산 실행이 되지 않은 표현식을 저장한다.
  - 변수에 값을 할당할 때 어떤 관계를 저장하는 것으로 사람들이 가정한다는 것
  - total = maximum + 12를 쓰면 total 값이 maximum 값과 어떤 식으로든 연관된다고 가정
  - 이후 maximum 값이 변경되면 total 값도 변경될 것이라고 생각
  - 수학적 지식을 가진 사람들에게서 발생
- 오개념 33: 조건이 거짓으로 변경되는 즉시 while 루프가 종료된다.
  - while 루프의 정지 조건이 평가되는 시점에 대한 혼란
  - 영어 단어의 의미가 프로그래밍 이해를 방해하는 일례
- 오개념 46: 매개변수 전달에는 호출과 정의에 서로 다른 변수 이름이 필요하다.
  - 변수 이름은 함수 내부를 포함해서 단 한 번만 사용할 수 있다고 가정한 경우
  - 실제로는 같은 이름을 상용하는 것이 권장됨

#### 새로운 프로그래밍 언어를 배울 때 오개념 방지하기

1. 자신이 옳다고 확신하더라도 여전히 틀릴 수도 있다는 것을 아는 것이 중요
2. 흔하게 발생하는 오개념에 대해 의도적으로 연구해봄으로써 그런 오개념에 빠지는 것을 방지
3. 같은 프로그래밍 언어를 같은 순서로 학습한 다른 프로그래머에게 조언을 구하는 것

### 요약

- LTM에 이미 저장된 지식은 새로운 상황으로 전이될 수 있음
  - 기존 지식이 학습 속도를 높이거나 새로운 작업을 더 잘 수행하는데 도움 되면 긍정적 전이
  - 기존 지식이 새로운 것을 배우거나 새로운 작업을 수행하는데 방해가 되면 부정적 전이
- 자신이 옳다고 확신하지만 실제로는 틀릴 때 오개념을 갖게 됨
- 오개념은 단순히 자신이 틀렸다는 것을 깨닫거나 듣는 것만으로는 해결되지 않고 오래되고 잘못된 모델을 대체할 새로운 정신 모델 필요
  - 연구하고 이해해야 함
