# 분산을 고려한 MySQL 운용

-----------

## 인덱스를 올바르게 운용하기

### 분산을 고려한 MySQL 운용, 세 가지 포인트

- RDBMS에는 인덱스라는 기능이 있고, 이러한 인덱스를 적절하게 설정하는 것이 매우 중요하다

### OS 캐시 활용

- 전체 데이터 크기에 주의해서 데이터량이 물리 메모리보다 가능한 한 적어지도록 유지한다.
  - 메모리가 부족할 경우에는 정설한다.
- DB에서는 create table로 스키마를 결정한다.
  - 보통 그다지 신경 쓰지 않고 원하는 대로 설계하는 사람도 있겠지만 테이블 규모가 커지면 상당히 중요해진다.
  - 3억 레코드 정도 되면 1레코드에 칼럼을 1개(8바이트)를 추가하면 8*3억 바이트 즉 3GB만큼 데이터가 증가한다
- 서비스를 설계하는 초기단계부터 깊게 생각할 필요는 없지만 어느 정도 규모가 있는 서비스가 되면 칼럼 변경, 스키마 변경에도 그에 상응하는
주의를 기울여야만 한다.
- 대량의 데이터를 저장하려는 테이블은 레코드가 가능한 한 작아지도록 컴팩트하게 설계해야 한다.
  - 정수형 int형은 32비트이므로 4바이트, 문자열이 8비트니까 1바이트와 같이 기본적인 수치는 머리에 새겨두자

### 인덱스의 중요성

- 인덱스는 주로 탐색을 빠르게 하기 위한 것으로 그 내부 데이터 구조로는 트리가 사용됨
- MySQL의 인덱스는 기본적으로 B+트리
  - B트리에서 파생된 데이터 구조
  - B트리는 트리를 구성하는 각 노드가 여러 개의 자식을 가질 수 있는 다분 트리
  - 데이터 타입이나 삭제를 반복한 경우에도 치우침이 생기지 않는 평형 트리
  - DB에서 자주 사용됨
- B트리에 데이터를 삽입할 때는 일정한 규칙에 따라 삽입할 필요가 있는데 그 규칙 덕분에 검색할 때 일부 노드를 순회하는 것만으로
자연스럽게 찾고자 하는 데이터에 도달할 수 있음
- 계산량은 O(log n)

#### 이분트리와 B트리 비교

- 이분트리는 노드의 자식이 반드시 2개 이하지만 B트리는 자식이 많음
- B트리는 자식의 수를 조정함으로써 각 노드의 크기를 적당한 사이즈로 정할 수 있다는 것이 장점
- 노드의 크기라는 것은 디스크의 페이지와 매우 밀접한 관계가 있음
- 노드 1개로 디스크의 1블록만큼을 할당하면 B트리로 디스크 상에 저장했을 때 각 노드를 딱 1블록만큼으로 해서 저장할 수 있음
- OS는 디스크에서 데이터를 읽을 때 블록 단위로 읽어낸다고 하였는데 물리적인 동작(디스크 회전)이 발생하고 밀리초 단위로 나오기 때문에 오래 걸리지만
B트리의 경우 각 노드를 1블록에 모아서 저장되도록 구성할 수 있으므로 디스크 Seek 발생횟수를 노드를 찾아갈 때만으로 최소화할 수 있음
- OS가 한 번 읽어내서 메모리에 캐싱하게 되므로 같은 노드 내의 데이터는 디스크 Seek 없이 탐색할 수 있음
- B+ 트리는 각 노드 내에 자식 노드로의 포인터만 가지고 있고 포인터 이외에 데이터로서의 실제 값 등은 제일 마지막인 잎 노드에만 가지고 있는 구조

### 인덱스의 효과

- 4000만 건 테이블에서의 탐색
- 인덱스 없음 : 선형 탐색
  - O(n): 최대 4000만번 탐색
- 인덱스 있음 : B트리로 이분 탐색
  - O(log n): 최대 25.25번
- 계산량 측면에서 개선될 뿐만 아니라 디스크 구조에 최적화된 인덱스를 사용해서 탐색함으로써 디스크 Seek 횟수면에서도 개선된다

#### 인덱스의 작용

- MySQL은 인덱스를 걸어놓고 있는 칼럼을 대상으로 한 쿼리라도 던지는 SQL에 따라서는 그것이 사용되거나 사용되지 않기도 함
- 기본적으로 인덱스가 사용되는 것은 where, order by, group by의 조건에 지정된 칼럼
- 인덱스로서 작용하는 것은 명시적으로 추가한 인덱스와 Primary Key, UNIQUE 제약
- 복수 칼럼이 동시에 인덱스를 태우고자 할 경우에는 복합 인덱스를 사용해야만 함

### 인덱스가 작용하는지 확인하는 법

- SQL을 던지기 전에 explain 명령을 실행하면 인덱스가 작용하는지 여부를 전부 조사해줌

#### explain 명령에서 속도에 유의하라

- 속도에 신경 쓰고자 할 때는 explain 명령으로 자신이 던지려고 하는 SQL에 제대로 인덱스가 작용하는지 여부를 확인하면서 개발하면 좋다
- 인덱스의 작용법이라는 의미에서 Extra 열도 중요하다
  - Using Where 이외에 Using filesort(외부 정렬)나 Using temporary(임시 테이블)은 기본적으로 좋지 않다
- explain의 row in set 부분의 시간은 explain 명령을 실행하는 시간이지 SQL을 던졌을 때의 평가가 아니다

------------

## MySQL의 분산

### MySQL의 레플리케이션 기능

- 레플리케이션이란 마스터(master)를 정하고 마스터를 뒤따르는 서버(slave)를 정해두면 마스터에 쓴 내용을 슬레이브가 폴링해서 동일한 내용으로 자신을 갱신하는 기능이다.
  - 슬레이브는 마스터의 레플리카가 되는 것
  - 동일한 내용의 서버를 여러 대 마련할 수 있음
- 마스터/슬레이브로 레플리케이션해서 서버를 여러 대 준비하게 되면 AP 서버에서는 로드밸런서를 경유해서 슬레이브로 질의하여 쿼리를 여러 서버로 분산할 수 있다
  - select 등 참조 쿼리만 로드밸런서로 흘러가도록 하고 갱신 쿼리는 마스터로 직접 던짐
  - 갱신 쿼리를 슬레이브로 던지게 되면 슬레이브와 마스터 간 내용을 동기화할 수 없음

-----------

## MySQL의 스케일아웃과 파티셔닝

### MySQL의 스케일아웃 전략

- 기본적인 스케일아웃 전략으로는 데이터가 메모리에 올라가는 크기이면 메모리에 올리고
올라가지 않으면 메모리를 증설하는 것

### 파티셔닝을 전제로 한 설계

- JOIN 쿼리를 던지기 위해서는 테이블을 파티셔닝할 수 없다
  - 여기서 분할이란 다른 머신으로 나눈다는 의미
- JOIN 쿼리는 대상이 되는 테이블을 앞으로도 서버 분할하지 않을 것이라고 보장할 수 있을 때에만 사용한다
- JOIN을 사용하지 않는다면 쿼리를 나눠서 실행해야 한다

### 파티셔닝의 상반관계

- 파티셔닝의 좋은 점은 부하가 내려가고 국소성이 늘어나서 캐시 효과가 높아진다는 점

#### 운용이 복잡해진다

- 용도가 다른 서버가 생기는 것이기 때문에 운용이 복잡해진다.
- DB를 많이 분할할경우 어디에 어떤 DB가 있는지 파악하는 게 매우 힘듬
- 고장이 났을 때도 어디서 고장이 났는지 찾는 것만 해도 오래걸림
- 운용이 복잡해지면 결국 복구에 시간이 더 걸리게 됨

#### 고장률이 높아진다

- 대수가 늘어나는 만큼 고장확률이 높아진다
