# 세부사항

---------

## 데이터베이스는 세부사항이다

- 아키텍처 관점에서 볼 때 데이터베이스는 엔티티가 아님
  - 세부사항이라 아키텍처의 구성요소 수준으로 끌어올릴 수가 없음
- 데이터베이스는 일개 소프트웨어일 뿐
  - 데이터에 접근할 방법을 제공하는 유틸리티
  - 아키텍처 관점에서 보면 이런 유틸리티는 저수준의 세부사항(메커니즘)
- 뛰어난 아키텍트라면 저수준 메커니즘이 시스템 아키텍처를 오염시키게 두지 않음

### 관계형 데이터베이스

- 관계형 데이터베이스의 기술이 얼마나 뛰어나든, 유용하든, 견고하든 그저 기술일 뿐임
  - 이것은 세부사항이란 말
- 특정한 형식의 데이터에 접근하는 경우에는 편리하지만 아키텍처 관점에서는 데이터를 어떤 방식으로 배치한다는것은
중요치 않음
- 데이터가 테이블 구조를 가진다는 사실은 최하위 수준의 유틸리티 함수만 알아야 함
- 테이블과 행이 객체 형태로 시스템 여기 저기에서 돌아다니게 허용하는 것은 아키텍처적으로 잘못된 설계.

### 데이터베이스 시스템은 왜 이렇게 널리 사용되는가?

- 오라클, MySQL, SQL 서버가 우위를 차지할 수 있던 이유는 바로 디스크 때문.
- 디스크의 발전은 경이로우나 치명적인 한 가지 특성으로 인해 개발자들이 괴로움
  - 느리다
- 디스크 때문에 피해갈 수 없는 시간 지연이라는 짐을 완화하기 위해 인덱스, 캐시, 쿼리 계획 최적화가 필요
- 데이터를 표현하는 일종의 표준 방식도 필요했는데 인덱스, 캐시, 쿼리 계획에서 작업 중인 대상이 어떤 데이터인지 알 수 있어야 했기 때문
  - 데이터 접근 및 관리 시스템 필요
    - 파일 시스템
    - 관계형 데이터베이스 관리 시스템(RDMBS)
- 파일 시스템은 문서(document) 기반
  - 이름을 기준으로 저장하거나 조회할 때는 잘 동작하지만 내용 기준으로 검색할 때는 도움되지 않음
    - login.c 이름의 파일은 쉽게 찾을 수 있으나 x라는 변수명이 포함된 .c 파일을 모두 찾는건 어려울 뿐 아니라 오래걸림
- 데이터베이스 시스템은 내용 기반
  - 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법 제공
  - 정형화되지 않은 문서를 저장하고 검색하는 데는 대체로 부적합

### 디스크가 없다면 어떻게 될까?

- 디스크는 점점 RAM으로 대체되고 있다.
- 데이터가 데이터베이스나 파일 시스템에 있더라고 RAM으로 읽은 후에 다루기 편리한 형태로 그 구조를 변경함
  - 리스트, 집합, 스택, 큐, 트리 등
  - 데이터를 파일이나 테이블 형태로 그대로 두는 경우는 거의 없음

### 세부사항

- 데이터베이스가 세부사항인 이유가 위의 내용
- 데이터베이스는 그저 매커니즘
  - 디스크와 RAM 사이에서 데이터를 이리저리 옮길 때 사용할 뿐
- 데이터베이스는 비트를 담는 거대한 그릇이며 데이터를 장기적으로 저장하는 공간에 지나지 않음
- 아키텍처 관점에서 본다면 데이터가 있기만 한다면 데이터가 어떤 형태인지는 절대 신경써서는 안됨

### 하지만 성능은?

- 성능은 아키텍처적인 관심사가 맞지만 데이터 저장소의 측면에서 성능은 완전히 캡슐화하여 업무 규칙과는 분리할 수 있는 관심사
  - 데이터 저장소에서 데이터를 빠르게 넣고 뺄 수 있어야 하는 것은 맞지만 이건 저수준 관심사
- 성능은 시스템의 전반적인 아키텍처와는 아무런 관련이 없음

### 결론

- 체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요함
  - 반면 그저 데이터를 디스크에서 이리저리 옮길 뿐인 기술과 시스템은 아키텍처적으로 중요치 않음
- 데이터는 중요
- 데이터베이스는 세부사항

-----------

## 웹은 세부사항이다

### 끝없이 반복하는 추

- 웹이 있기 전에는 클라이언트-서버 아키텍처
  - 그 전에는 중앙집중식 미니컴퓨터
  - 그 전에는 그린 스크린
  - ...
- IT 역사 전체로 시야를 넓히면 웹은 아무것도 바꾸지 않았다.
  - 단지 사용 방법이 바뀌는 것 뿐(진동)
- 아키텍트로서 진동은 그저 핵심 업무 규칙의 중심에서 밀어내고 싶은 단기적인 문제일 뿐

### 요약

- GUI는 세부사항
  - 웹은 GUI
  - 따라서 웹도 세부사항
- 자바스크립트의 유효성 검증이나 드래그-앤-드롭 방식의 AJAX 호출, 웹 페이지에 넣을 수 있는 다른 무수한 위젯과 가젯으로 인한 복잡함을 생각해 볼 때
웹에서 장치 독립성은 비현실적이라고 주장할 수 있음
  - 어느정도는 옳지만 UI와 애플리케이션 사이에는 추상화가 가능한 또 다른 경계가 존재

### 결론

- 이러한 종류의 추상화는 만들기 쉽지 않고, 제대로 만들려면 수차례의 반복 과정을 거쳐야 하나 불가능하지 않다.
  - 세상은 마케팅 귀재로 가득하기 때문에 이러한 추상화가 꼭 필요할 때가 많다고 주장할 수 있음
    - UI를 바꿔주세요~

------------

## 프레임워크는 세부사항이다

- 아무리해도 프레임워크는 아키텍처가 될 수 없다.

### 프레임워크 제작자

- 프레임워크 제작자는 내가 풀어야 할 문제를 모름
  - 자신들이 해결해야 할 고유한 문제나 동료와 친구들의 문제는 알지만 나의 문제를 해결하기 위한 것이 아님
    - 대부분은 겹칠수도
    - 겹치면 더 유용해짐

### 혼인 관계의 비대칭성

- 프레임워크를 사용해야 할 경우 문서를 꼼꼼히 읽고 소프트웨어와 어떻게 통합할 지 고민한다.
- 하지만 모든 위험과 부담은 우리가 감수해야지 제작자가 감수하는 건 아무것도 없다

### 위험 요인

- 프레임워크의 아키텍처는 그다지 깔끔하지 않은 경우가 많음
  - 의존성 규칙을 위반하는 경향이 있음
  - 업무 객체를 만들 때 프레임워크 제작자는 자신의 코드를 상속할 것을 요구함
  - 프레임워크가 한번 안으로 들어가버리면 다시는 원 밖으로 나오지 않음
- 프레임워크는 애플리케이션의 초기 기능을 만드는 데는 도움이 되긴 함
  - 제품이 성숙해지면서 프레임워크가 제공하는 기능과 틀을 벗어나는 경우가 생김
  - 프레임워크와 계속 싸우고 있을 수도
- 프레임워크는 우리에게 도움되지 않는 방향으로 진화할 수도 있음
  - 도움도 되지 않는 신규 버전으로 업그레이드하느라 다른 일을 못할 수도 있음
  - 사용 중인 기능이 사라지거나 반영하기 힘튼 형태로 변경될 수도 있음
- 새롭고 더 나은 프레임워크가 등장해서 갈아타고 싶을 수도 있음

### 해결책

- 프레임워크를 사용하나 결합해서는 안됨
- 프레임워크는 아키텍처의 바깥쪽 원에 속하는 세부사항으로 취급
- 업무 객체를 만들 때 프레임워크가 자신의 기반 클래스로부터 파생하기를 요구한다면?
  - 거절하고 프락시를 만들고 업무 규칙에 플러그인할 수 있는 컴포넌트에 프락시를 위치
- 프레임워크가 핵심 코드 안으로 들어오지 못하게 하라
  - 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합하고 의존성 규칙을 준수
- 스프링의 예
  - 훌륭한 의존성 주입 프레임워크
  - @Autowired 어노테이션이 업무 객체 도처에 산재해서는 안 됨
  - 업무 객체보다는 메인 컴포넌트에서 스프링을 사용해서 의존성을 주입하는 편이 좋음

### 결론

- 프레임워크와의 첫만남부터 결혼하지 마라
- 가급적이면 프레임워크를 가능한 한 오랫동안 아키텍처 경계 너머에 두는것이 낫다

----------

## 사례 연구: 비디오 판매

### 제품

- 웹 사이트에서 비디오를 판매하는 소프트웨어
- 개인은 단품 가격을 지불해 스트리밍, 더 높은 가격을 내고 다운(영구 소장)
- 기업은 스트리밍 전용, 대량구매시 할인
- 액터
  - 개인(시청자, 구매자)
  - 기업(다른 사람들이 시청할 비디오를 구매하는 사람)
  - 비디오 제작자(비디오 파일과 비디오에 대한 설명서, 부속 파일 제공)
  - 관리자(신규 비디오 시리즈물 추가 혹은 기존 시리즈물 비디오 추가 삭제, 가격 책정)
- 시스템의 초기 아키텍처를 결정하는 첫 단계는 액터와 유스케이스를 식별하는 일

### 유스케이스 분석

- 단일 책임 원칙에 따르면 네 액터가 시스템이 변경되어야 할 네 가지 주요 근원
  - 신규 기능 혹은 기존 기능을 변경해야 한다면 이들 액터 중 하나에게 해당 기능을 제공하기 위해서
- 시스템을 분할하여 특정 액터를 위한 변경이 나머지 액터에게 전혀 영향을 미치지 않게 만들고자 함
- 추상 유스케이스는 범용적인 정책을 담고 있으며 다른 유스케이스에서 이를 더 구체화 한다.
  - 시청자 입장에서 카탈로그 조회하기
  - 구매자 입장에서 카탈로그 조회하기
  - 이 두 유스케이스 모두 카탈로그 조회하기라는 추상 유스케이스를 상속받음

### 결론

- 단일 책임 원칙에 기반한 액터의 분리, 의존성 규칙을 생각하자
- 코드를 한번 구조화하고 나면 시스템을 실제로 배포하는 방식은 다양하게 선택할 수 있다.
