# 컴포넌트 원칙

- SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.
- 대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다.

--------

## 컴포넌트

- 컴포넌트는 배포 단위다.
  - 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위
  - 자바의 경우 jar 파일
- 컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한
능력을 갖춰야 한다.

### 컴포넌트의 간략한 역사

- 소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다.
  - 프로그램의 시작부에는 프로그램이 로드될 주소를 선언하는 오리진(origin) 구문이 나와야 했다.
- 이러한 구시대에는 프로그래머가 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.
- 하지만 이 시대에는 장치는 느리고 메모리는 비싸 자원이 한정적이었기 때문에 이러한 접근법은 문제가 있었다.
- 컴파일 시간을 단축시키기 위해 프로그래머는 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리했다.
  - 함수 라이브러리를 개별적으로 컴파일하고, 컴파일된 바이너리를 메모리의 특정 위치에 로드했다.
  - 함수 라이브러리에 대한 심벌 테이블을 생성한 후, 이를 이용해 애플리케이션 코드를 컴파일했다.
  - 애플리케이션을 실행해야 한다면 바이너리 함수 라이브러리를 로드한 다음 애플리케이션을 로드했다.
- 하지만 이러한 방식도 프로그래머가 함수 라이브러리에 더 많은 함수를 추가하면 할당된 메모리 주소를 넘어서게 되고, 추가 공간을 할당해야 한다.

### 재배치성

- 해결책은 재배치가 가능한 바이너리(relocatable binary)였다.
  - 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자는 것
- 로더는 재배치 코드가 자리할 위치 정보를 전달받았다.
- 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었다.
- 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다.
  - 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조(external reference)로 생성했다.
  - 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 이를 외부 정의(external definition)
- 이렇게 함으로써 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다.
- 이렇게 링킹 로더(프로그램을 로드하는 동시에 링크까지 수행하는 로더)가 탄생했다.

### 링커

- 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었으나 1960년대 말과
1970년대 초가 되자 프로그램이 커지게 되면서 링킹 로더가 너무 느려서 참을 수 없는 지경에 다다랐다.
  - 함수 라이브러리는 자기 테이프(magnetic tape)와 같이 느린 장치에 저장되었다
    - 디스크조차도 상당히 느렸다
  - 링킹 로더는 이처럼 느린 장치를 사용해서 수십에서 수백 개의 바이너리 라이브러리를 읽고 외부 참조를 해석해야 했다.

### 결론

- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.

-------------

## 컴포넌트 응집도

- 어떤 클래스를 어느 컴포넌트에 포함시켜야 할까? 라는 결정은 중요한 결정이므로 제대로 된 소프트웨어 엔지니어링 원칙의 도움을 받아야 한다.
- 컴포넌트 응집도와 관련된 세 가지 원칙
  - REP: 재사용/릴리스 등가 원칙(Reuse/Release Equivalence Principle)
  - CCP: 공통 폐쇄 원칙(Common Closure Principle)
  - CRP: 공통 재사용 원칙(Common Reuse Principle)

### REP: 재사용/릴리스 등가 원칙

- 재사용 단위는 릴리스 단위와 같다.
- 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수 없고,
하지도 않을 것
  - 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.
- 이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성이 높은 클래스와 모듈들로 구성되어야 함을 뜻함
  - 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 함
- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 함

### CCP: 공통 폐쇄 원칙

- 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
  - SRP를 컴포넌트 관점에서 다시 쓴 것이다.
- 대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
  - 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.
- CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.

#### SRP와의 유사성

- SRP에서는 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라고 말한다.
- CCP에서는 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라고 말한다.

### CRP: 공통 재사용 원칙

- 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라
- CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.
  - 개별 클래스가 단독으로 재사용되는 경우는 거의 없다.
  - 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다.
- 간단한 사례로 컨테이너(container) 클래스와 해당 클래스의 이터레이터(iterator)클래스
  - 이들 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용된다.
  - 반드시 동일한 컴포넌트에 위치해야 한다.
- 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.
  - 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다.
    - 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다.

#### ISP와의 관계

- CRP는 ISP의 포괄적인 버전이다.
- ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언한다.
- CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.

#### 필요하지 않은 것에 의존하지 말라.

### 컴포넌트 응집도에 대한 균형 다이어그램

- REP와 CCP는 포함 원칙이다.
  - 두 원칙은 컴포넌트를 더욱 크게 만든다.
- CRP는 배제 원칙이다.
  - 컴포넌트를 더욱 작게 만든다.
- 원칙들이 균형을 이루는 방법을 찾아야 한다.

### 결론

- 어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다.
  - 이 균형점은 거의 항상 유동적이다.
- 시간이 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다.

------------

## 컴포넌트 결합

- 컴포넌트 사이의 관계를 설명하는 세 가지 원칙

### ADP: 의존성 비순환 원칙

- 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.
- 무언가를 작동하게 만들어 놓고 퇴근했는데 이튿날 출근해 보면 전혀 돌아가지 않는 경험
  - 누군가가 의존하고 있던 무언가를 수정했기 때문
  - 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생
- 해결책은 두 가지 방법
  - 주 단위 빌드
  - 의존성 비순환 원칙

#### 주 단위 빌드 (Weekly Build)

- 중간 규모의 프로젝트에서는 흔하게 사용
- 모든 개발자는 일주일의 첫 4일 동안은 서로를 신경쓰지 않는다.
- 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.
- 5일 중 4일 동안 개발자를 고립된 세계에서 살 수 있게 보장해 준다는 아주 멋진 장점이 있으나 금요일에 통합과 관련된 막대한 업보를 치러야 한다.
- 프로젝트가 커지면 이러한 흐름은 위기를 초래한다.

#### 순환 의존성 제거하기

- 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것
- 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 됨.
- 각 팀은 특정 컴포넌트가 새롭게 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다.
- 하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다.
  - 의존성 구조에 순환이 있어서는 안 된다.

#### 순환 끊기

- Entities 컴포넌트에서 Authorizer 컴포넌트를 사용해야 하는 상황.

1. 의존성 역전 원칙(DIP)을 적용한다.
   - Entities의 User가 필요로 하는 메서드를 제공하는 인터페이스를 생성
   - 이 인터페이스는 Entities에 위치시키고 Authorizer에서는 이 인터페이스를 상속
   - 이렇게 하면 Entities와 Authorizer 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있음.
     - Entities가 (->) Authorizer 에 의존
     - Authorizer가 (->) Entities의 인터페이스를 상속

2. Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다.
   - 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

#### 흐트러짐(Jitters)

- 두 번째 해결책에서 시시하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실이다.
- 프로젝트가 성장하면서 의존성 구조는 서서히 흐트러지며 또 성장한다.
  - 순환이 발생하는지를 항상 관찰해야 함
  - 순환이 발생하면 어떤 식으로든 끊어야 함

#### 하향식(top-down) 설계

- 컴포넌트 구조는 하향식으로 설계될 수 없다.
- 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 시스템이 성장하고 변경될 때 함께 진화한다.
- 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다.
  - 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도
- 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.
  - 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요 없기 때문

--------------

### SDP: 안정된 의존성 원칙

- 안정성의 방향으로 더 안정된 쪽에 의존하라
- 설계는 결코 정적일 수 없다.
  - 변경은 불가피하다.
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.
- 안정도니 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어짐ㄴ 모듈에 의존하지 않도록 만들 수 있다.

#### 안정성

- 동전을 옆면으로 세우면 안정적인가? 답은 아니오다. 하지만 건드리지 않는다면 꽤 오랫동안 서 있을 수 있다.
  - 안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없다.
  - 동전의 경우 옆으로 쓰러지는 등 상태가 변하지는 않았지만 안정적이라고 보기는 어렵다.
- 안정성은 변경을 만들기 위해 필요한 작업량과 관련된다.
  - 옆면으로 선 동전이 안정적이지 않은 이유는 그다지 힘을 쓰지 않고도 넘어뜨릴 수 있기 때문
  - 탁자는 상당히 안정적인데 탁자를 뒤집으려면 수고를 감수해야 하기 때문
- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.
  - 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있다.
- 세 컴포넌트가 X 컴포넌트에 의존하는 경우
  - X는 세 컴포넌트를 책임진다(responsible)라고 말한다.
  - 반대로 X는 어디에서도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 없기 때문에 독립적이다(independent)라고 말한다.

#### 안정성 지표

- 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보는 방법
  - 컴포넌트가 위치상(positional) 어느 정도의 안정성을 가지는지 계산할 수 있다.
    - Fan-in: 안으로 들어오는 의존성
    - Fan-out: 바깥으로 나가는 의존성
    - I(불안정성): I=Fan-out / (Fan-in + Fan-out) ([0,1] 범위의 값)
      - 0이면 최고로 안정된 컴포넌트
- SDP에서 컴포넌트의 I 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야 한다고 말한다.
  - 의존성 방향으로 갈수록 I 지표 값이 감소해야 한다.

#### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

- 모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능한데 이는 바람직한 상황이 아니다.
- 우리가 컴포넌트 구조를 설계할 때 기대하는 것은 불안정한 컴포넌트도 있고 안정된 컴포넌트도 존재하는 상태다.

### SAP: 안정된 추상화 원칙

- 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

#### 고수준 정책을 어디에 위치시켜야 하는가?

- 업무 로직이나 아키텍처와 관련된 결정에는 변동성이 없기를 기대한다.
- 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야 한다.
  - 하지만 고수준 정책을 안정된 컴포넌트에 위치시키면 그 정책을 포함하는 소스 코드는 수정하기가 어려워진다.
  - 이로 인해 시스템 전체 아키텍처가 유연성을 잃는다.
- 컴포넌트가 최고로 안정된 상태(I=0)이면서 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?
  - OCP
  - 추상 클래스

#### 안정된 추상화 원칙

- 안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.
- 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다.

#### 추상화 정도 측정하기

- Nc: 컴포넌트의 클래스 개수
- Na: 컴포넌트의 추상 클래스와 인터페이스의 개수
- A: 추상화 정도. A = Na / Nc
- A 지표는 [0,1] 사이의 값

### 결론

- 지표는 그저 임의로 결정된 표준을 기초로 한 측정값에 지나지 않는다.
- 경험을 통해 좋은 의존성과 좋지 않은 의존성을 배워야 한다.
