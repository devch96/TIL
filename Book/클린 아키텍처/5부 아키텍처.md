# 아키텍처

---------

## 아키텍처란?

- 소프트웨어 아키텍트는 최고의 프로그래머이며, 계속 프로그래밍 작업을 맡을 뿐만 아니라 동시에 나머지 팀원들이
생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어 준다.
- 소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태다.
  - 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에
  따라 정해진다.
  - 그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.
- 우리는 시스템이 제대로 동작하기를 바라며, 시스템 아키텍처는 이를 최우선 목표 중 하나로 지원해야 한다.
- 하지만 시스템 아키텍처는 시스템의 동작 여부와는 거의 관련이 없다.
  - 형편없는 아키텍처도 동작은 한다. 하지만 이러한 시스템들은 운영에서 문제가 아닌 배포, 유지보구, 계속되는 개발 과정에서 어려움을 겪는다.
  - 그렇다고 해서 아키텍처가 시스템이 제대로 동작하도록 지원하는 데 아무런 역할을 하지 않는다는 것은 아니다.
    - 하지만 이 역할은 수동적이며 피상적인 것이지 능동적이며 본질적인 것은 아니다.
- 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.
  - 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 쉽게 배포하게 해준다.
- 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

### 개발

- 개발 팀 구조가 다르다면 아키텍처 관련 결정에서도 차이가 난다.
  - 개발자 다섯 명으로 구성될 정도로 작다면, 잘 정의된 컴포넌트나 인터페이스가 없더라도 서로 효율적으로 협력하여
  모놀리틱 시스템을 개발할 수 있다.
    - 소수 개발 팀은 개발 초기에 아키텍처 관련 제약들이 오히려 방해가 된다고 여길 가능성이 높다.
    - 수많은 시스템에서 좋은 아키텍처가 결여된 이유
  - 일곱 명씩 총 다섯 팀이 시스템을 개발하고 있다면 시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면
  개발이 진척되지 않는다.

### 배포

- 배포 비용이 높을수록 시스템의 유용성은 떨어진다.
- 소프트웨어 아키텍처는 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.

### 운영

- 아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 덜 적극적이다.
  - 운영에서 겪는 대다수의 어려움은 단순히 하드웨어를 더 투입해서 해결할 수 있다.
- 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다.

### 유지보수

- 유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 비용이 가장 많이 든다.
  - 새로운 기능은 계속 생기고, 뒤따라서 발생하는 결함은 피할 수 없으며, 결함을 수정하는 데도 엄청난 인적 자원이 소모된다.
- 유지보수의 가장 큰 비용은 탐사와 이로 인한 위험부담에 있다.
  - 탐사: 기능을 추가하거나 결함을 수정할 때 어디를 고치는게 최선인지, 어떤 전략을 쓰는게 최적일지를 결정할 때 드는 비용
  - 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며 이로 인한 위험부담 비용 추가
- 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리하면 미래에 추가될 기능에 대한 길을 밝혀 둘 수 있을 뿐만 아니라
의도치 않은 장애가 발생할 위험을 크게 줄일 수 있다.

### 선택사항 열어 두기

- 소프트웨어를 만든 이유는 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요했기 때문인데, 이러한 유연성은 시스템의 형태, 컴포넌트의 배치 방식,
컴포넌트가 상호 연결되는 방식에 상당히 크게 의존한다.
- 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 오랫동안 열어두는 것이다.
  - 열어 둬야 할 선택사항이란 중요치 않은 세부사항이다.
- 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해할 수 있다.
  - 정책
    - 모든 업무 규칙과 업무 절차를 구체화한것
    - 시스템의 진정한 가치가 살아 있는 곳
  - 세부사항
    - 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소이지만 정책이 가진 행위에는 조금도 영향을 미치지 않는 것
      - 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
- 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.
  - 세부사항을 결정하는 일은 미루거나 연기할 수 있다.
    - 예시
    - 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다. 고수준의 정책은 어떤 종류의 데이터베이스를 사용하는지 신경 써서는 안 된다. 
    - 개발 초기에는 웹 서버를 선택할 필요가 없다. 고수준의 정책은 자신이 웹을 통해 전달된다는 사실을 알아서는 안 된다.
    - 개발 초기에는 REST를 적용할 필요가 없다. 고수준의 정책은 외부 세계로의 인터페이스에 대해 독립적이어야 하기 때문이다.
    - 개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없다. 고수준의 정책은 의존성을 해석하는 방식에 대해 신경 써서는 안 된다.
- 세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다.
  - 미룬다면 더 많은 정보를 얻을 수 있고, 이를 토대로 제대로 된 결정을 내릴 수 있다.
  - 다양한 실험을 시도해볼 수 있는 선택지도 열어 둘 수 있다.
    - 동작하고 있는 고수준 정책이 데이터베이스에 독립적이라면 다양한 데이터베이스를 후보로 두고 그 적용 가능성과 성능을 검토해볼 수 있다.

### 장치 독립성

- 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화했고, 해당 함수는 천공카드와 같은 단위 레코드를 처리한다.
  - 동일한 프로그램을 아무런 변경 없이도 카드에서 읽고 쓰거나 테이프에서 읽고 쓸 수 있게 되었다.
    - 개방 폐쇄 원칙

### 결론

- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다.
- 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.

---------------

## 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
  - 시스템의 유스케이스
  - 시스템의 운영
  - 시스템의 개발
  - 시스템의 배포

### 유스케이스

- 시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 뜻
  - 시스템이 장바구니 애플리케이션이라면 아키텍처는 장바구니와 관련된 유스케이스를 지원해야 한다.
- 좋은 아키텍처를 갖춘다면 애플리케이션이 행위 그 자체로 보임
  - 행위는 일급 요소이며 시스템의 최상위 수준에서 알아볼 수 있으므로 개발자가 일일이 찾아 헤매지 않아도 됨

### 운영

- 시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡음
- 운영 작업 형태를 지원해야 함
  - 어떤 시스템에서는 시스템의 처리 요소를 일련의 작은 서비스들로 배열하여 서로 다른 많은 서버에서 병렬로 실행할 수 있게 만들어야 함
  - 다른 시스템에서는 경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 만든다는 뜻일 수도 있음
  - 독립된 주소 공간에서 실행되는 소수의 프로세스만으로도 충분한 시스템도 있음
  - 어떤 시스템은 단일 프로세스에서 실행되는 단순한 모노리틱 프로그램

### 개발

- 콘웨이의 법칙
  - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
- 많은 팀으로 구성되며 관심사가 다양한 조직에서 개발을 해야 한다면 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여
개발하는 동안 팀들이 서로를 방해하지 않도록 해야 한다.
  - 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할
  - 컴포넌트를 독립적인 팀에 할당

### 선택사항 열어놓기

- 좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다.
  - 현실은 이러한 균형을 잡는것이 어렵다
- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

### 계층 결합 분리

- 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고,
동일한 이유로 변경되는 것들은 묶는다.
  - 사용자 인터페이스가 변경되는 이유는 업무 규칙과는 아무런 관련이 없다.
- 업무 규칙은 그 자체가 애플리케이션과 밀접한 관련이 있거나 더 범용적일 수도 있다.
  - 입력 필드 유효성 검사는 애플리케이션 자체와 밀접하게 관련된 업무 규칙
  - 계좌의 이자 계산이나 재고품 집계는 업무 도메인에 더 밀접하게 연관된 업무 규칙

### 유스케이스 결합 분리

- 유스케이스 그 자체는 서로 다른 이유로 변경된다.
  - 주문 입력 시스템에서 주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 다른 이유로 변경된다.
  - 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른 수직으로 좁다란 조각이기도 하다.
- 우리는 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다.
- 유스케이스와 계층을 분리해야한다.
- 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다.

### 결합 분리 모드

- 유스케이스에서 서로 다른 관점이 분리되었다면, 높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되었을 가능성이 높다.
- 유스케이스를 위해 수행하는 작업(결합 분리)은 운영에도 도움이 된다.
  - 운영 측면 이점을 살리기 위해선 결합을 분리할 때 적절한 모드를 선택해야 한다.
    - 분리된 컴포넌트를 서로 다른 서버에서 실행?

### 개발 독립성

- 컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다
  - 업무 규칙이 UI를 알지 못하면 UI에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 그다지 영향을 줄 수 없다.
- 기능 팀, 컴포넌트 팀, 계층 팀 혹은 다른 팀이라도 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해 준다.

### 배포 독립성

- 유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.

### 중복

- 소프트웨어에서 중복은 일반적으로 나쁜 것이다.
- 하지만 중복에도 여러 종류가 있다.
  - 진짜 중복
    - 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 함
  - 거짓된 또는 우발적인 중복
    - 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면(서로 다른 속도와 다른 이유로 변경된다면) 진짜 중복이 아니다.
    - 나중에 보면 매우 다르다는 사실을 알게 됨
- 진짜 중복과 거짓 중복을 가려내고 통합해야 한다.

### 결합 분리 모드 (다시)

- 계층과 유스케이스의 결합을 분리하는 방법은 다양하다
  - 소스 코드 수준에서 분리
    - 소스 코드 모듈 사이의 의존성을 제어할 수 있음
    - 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 할 수 있음
    - 모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신할 때는 간단한 함수 호출을 사용함.
    - 메모리에 하나의 실행 파일만이 로드
    - 모놀리틱 구조라고 함
  - 바이너리 코드 수준(배포)에서 분리
    - jar 파일, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있음.
    - 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있음
    - 어떤 컴포넌트는 동일한 프로세서의 다른 프로세스에 상주하고, 프로세스 간 통신, 소켓, 공유 메모리를 통해 통신함
  - 실행 단위(서비스) 수준에서 분리
    - 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있음
    - 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적
    - 마이크로서비스 구조라고 함
- 프로젝트 초기 단계에는 어떤 모드가 최선인지 알기 어렵다
  - 초기에는 소스 코드 수준이면 되는데 성장하면서 컴포넌트를 분리해야 할 수 도 있음.
  - 더 나아가면 서비스도 분리해야 할 수 있음
- 좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고,
또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 함

### 결론

- 결합 분리 모드를 변경하기는 쉽지 않음
- 시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 함.

-------------

## 경계: 선 긋기

- 소프트웨어 아키텍처는 선을 긋는 기술이며 이러한 선을 경계라고 부른다.
  - 경계는 소프트웨어 요소를 서로 분리하고, 경계 밖에 있는 요소를 알지 못하도록 막는다.
- 아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것
  - 인적 자원의 효율을 떨어뜨리는 요인은?
    - 결합(coupling) 특히 너무 일찍 내려진 결정
      - 시스템의 업무 요구사항, 유스케이스와 아무런 관련이 없는 결정
        - 프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브러리, 의존성 주입에 대한 결정

### 어떻게 선을 그을까? 그리고 언제 그을까?

- 관련이 있는 것과 없는 것 사이에 선을 긋는다.
  - GUI는 업무 규칙과 관련 없기 때문에 둘 사이에는 반드시 선이 있어야 한다.
  - 데이터베이스는 GUI와는 관련이 없으므로 둘 사이에는 반드시 선이 있어야 한다.
  - 데이터베이스는 업무 규칙과 관련이 없으므로 둘 사이에는 반드시 선이 있어야 한다.
- 데이터베이스는 업무 규칙이 간접적으로 사용할 수 있는 도구지 업무 규칙이 구체화된 것이 아니다.
  - 업무 규칙은 스키마, 쿼리 언어, 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안 된다.
  - 업무 규칙이 알아야 할 것은 데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 사실이 전부다.

### 입력과 출력은?

- 입력과 출력은 중요하지 않다
- 사용자 경험은 인터페이스에 의해 좌우되나, 인터페이스 뒤에는 인터페이스를 조작하는 모델(데이터 구조와 함수로 구성된 정교한 집합)이 존재한다.
  - 더 중요한 사실은 모델은 인터페이스를 전혀 필요로 하지 않는다.
- 관련성이 낮은 컴포넌트가 관련성이 높은 컴포넌트에 의존한다.
  - 인터페이스는 업무 규칙을 신경 쓴다
  - 업무 규칙은 인터페이스를 신경쓰지 않는다.

### 플러그인 아키텍처

- 데이터베이스와 GUI에 대해 내린 두 가지 결정을 하나로 합쳐서 보면 컴포넌트 추가와 관련된 일종의 패턴이 만들어진다.
  - 시스템에서 서드 파티 플러그인을 사용할 수 있게 한 바로 그 패턴과 동일하다
- 주변 컴포넌트로부터 핵심적인 업무 규칙이 분리되어 있으면 갈아끼우기 쉬워진다.

### 플러그인에 대한 논의

- 우리가 시스템에서 갖추고자 하는 관계는 상당히 비대칭적 관계다.
  - A는 B에 의존한다.
    - B는 A를 망가트릴 수 있다.
    - A는 B를 건드릴 수 없다.
- 우리는 특정 모듈이 나머지 모듈에 영향받지 않기를 바란다.
  - 웹 페이지의 포맷을 변경하거나 데이터베이스 스키마를 변경하더라도 업무 규칙은 깨지지 않기를 바란다.
- 시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화벽을 생성할 수 있다.
  - GUI가 업무 규칙에 플러그인 형태로 연결되면 GUI에서 발생한 변경은 절대로 업무 규칙에 영향을 미칠 수 없다.
- 경계는 변경의 축이 있는 지점에 그어진다.
  - 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 다른 속도, 다른 이유로 변경된다.
  - 이 역시 순전히 단일 책임 원칙에 해당한다.

### 결론

- 소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다.
- 일부 컴포넌트는 핵심 업무 규칙에 해당하고, 나머지 컴포넌트는 플러그인으로, 핵심 엄무와는 직접적인 관련이 없지만 필수 기능을 포함한다.
- 이는 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것이다.
- 의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치된다.

----------------

## 경계 해부학

- 시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의되는데, 이러한 경계는 다양한 형태로 나타난다.

### 경계 횡단하기

- '런타임에 경계를 횡단한다' 함은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과함
- 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있음
  - 소스 코드 모듈 하나가 변경되면 이에 의존하는 다른 소스 코드 모듈도 변경하거나 재컴파일해서 재배포해야 할 수도 있음
- 경계는 변경의 전파를 막는 방화벽을 구축하고, 관리하는 수단으로써 존재

### 두려운 단일체

- 아키텍처 경계 중에서 가장 단순하며 가장 흔한 형태
  - 물리적으로 엄격하게 구분되지 않는 형태
- 배포 관점에서 보면 단일 실행 파일
- 배포 관점에서 볼 때 단일체는 경계가 드러나지 않음
  - 단일체는 컴포넌트 수준으로 분리되지 않으므로 경계가 드러나지 않음
- 그렇다고 단일체에서 경계가 실제로 존재하지 않거나, 경계 자체가 무의미하다는 뜻은 아님
- 최종적으로는 정적으로 링크된 단일 실행 파일을 만들더라도 그 안에 포함된 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을
독립적으로 수행할 수 있게 하는 일은 대단히 가치 있는 일이다.
- 가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.
  - 이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향(저수준 -> 고수준)으로 향한다.
- 고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있다.

### 배포형 컴포넌트

- 아키텍처의 경계가 물리적으로 드러나는 가장 단순한 형태는 동적 링크 라이브러리(DLL)이다.
  - .NET DLL, jar, ...
- 컴포넌트를 이 형태로 배포하면 따로 컴파일하지 않고 곧바로 사용할 수 있다.
- 동적 링크와 런타임 로딩으로 인해 최초의 함수 호출은 오래 걸릴 수 있지만 대체로 이들 경계를 가로지르는 통신은 빈번할 것이다.

### 스레드

- 단일체와 배포형 컴포넌트 모두 스레드를 활용할 수 있다.

### 로컬 프로세스

- 로컬 프로세스는 주로 명령행이나 그와 유사한 시스템 호출을 통해 생성된다.
- 로컬 프로세스는 소켓이나 메일박스, 메시지 큐와 같이 운영체제에서 제공하는 통신 기능을 이용하여 서로 통신한다.

### 서비스

- 물리적인 형태를 띠는 가장 강력한 경계는 바로 서비스다.
- 서비스는 프로세스로, 일반적으로 명령행 또는 그와 동등한 시스템 호출을 통해 구동된다.
- 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다.
  - 주의를 기울여서, 가능하면 빈번하게 통신하는 일은 피해야한다.

### 결론

- 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
- 서비스 경계를 활용하는 시스템이라면 로컬 프로세스 경계도 일부 포함하고 있을 수 있다.
