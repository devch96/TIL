# 아키텍처

---------

## 아키텍처란?

- 소프트웨어 아키텍트는 최고의 프로그래머이며, 계속 프로그래밍 작업을 맡을 뿐만 아니라 동시에 나머지 팀원들이
생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어 준다.
- 소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태다.
  - 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에
  따라 정해진다.
  - 그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.
- 우리는 시스템이 제대로 동작하기를 바라며, 시스템 아키텍처는 이를 최우선 목표 중 하나로 지원해야 한다.
- 하지만 시스템 아키텍처는 시스템의 동작 여부와는 거의 관련이 없다.
  - 형편없는 아키텍처도 동작은 한다. 하지만 이러한 시스템들은 운영에서 문제가 아닌 배포, 유지보구, 계속되는 개발 과정에서 어려움을 겪는다.
  - 그렇다고 해서 아키텍처가 시스템이 제대로 동작하도록 지원하는 데 아무런 역할을 하지 않는다는 것은 아니다.
    - 하지만 이 역할은 수동적이며 피상적인 것이지 능동적이며 본질적인 것은 아니다.
- 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.
  - 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 쉽게 배포하게 해준다.
- 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

### 개발

- 개발 팀 구조가 다르다면 아키텍처 관련 결정에서도 차이가 난다.
  - 개발자 다섯 명으로 구성될 정도로 작다면, 잘 정의된 컴포넌트나 인터페이스가 없더라도 서로 효율적으로 협력하여
  모놀리틱 시스템을 개발할 수 있다.
    - 소수 개발 팀은 개발 초기에 아키텍처 관련 제약들이 오히려 방해가 된다고 여길 가능성이 높다.
    - 수많은 시스템에서 좋은 아키텍처가 결여된 이유
  - 일곱 명씩 총 다섯 팀이 시스템을 개발하고 있다면 시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면
  개발이 진척되지 않는다.

### 배포

- 배포 비용이 높을수록 시스템의 유용성은 떨어진다.
- 소프트웨어 아키텍처는 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.

### 운영

- 아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 덜 적극적이다.
  - 운영에서 겪는 대다수의 어려움은 단순히 하드웨어를 더 투입해서 해결할 수 있다.
- 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다.

### 유지보수

- 유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 비용이 가장 많이 든다.
  - 새로운 기능은 계속 생기고, 뒤따라서 발생하는 결함은 피할 수 없으며, 결함을 수정하는 데도 엄청난 인적 자원이 소모된다.
- 유지보수의 가장 큰 비용은 탐사와 이로 인한 위험부담에 있다.
  - 탐사: 기능을 추가하거나 결함을 수정할 때 어디를 고치는게 최선인지, 어떤 전략을 쓰는게 최적일지를 결정할 때 드는 비용
  - 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며 이로 인한 위험부담 비용 추가
- 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리하면 미래에 추가될 기능에 대한 길을 밝혀 둘 수 있을 뿐만 아니라
의도치 않은 장애가 발생할 위험을 크게 줄일 수 있다.

### 선택사항 열어 두기

- 소프트웨어를 만든 이유는 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요했기 때문인데, 이러한 유연성은 시스템의 형태, 컴포넌트의 배치 방식,
컴포넌트가 상호 연결되는 방식에 상당히 크게 의존한다.
- 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 오랫동안 열어두는 것이다.
  - 열어 둬야 할 선택사항이란 중요치 않은 세부사항이다.
- 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해할 수 있다.
  - 정책
    - 모든 업무 규칙과 업무 절차를 구체화한것
    - 시스템의 진정한 가치가 살아 있는 곳
  - 세부사항
    - 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소이지만 정책이 가진 행위에는 조금도 영향을 미치지 않는 것
      - 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
- 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.
  - 세부사항을 결정하는 일은 미루거나 연기할 수 있다.
    - 예시
    - 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다. 고수준의 정책은 어떤 종류의 데이터베이스를 사용하는지 신경 써서는 안 된다. 
    - 개발 초기에는 웹 서버를 선택할 필요가 없다. 고수준의 정책은 자신이 웹을 통해 전달된다는 사실을 알아서는 안 된다.
    - 개발 초기에는 REST를 적용할 필요가 없다. 고수준의 정책은 외부 세계로의 인터페이스에 대해 독립적이어야 하기 때문이다.
    - 개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없다. 고수준의 정책은 의존성을 해석하는 방식에 대해 신경 써서는 안 된다.
- 세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다.
  - 미룬다면 더 많은 정보를 얻을 수 있고, 이를 토대로 제대로 된 결정을 내릴 수 있다.
  - 다양한 실험을 시도해볼 수 있는 선택지도 열어 둘 수 있다.
    - 동작하고 있는 고수준 정책이 데이터베이스에 독립적이라면 다양한 데이터베이스를 후보로 두고 그 적용 가능성과 성능을 검토해볼 수 있다.

### 장치 독립성

- 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화했고, 해당 함수는 천공카드와 같은 단위 레코드를 처리한다.
  - 동일한 프로그램을 아무런 변경 없이도 카드에서 읽고 쓰거나 테이프에서 읽고 쓸 수 있게 되었다.
    - 개방 폐쇄 원칙

### 결론

- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다.
- 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.

---------------

## 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
  - 시스템의 유스케이스
  - 시스템의 운영
  - 시스템의 개발
  - 시스템의 배포

### 유스케이스

- 시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 뜻
  - 시스템이 장바구니 애플리케이션이라면 아키텍처는 장바구니와 관련된 유스케이스를 지원해야 한다.
- 좋은 아키텍처를 갖춘다면 애플리케이션이 행위 그 자체로 보임
  - 행위는 일급 요소이며 시스템의 최상위 수준에서 알아볼 수 있으므로 개발자가 일일이 찾아 헤매지 않아도 됨

### 운영

- 시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡음
- 운영 작업 형태를 지원해야 함
  - 어떤 시스템에서는 시스템의 처리 요소를 일련의 작은 서비스들로 배열하여 서로 다른 많은 서버에서 병렬로 실행할 수 있게 만들어야 함
  - 다른 시스템에서는 경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 만든다는 뜻일 수도 있음
  - 독립된 주소 공간에서 실행되는 소수의 프로세스만으로도 충분한 시스템도 있음
  - 어떤 시스템은 단일 프로세스에서 실행되는 단순한 모노리틱 프로그램

### 개발

- 콘웨이의 법칙
  - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
- 많은 팀으로 구성되며 관심사가 다양한 조직에서 개발을 해야 한다면 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여
개발하는 동안 팀들이 서로를 방해하지 않도록 해야 한다.
  - 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할
  - 컴포넌트를 독립적인 팀에 할당

### 선택사항 열어놓기

- 좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다.
  - 현실은 이러한 균형을 잡는것이 어렵다
- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

### 계층 결합 분리

- 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고,
동일한 이유로 변경되는 것들은 묶는다.
  - 사용자 인터페이스가 변경되는 이유는 업무 규칙과는 아무런 관련이 없다.
- 업무 규칙은 그 자체가 애플리케이션과 밀접한 관련이 있거나 더 범용적일 수도 있다.
  - 입력 필드 유효성 검사는 애플리케이션 자체와 밀접하게 관련된 업무 규칙
  - 계좌의 이자 계산이나 재고품 집계는 업무 도메인에 더 밀접하게 연관된 업무 규칙

### 유스케이스 결합 분리

- 유스케이스 그 자체는 서로 다른 이유로 변경된다.
  - 주문 입력 시스템에서 주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 다른 이유로 변경된다.
  - 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른 수직으로 좁다란 조각이기도 하다.
- 우리는 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다.
- 유스케이스와 계층을 분리해야한다.
- 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다.

### 결합 분리 모드

- 유스케이스에서 서로 다른 관점이 분리되었다면, 높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되었을 가능성이 높다.
- 유스케이스를 위해 수행하는 작업(결합 분리)은 운영에도 도움이 된다.
  - 운영 측면 이점을 살리기 위해선 결합을 분리할 때 적절한 모드를 선택해야 한다.
    - 분리된 컴포넌트를 서로 다른 서버에서 실행?

### 개발 독립성

- 컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다
  - 업무 규칙이 UI를 알지 못하면 UI에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 그다지 영향을 줄 수 없다.
- 기능 팀, 컴포넌트 팀, 계층 팀 혹은 다른 팀이라도 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해 준다.

### 배포 독립성

- 유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.

### 중복

- 소프트웨어에서 중복은 일반적으로 나쁜 것이다.
- 하지만 중복에도 여러 종류가 있다.
  - 진짜 중복
    - 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 함
  - 거짓된 또는 우발적인 중복
    - 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면(서로 다른 속도와 다른 이유로 변경된다면) 진짜 중복이 아니다.
    - 나중에 보면 매우 다르다는 사실을 알게 됨
- 진짜 중복과 거짓 중복을 가려내고 통합해야 한다.

### 결합 분리 모드 (다시)

- 계층과 유스케이스의 결합을 분리하는 방법은 다양하다
  - 소스 코드 수준에서 분리
    - 소스 코드 모듈 사이의 의존성을 제어할 수 있음
    - 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 할 수 있음
    - 모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신할 때는 간단한 함수 호출을 사용함.
    - 메모리에 하나의 실행 파일만이 로드
    - 모놀리틱 구조라고 함
  - 바이너리 코드 수준(배포)에서 분리
    - jar 파일, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있음.
    - 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있음
    - 어떤 컴포넌트는 동일한 프로세서의 다른 프로세스에 상주하고, 프로세스 간 통신, 소켓, 공유 메모리를 통해 통신함
  - 실행 단위(서비스) 수준에서 분리
    - 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있음
    - 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적
    - 마이크로서비스 구조라고 함
- 프로젝트 초기 단계에는 어떤 모드가 최선인지 알기 어렵다
  - 초기에는 소스 코드 수준이면 되는데 성장하면서 컴포넌트를 분리해야 할 수 도 있음.
  - 더 나아가면 서비스도 분리해야 할 수 있음
- 좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고,
또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 함

### 결론

- 결합 분리 모드를 변경하기는 쉽지 않음
- 시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 함.

-------------

## 경계: 선 긋기

- 소프트웨어 아키텍처는 선을 긋는 기술이며 이러한 선을 경계라고 부른다.
  - 경계는 소프트웨어 요소를 서로 분리하고, 경계 밖에 있는 요소를 알지 못하도록 막는다.
- 아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것
  - 인적 자원의 효율을 떨어뜨리는 요인은?
    - 결합(coupling) 특히 너무 일찍 내려진 결정
      - 시스템의 업무 요구사항, 유스케이스와 아무런 관련이 없는 결정
        - 프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브러리, 의존성 주입에 대한 결정

### 어떻게 선을 그을까? 그리고 언제 그을까?

- 관련이 있는 것과 없는 것 사이에 선을 긋는다.
  - GUI는 업무 규칙과 관련 없기 때문에 둘 사이에는 반드시 선이 있어야 한다.
  - 데이터베이스는 GUI와는 관련이 없으므로 둘 사이에는 반드시 선이 있어야 한다.
  - 데이터베이스는 업무 규칙과 관련이 없으므로 둘 사이에는 반드시 선이 있어야 한다.
- 데이터베이스는 업무 규칙이 간접적으로 사용할 수 있는 도구지 업무 규칙이 구체화된 것이 아니다.
  - 업무 규칙은 스키마, 쿼리 언어, 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안 된다.
  - 업무 규칙이 알아야 할 것은 데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 사실이 전부다.

### 입력과 출력은?

- 입력과 출력은 중요하지 않다
- 사용자 경험은 인터페이스에 의해 좌우되나, 인터페이스 뒤에는 인터페이스를 조작하는 모델(데이터 구조와 함수로 구성된 정교한 집합)이 존재한다.
  - 더 중요한 사실은 모델은 인터페이스를 전혀 필요로 하지 않는다.
- 관련성이 낮은 컴포넌트가 관련성이 높은 컴포넌트에 의존한다.
  - 인터페이스는 업무 규칙을 신경 쓴다
  - 업무 규칙은 인터페이스를 신경쓰지 않는다.

### 플러그인 아키텍처

- 데이터베이스와 GUI에 대해 내린 두 가지 결정을 하나로 합쳐서 보면 컴포넌트 추가와 관련된 일종의 패턴이 만들어진다.
  - 시스템에서 서드 파티 플러그인을 사용할 수 있게 한 바로 그 패턴과 동일하다
- 주변 컴포넌트로부터 핵심적인 업무 규칙이 분리되어 있으면 갈아끼우기 쉬워진다.

### 플러그인에 대한 논의

- 우리가 시스템에서 갖추고자 하는 관계는 상당히 비대칭적 관계다.
  - A는 B에 의존한다.
    - B는 A를 망가트릴 수 있다.
    - A는 B를 건드릴 수 없다.
- 우리는 특정 모듈이 나머지 모듈에 영향받지 않기를 바란다.
  - 웹 페이지의 포맷을 변경하거나 데이터베이스 스키마를 변경하더라도 업무 규칙은 깨지지 않기를 바란다.
- 시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화벽을 생성할 수 있다.
  - GUI가 업무 규칙에 플러그인 형태로 연결되면 GUI에서 발생한 변경은 절대로 업무 규칙에 영향을 미칠 수 없다.
- 경계는 변경의 축이 있는 지점에 그어진다.
  - 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 다른 속도, 다른 이유로 변경된다.
  - 이 역시 순전히 단일 책임 원칙에 해당한다.

### 결론

- 소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다.
- 일부 컴포넌트는 핵심 업무 규칙에 해당하고, 나머지 컴포넌트는 플러그인으로, 핵심 엄무와는 직접적인 관련이 없지만 필수 기능을 포함한다.
- 이는 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것이다.
- 의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치된다.

----------------

## 경계 해부학

- 시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의되는데, 이러한 경계는 다양한 형태로 나타난다.

### 경계 횡단하기

- '런타임에 경계를 횡단한다' 함은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과함
- 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있음
  - 소스 코드 모듈 하나가 변경되면 이에 의존하는 다른 소스 코드 모듈도 변경하거나 재컴파일해서 재배포해야 할 수도 있음
- 경계는 변경의 전파를 막는 방화벽을 구축하고, 관리하는 수단으로써 존재

### 두려운 단일체

- 아키텍처 경계 중에서 가장 단순하며 가장 흔한 형태
  - 물리적으로 엄격하게 구분되지 않는 형태
- 배포 관점에서 보면 단일 실행 파일
- 배포 관점에서 볼 때 단일체는 경계가 드러나지 않음
  - 단일체는 컴포넌트 수준으로 분리되지 않으므로 경계가 드러나지 않음
- 그렇다고 단일체에서 경계가 실제로 존재하지 않거나, 경계 자체가 무의미하다는 뜻은 아님
- 최종적으로는 정적으로 링크된 단일 실행 파일을 만들더라도 그 안에 포함된 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을
독립적으로 수행할 수 있게 하는 일은 대단히 가치 있는 일이다.
- 가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.
  - 이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향(저수준 -> 고수준)으로 향한다.
- 고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있다.

### 배포형 컴포넌트

- 아키텍처의 경계가 물리적으로 드러나는 가장 단순한 형태는 동적 링크 라이브러리(DLL)이다.
  - .NET DLL, jar, ...
- 컴포넌트를 이 형태로 배포하면 따로 컴파일하지 않고 곧바로 사용할 수 있다.
- 동적 링크와 런타임 로딩으로 인해 최초의 함수 호출은 오래 걸릴 수 있지만 대체로 이들 경계를 가로지르는 통신은 빈번할 것이다.

### 스레드

- 단일체와 배포형 컴포넌트 모두 스레드를 활용할 수 있다.

### 로컬 프로세스

- 로컬 프로세스는 주로 명령행이나 그와 유사한 시스템 호출을 통해 생성된다.
- 로컬 프로세스는 소켓이나 메일박스, 메시지 큐와 같이 운영체제에서 제공하는 통신 기능을 이용하여 서로 통신한다.

### 서비스

- 물리적인 형태를 띠는 가장 강력한 경계는 바로 서비스다.
- 서비스는 프로세스로, 일반적으로 명령행 또는 그와 동등한 시스템 호출을 통해 구동된다.
- 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다.
  - 주의를 기울여서, 가능하면 빈번하게 통신하는 일은 피해야한다.

### 결론

- 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
- 서비스 경계를 활용하는 시스템이라면 로컬 프로세스 경계도 일부 포함하고 있을 수 있다.

--------------

## 정책과 수준

- 소프트웨어 시스템이란 정책을 기술한 것이다.
  - 컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서다.
- 대다수의 주요 시스템에서 하나의 정책은 이 정책을 서술하는 여러 개의 조그만 정책들로 쪼갤 수 있다.
  - 집계와 관련된 업무 규칙
    - 보고서는 무슨 포맷?
    - 입력 데이터 검증은 어떻게?
    - ...
- 소프트웨어 아키텍처를 개발하는 기술에는 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함됨
- 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며 동일한 컴포넌트에 속해야 함
  - 반대일 경우 다른 수준에 위치, 다른 컴포넌트로 분리해야 함
- 흔히 아키택처 개발은 재편성된 컴포넌트들을 비순환 방향 그래프로 구성하는 기술을 포함함
  - 그래프에서 정점은 동일한 수준의 정책을 포함하는 컴포넌트
  - 방향이 있는 간선은 컴포넌트 사이의 의존성
    - 의존성이란 소스 코드, 컴파일 타임의 의존성
      - import 구문 등
- 좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 함
  - 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 함

### 수준

- 수준(level)은 '입력과 출력까지의 거리'
  - 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아짐
- 데이터 흐름과 소스 코드 의존성은 항상 같은 방향을 가리키지는 않음
- 소스 코드의 의존성은 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안 된다.
- 정책을 컴포넌트로 묶는 기준은 정책이 변경되는 방식에 달려있다.
  - 단일 책임 원칙과 공통 폐쇄 원칙에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶인다.
- 모든 소스 코드 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도 줄일 수 있다.
  - 시스템의 최저 수준에서 중요하지 않지만 긴급한 변경이 발생하더라도, 보다 높은 위치의 중요한 수준에 미치는 영향은 거의 없게 된다.
  - 저수준 컴포넌트가 고수준 컴포넌트에 플러그인되어야 한다는 관점으로도 볼 수 있다.

### 결론

- 정책에 대한 논의는 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을
모두 포함한다.

--------------------

## 업무 규칙

- 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차다.
- 컴퓨터상으로 구현했는지와 상관없이 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 한다.
  - 대출에 N% 이자를 부과한다는 사실은 은행이 돈을 버는 업무 규칙
    - 컴퓨터 프로그램으로 계산하든, 직원이 직접 계산하든 관계 없음
- 이러한 규칙을 핵심 업무 규칙이라 부른다
  - 규칙은 사업 자체에 핵심적이며, 규칙을 자동화하는 시스템이 없더라도 업무 규칙은 존재하기 때문
- 핵심 업무 규칙은 보통 데이터를 요구한다
  - 대출에는 대출 잔액, 이자율, 지급 일정 등의 데이터 필요
  - 이러한 데이터를 핵심 업무 데이터라 부른다
- 핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기 때문에 객체로 만들 좋은 후보가 되고, 우리는 이러한 유형의 객체를 엔티티라고 부른다.

### 엔티티

- 엔티티는 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.
- 엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.
  - 대출을 뜻하는 Loan 엔티티
    - makePayment()
    - applyInterest()
    - chargeLateFee()
- 엔티티는 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크에 대한 고려사항들로 인해 오염되서는 절대 안 된다.
- 엔티티는 순전히 업무에 대한 것이며, 이외의 것은 없다.

### 유스케이스

- 모든 업무 규칙이 엔티티처럼 순수한 것은 아니다.
  - 자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙도 존재
- 이것이 바로 유스케이스
  - 유스케이스는 자동화된 시스템이 사용되는 방법을 설명
  - 엔티티 내의 핵심 업무 규칙과는 반대로 유스케이스는 애플리케이션에 특화된 업무 규칙을 설명
- 유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지를 명시하는 규칙을 담음
  - 엔티티가 어떻게 사용될지 유스케이스가 제어
- 유스케이스는 사용자 인터페이스를 기술하지 않음
- 유스케이스는 엔티티에 의존하지만, 엔티티는 유스케이스에 의존하지 않음

### 요청 및 응답 모델

- 유스케이스는 단순한 요청 데이터 구조를 입력으로 받아들이고, 단순한 응답 데이터 구조를 출력으로 반환함
  - 데이터 구조는 HttpRequest나 HttpResponse와 같은 표준 프레임워크 인터페이스로부터 파생되지 않음
  - 웹?REST? 모름
- 요청 및 응답 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도 해당 모델이 수반하는 의존성에 간접적으로 결합되어 버림
- 엔티티 객체를 가리키는 참조를 요청 및 응답 데이터 구조에 포함하려는 유혹도 있음
  - 엔티티와 요청/응답 모델은 상당히 많은 데이터를 공유하므로 적합해 보임
  - 하지만 이 유횩을 떨쳐내야 함
  - 두 객체의 목적은 완전히 다름
- 엔티티와 요청 및 응답 데이터 구조는 시간이 지나면 완전히 다른 이유로 변경될 것이기에 두 객체를 함께 묶는 행위는
공통 폐쇄 원칙과 단일 책임 원칙을 위배한다.

### 결론

- 업무 규칙은 소프트웨어 시스템이 존재하는 이유
- 업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아 있어야 함
- 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치해야 하며, 덜 중요한 코드는 심장부에 플러그인 되어야 함
- 업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 함

-----------

## 소리치는 아키텍처

- 애플리케이션 아키텍처는 뭐라고 소리칠까?
  - 헬스 케어 시스템? 스프링?

### 아키텍처의 테마

- 소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조
  - 주택이나 도서관의 계획서가 해당 건축물의 유스케이스에 대해 소리치는 것처럼
  - 소프트웨어 애플리케이션의 아키텍처도 애플리케이션의 유스케이스에 대해 소리쳐야 함
- 아키텍처를 프레임워크 중심으로 만들어버리면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다.

### 아키텍처의 목적

- 좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이
기술할 수 있음
- 프레임워크는 열어 둬야 할 선택사항

### 하지만 웹은?

- 웹은 전달 매커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 다뤄야 함
- 애플리케이션이 웹을 통해 전달된다는 사실은 세부사항이며, 시스템 구조를 지배해서는 안됨

### 프레임워크는 도구일 뿐, 삶의 방식은 아니다

- 프레임워크는 매우 강력하고 상당히 유용하다.
- 하지만 프레임워크가 아키텍처의 중심을 차지하는 일을 막아야 한다.
- 아키텍처는 유스케이스에 중점을 둔 채 그대로 보존해야 한다.

### 테스트하기 쉬운 아키텍처

- 아키텍처가 유스케이스를 최우선으로 하고, 프레임워크와는 적당한 거리를 둔다면 프레임워크 없이도 유스케이스 전부에 대해
단위 테스트를 할 수 있어야 한다.
  - 테스트를 돌리는 데 웹 서버가 필요해서는 안됨
  - 데이터베이스가 반드시 연결되 있어야만 테스트를 돌릴 수 있어서도 안됨

### 결론

- 아키텍처는 시스템을 이야기해야지 시스템에 적용한 프레임워크에 대해 이야기해서는 안됨

-------------------

## 클린 아키텍처

- 여러 아이디어가 있다
  - 육각형 아키텍처(Hexagonal Architecture)
    - 포트와 어댑터라고도 알려져있다.
  - DCI(Data, Context and Interaction)
  - BCE(Boundary-Control-Entity)
- 세부적인 면은 차이가 있더라도 내용은 상당히 비슷하다.
  - 이들의 목표는 관심사의 분리(separation of concerns)
  - 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성
  - 각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.
- 이들 아키텍처는 모두 시스템이 다음과 같은 특징을 지니게 함
  - 프레임워크 독립성
    - 프레임워크의 존재 여부에 의존하지 않음
    - 프레임워크가 지닌 제약사항 안으로 시스템을 욱여 넣도록 강제하지 않음
  - 테스트 용이성
    - 업무 규칙은 UI, 데이터베이스, 웹 서버, 또는 여타 외부 요소가 없이도 테스트 가능함
  - UI 독립성
    - 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있음
      - 업무 규칙을 변경하지 않은 채 웹 UI를 콘솔 UI로 대체
  - 데이터베이스 독립성
    - 업무 규칙은 데이터베이스에 결합되지 않음
  - 모든 외부 에이전시에 대한 독립성
    - 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못함

### 의존성 규칙

- 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 함
  - 외부와 가까이 있을 수록 저수준(컨트롤러)
- 내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못함
  - 내부의 원에 속한 코드는 외부의 원에 선언된 어떤 것에 대해서도 그 이름을 언급해서는 절대 안 됨
    - 함수, 클래스, 변수, 소프트웨어 엔티티로 명명되는 모든 것을 포함
- 외부의 원에 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안 됨
  - 데이터 형식이 외부의 원에 있는 프레임워크가 생성한 것이라면 더더욱 안 됨
- 외부 원에 위치한 어떤 것도 내부의 원에 영향을 주지 않길 바람

### 엔티티

- 엔티티는 전사적인 핵심 업무 규칙을 캡슐화함
- 기업의 다양한 애플리케이션에서 엔티티를 재사용할 수만 있다면 형태는 그다지 중요치 않음
  - 메서드를 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수 있음
- 운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 됨

### 유스케이스

- 유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함함
- 유스케이스 계층의 소프트웨어는 시스템의 모든 유스케이스를 캡슐화하고 구현함
- 이 계층에서 발생한 변경이 엔티티에 영향을 주어서는 안 됨
- 또한 데이터베이스, UI 또는 여타 공통 프레임워크와 같은 외부 요소에서 발생한 변경이 이 계층에 영향을 줘서도 안됨
- 운영 관점에서 애플리케이션이 변경된다면 유스케이스가 영향을 받으며 코드 일부는 분명 영향을 받음

### 인터페이스 어댑터

- 일련의 어댑터들로 구성됨
- 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환함
- 이 계층은 GUI의 MVC 아키텍처를 모두 포괄함
  - 프레젠터, 뷰, 컨트롤러는 모두 여기에 속함
  - 모델은 그저 데이터 구조 정도
  - 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아 감
- 이 계층은 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임이의 프레임워크(데이터베이스)가
이용하기에 가장 편리한 형식으로 변환한다.
  - 이 계층에 속한 어떤 코드도 데이터베이스에 대해 조금도 알아서는 안 됨
- 이 계층에는 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요함

### 프레임워크와 드라이버

- 가장 바깥쪽 계층은 일반적으로 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성됨
  - 안쪽 원과 통신하기 위한 접합 코드 외에는 특별히 더 작성해야 할 코드가 그다지 많지 않음

### 원은 네 개여야만 하나?

- 네 개보다 더 많은 원이 필요할 수도 있으나 의존성 규칙은 적용됨
- 소스 코드 의존성은 항상 안쪽을 향함
- 가장 바깥쪽 우너은 저수준의 구체적인 세부사항으로 구성, 안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을
캡슐화함

### 경계 횡단하기

- 제어흐름은 컨트롤러에서 시작해서 유스케이스를 지난 후 프레젠터에서 실행되면서 마무리 됨
- 의존성은 유스케이스를 향해 안쪽을 가리킴
- 이처럼 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우 의존성 역전 원칙을 사용하여 해결함

### 경계를 횡단하는 데이터는 어떤 모습인가

- 경계를 가로지르는 데이터는 흔히 간단한 데이터 구조
  - 기본적인 구조체 혹은 간단한 데이터 전송 객체(Data Transfer Object)등
  - 함수를 호출할 때 간단한 인자를 사용해 데이터로 전달할 수 있음
- 엔티티 객체나 데이터베이스의 행을 전달하면 안됨

### 결론

- 위의 간단한 규칙들을 준수하는 일은 어렵지 않으며, 향후에 겪을 수많은 고통거리를 덜어줄 것
- 소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며 이에 따른 이점을 누릴 수 있음.

-------------

## 프레젠터와 험블 객체

- 프레젠터는 험블 객체 패턴을 따른 형태로 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.

### 험블 객체 패턴

- 험블 객체 패턴은 디자인 패턴으로 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안됨
- 아이디어
  - 행위들을 두 개의 모듈 또는 클래스로 나눔
    - 이들 모듈 중 하나가 험블
  - 가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮김
  - 나머지 모듈에는 험블 객체에 속하지 않은 테스트하기 쉬운 행위를 모두 옮김
- 예시
  - GUI 경우 단위 테스트가 어려움
    - 화면을 보면서 각 요소가 필요한 위치에 적절히 표시되었는지 검사하는 테스트는 작성하기 어려움
    - GUI에서 수행하는 행위의 대다수는 쉽게 테스트 가능함
  - 험블 객체 패턴을 사용하면 두 분류의 행위를 분리하여 프레젠터와 뷰라는 서로 다른 클래스로 만들 수 있음.

### 프레젠터와 뷰

- 뷰는 험블 객체이고 테스트하기 어렵다.
  - 이 객체에 포함된 코드는 가능한 한 간단하게 유지한다.
  - 뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않음
- 프레젠터는 테스트하기 쉬운 객체
  - 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것
- 예시
  - 애플리케이션에서 어떤 필드에 날짜를 표시하고자 함
    - 애플리케이션은 프레젠터에 Date 객체를 전달
    - 프레젠터는 해당 데이터를 적절한 포맷의 문자열로 만들고 뷰 모델이라고 부르는 간단한 데이터 구조에 담음
    - 뷰는 뷰 모델에서 이 데이터를 찾음
  - 화면에 금액을 표시하고자 함
    - 애플리케이션은 프레젠터에 Currency 객체를 전달
    - 프레젠터는 해당 객체를 소수점과 통화 표시가 된 포맷으로 변환하여 문자열 생성 후 뷰 모델에 저장
    - 뷰는 뷰 모델에서 이 데이터를 찾음
- 뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 맡은 역할은 전혀 없음
  - 보잘것없다(Humble)

### 테스트와 아키텍처

- 행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의된다.
  - 프레젠터와 뷰 사이의 경계는 이러한 경계 중 하나이며 이 외에도 수많은 경계가 존재

### 데이터베이스 게이트웨이

- 유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이가 위치함
- 다형적 인터페이스로 애플리케이션이 데이터베이스에 수행하는 CRUD 작업과 관련된 모든 메서드를 포함함
- 유스케이스 계층은 SQL을 허용하지 않기 때문에 유스케이스 계층은 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출함
- 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기 때문에 험블 객체가 아님
  - 테스트하기 쉬움
  - 게이트웨이는 스텁이나 테스트 더블로 적당히 교체할 수 있기 때문

### 데이터 매퍼

- 하이버네이트 같은 ORM은 어느 계층?
- 데이터베이스 계층
- ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 또 다른 험블 객체 경계를 형성

### 결론

- 각 아키테처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있다.
- 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.

------------

## 부분적 경계

- 아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다
  - 쌍방향의 다형적 Boundary 인터페이스
  - Input, Output을 위한 데이터 구조
  - 두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리하는 데 필요한 의존성 관리
- 경계를 만드는 비용이 너무 크다고 판단하면서도 나중에 필요하니 공간을 확보하길 원하기도 함
  - 애자일 커뮤니티에선 별로 안좋아함
    - YAGNI(You Aren't Going to Need It) 원칙을 위배하기 때문
      - 필요한 작업만 해라
- 어쩌면 필요할지도라는 생각이 들면 부분적 경계를 구현해볼 수 있다.

### 마지막 단계를 건너뛰기

- 부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 모든 작업은 수행하지만
단일 컴포넌트에 그대로 모아만 두는 것이다.
  - 쌍방향 인터페이스
  - 입력, 출력 데이터 구조
- 부분적 경계를 만들려면 완벽한 경계를 만들 때만큼의 코드량과 사전 설계가 필요하지만 다수의 컴포넌트를 관리하는 작업은 하지 않아도 됨

### 일차원 경계

- 완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다.
- Service(Interface)
  - ServiceImple(Class)

### 파사드

- 더 단순한 경계는 파사드 패턴으로 의존성 역전까지도 희생한다.
- 경계는 Facade 클래스로만 간단히 정의된다.
- Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다.
- 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다.
  - 하지만 Client가 모든 서비스 클래스에 대해 추이 종속성을 가지게 됨
    - 정적 언어라면 서비스 클래스 중 하나에서 소스 코드가 변경되면 Client도 무조건 재컴파일해야 함

### 결론

- 아키텍처 경계를 부분적으로 구현하는 간단한 세 가지 방법
  - 마지막 단계 건너뛰기
  - 일차원 경계
  - 파사드

---------------

## 계층과 경계

- 시스템이 세 가지 컴포넌트(UI, 업무 규칙, 데이터베이스)로만 구성된다고 생각하기 쉽다.
  - 몇몇 단순한 시스템에서는 이 정도로 충분하나, 대다수의 시스템에서 컴포넌트의 개수는 이보다 훨씬 많다.

### 움퍼스 사냥 게임

- 텍스트를 기반으로 하는 이 게임은 GO EAST와 SHOOT WEST와 같은 매우 단순한 명령어를 사용한다.
  - 사용자는 명령어를 입력하며, 컴퓨터는 플레이어가 보고, 냄새 맡고, 듣고, 경험할 것들로 응답한다.
- 텍스트 기반 UI는 그대로 유지하되, 게임 규칙과 UI를 분리해서 여러 시장에서 다양한 언어로 발매할 수 있게 만든다 가정
- 의존성 규칙을 준수할 수 있도록 의존성이 적절한 방향을 가리키게 만들어야 함

### 클린 아키텍처?

- UI에서 언어가 유일한 변경의 축은 아니다.
- 변경의 축에 의해 정의되는 아키텍처 경계가 잠재되어 있을 수도 있다.

### 흐름 횡단하기

- 시스템이 복잡해질수록 컴포넌트 구조는 더 많은 흐름으로 분리된다.

### 흐름 분리하기

- 모든 흐름이 결국에는 상단의 단일 컴포넌트에서 서로 만난다고 생각할 수도 있으나 현실은 훨씬 복잡하다.

### 결론

- 아키텍처 경계가 어디에나 존재한다.
- 아키텍트로서 우리는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야 한다.
- 이러한 경계를 구현하려면 비용이 많이드나 경계가 무시되었다면 나중에 다시 추가하는 비용은 더 크다는 사실도 알아야 한다.
- 프로젝트 초반에는 구현할 경계가 무엇인지와 무시할 경계가 무엇인지 쉽게 결정할 수 없으니 지켜봐야 한다.
  - 시스템이 발전함에 따라 주의를 기울여야 한다.

-------------

## 메인(Main) 컴포넌트

- 모든 시스템에는 최소한 하나의 컴포넌트가 존재하고, 이 컴포넌트가 나머지 컴포넌트를 생성하고, 조정하며 관리한다.
  - 메인이라고 부른다

### 궁극적인 세부사항

- 메인 컴포넌트는 궁극적인 세부사항으로 가장 낮은 수준의 정책이다.
  - 메인 시스템의 초기 진입점이다.
  - 운영체제를 제외하면 어떤 것도 메인에 의존하지 않는다.
- 의존성 주입 프레임워크를 이용해 의존성을 주입하는 일은 바로 이 메인 컴포넌트에서 이뤄져야 한다.
- 메인은 클린 아키텍처에서 가장 바깥 원에 위치하는, 지저분한 저수준 모듈이다.
- 메인은 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에게 넘긴다.

### 결론

- 메인을 애플리케이션의 플러그인이라고 생각하자
- 메인을 플러그인 컴포넌트로 여기고, 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.

---------------

## '크고 작은 모든' 서비스들

- 서비스 지향 아키텍처와 마이크로서비스 아키텍처가 인기를 끌고 있는 이유
  - 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보임
  - 서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보임

### 서비스 아키텍처?

- 서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하지는 않는다.
- 시스템의 아키텍처는 의존성 규칙을 준수(고수준의 정책을 저수준의 세부사항으로부터 분리)하는 경계에 의해 정의된다.
  - 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼(네트워크, 등등) 함수 호출에 불과하며 아키텍처 관점에서는 중요하진 않다.
- 아키텍처적으로 중요한 서비스도 있지만 단순히 함수 호출에 지나지 않은 서비스도 존재한다.

### 서비스의 이점?

#### 결합 분리의 오류

- 시스템을 서비스들로 분리함으로써 얻게 되리라 예상되는 큰 이점 하나는 서비스 사이의 결합이 확실히 분리된다는 점
  - 각 서비스는 서로 다른 프로세스에서 실행
  - 서비스는 다른 서비스의 변수에 직접 접근 불가
  - 모든 서비스의 인터페이스는 반드시 잘 정의되어 있어야 함
- 서비스는 개별 변수 수준에서는 각각 결합이 분리되나, 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재
  - 서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가한다면 이 필드를 사용해 동작하는 모든 서비스는 반드시 변경되어야 함
  - 서비스들은 이 데이터 레코드에 강하게 결합되고, 서비스들 사이는 간접적으로 결합되어 버림
- 인터페이스가 잘 정의되어 있어야 한다는 이점은 명백히 사실이나, 서비스 인터페이스가 함수 인터페이스보다 더 엄밀하고, 더 엄격하고, 더 잘 정의되는 것은
아님

#### 개발 및 배포 독립성의 오류

- 서비스를 사용함에 따라서 예측되는 또 다른 이점은 전담팀이 서비스를 소유하고 운영한다는 점
  - 데브옵스 전략의 일환으로 전담팀에서 서비스를 작성하고, 유지보수하며, 운영하는 책임을 가짐
  - 이러한 개발 및 배포 독립성은 확장 가능한(scalable)것으로 간주됨
- 대규모 엔터프라이즈 시스템을 독립적으로 개발, 배포하고 수십, 수백, 수천 개의 서비스들을 이용하여 만들 수 있다고 믿음
  - 하지만 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있음
  - 확장 가능한 시스템을 구축하는 유일한 선택지가 아님
- 결합 분리의 오류에 따르면 서비스라고 해서 항상 독립적으로 개발하고, 배포하며, 운영할 수 있는 것은 아님

### 야옹이 문제

- 택시 통합 시스템을 각각의 서비스로 나눠서 사용
- 새로운 배달 업무(야옹이)가 추가될 경우 모든 서비스가 바뀌어야 함
  - 이 서비스들은 모두 결합되어 있어서 독립적으로 개발하고, 배포하거나, 유지될 수 없음
- 횡단 관심사가 지닌 문제
  - 모든 소프트웨어 시스템은 서비스 지향이든 아니든 이 문제에 직면함

### 객체가 구출하다

- 컴포넌트 기반 아키텍처에서는 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리함
  - 탬플릿 메서드 패턴, 전략 패턴

### 컴포넌트 기반 서비스

- 서비스에도 이렇게 할 수 있을까?
  - 예
- 서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다.

### 횡단 관심사

- 아키텍처의 경계가 서비스에 있지 않다
  - 서비스를 관통하며 서비스를 컴포넌트 단위로 분할한다

### 결론

- 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만 그 자체로는 아키텍처적으로 그리 중요한 요소가 아니다.
- 클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을 때도 있다.

----------------

## 테스트 경계

- 테스트는 시스템의 일부이며, 아키텍처에도 관여한다.
  - 어떤 면에선 정말 평범하게, 어떤 면에선 상당히 독특하게 관여한다.

### 시스템 컴포넌트인 테스트

- 아키텍처 관점에서는 모든 테스트가 동일하다
  - 단위 테스트, 통합 테스트 등등
- 테스트는 태생적으로 의존성 규칙을 가짐
  - 테스트는 세부적이며 구체적인 것으로 의존성이 항상 테스트 대상이 되는 코드를 향함
- 테스트는 시스템 컴포넌트 중에서 가장 고립되어 있음
  - 시스템 운영에 필요치 않고, 어떤 사용자도 테스트에 의존하지 않음
  - 테스트의 역할이 운영이 아니라 개발 지원에 있기 때문
  - 그렇다고 시스템 컴포넌트가 아닌것은 아님

### 테스트를 고려한 설계

- 테스트가 지닌 극단적인 고립성이 테스트는 대체로 배포하지 않는다는 사실과 어우러지며 개발자는 종종 테스트가 시스템의
설계 범위 밖에 있다고 여기는데 이 관점은 아주 나쁨
  - 테스트가 시스템의 설계와 잘 통합되지 않으면 테스트는 깨지기 쉬워지고 시스템은 변경하기가 어려워지기 때문
- 시스템에 강하게 결합된 테스트라면 시스템이 변경될 때 함께 변경되어야만 함
  - 깨지기 쉬운 테스트 문제
- GUI 사용하여 업무 규칙을 검증하는 테스트 스위트
  - GUI 변경시 수천개의 테스트가 깨짐
  - 이 문제를 해결하려면 테스트를 고려해서 설계해야 함
    - 소프트웨어 설계의 첫 번째 규칙
    - 변동성이 있는 것에 의존하지 말라
  - 시스템과 테스트를 설계할 때 GUI를 사용하지 않고 업무 규칙을 테스트할 수 있게 해야 함

### 테스트 API

- 테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API 제작
  - 보안 제약사항을 무시하고, (데이터베이스와 같은) 값비싼 자원은 건너뛰고, 시스템을 테스트 가능한 특정 상태로 강제하는
  강력한 힘을 지녀야 함
- 테스트 API는 테스트 구조를 애플리케이션 구조로부터 결합을 분리하는 게 목표

#### 구조적 결합

- 구조적 결합은 테스트 결합 중에서 가장 강하며 가장 은밀하게 퍼져 나가는 유형
  - 모든 사용 클래스에 테스트 클래스가 각각 존재하고, 모든 상용 메서드에 테스트 메서드 집합이 각각 존재하는 테스트 스위트 가정
    - 애플리케이션 구조에 강하게 결합되어 있음
  - 상용 클래스나 메서드 중 하나라도 변경되면 딸려 있는 다수의 테스트가 변경되어야 함
    - 테스트는 깨지기 쉬워지고 코드를 뻣뻣하게 만듬
- 테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는 데 있음
  - 상용 코드를 리팩터링하거나 진화시키더라도 테스트에는 전혀 영향을 주지 않음
  - 테스트를 리팩터링하거나 진화시킬 때도 사용ㅇ 코드에는 전혀 영향을 주지 않음
- 이렇게 따로 진화할 수 있다는 점은 필수적
  - 테스트는 계속 구체적이고 더 특화된 형태로 발전
  - 사용 코드는 더 추상적이고 더 범용적인 형태로 발전

#### 보안

- 테스트 API가 지닌 강력한 힘을 운영 시스템에 배포하면 위험에 처할 수 있음
  - 위험을 피하고 싶다면 테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포할 수 있는 컴포넌트로 분리

### 결론

- 테스트는 시스템의 일부
- 테스트에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 잘 설계돼야만 함

-------------

## 클린 임베디드 아키텍처

- 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다.
  - 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.
- 펌웨어는 하드웨어 장치에 프로그래밍된 소프트웨어 프로그램 혹은 명령어 집합.
  - ROM, EPROM 혹은 플래시 메모리 같은 비휘발성 메모리에 유지된다.
  - 개별 하드웨어에 내장되는 소프트웨어

### 앱-티튜드 테스트

- 임베디드 소프트웨어는 많이 펌웨어로 변한다.
- 임베디드 코드가 동작하게 만드는 데 대부분의 노력을 집중하고, 오랫동안 유용하게 남도록 구조화하는 데는 그리 신경 쓰지 않기 때문
- 켄트 백의 소프트웨어를 구축하는 세 가지 활동
  - 먼저 동작하게 만들어라
    - 소프트웨어가 동작하지 않는다면 사업은 망한다
  - 그리고 올바르게 만들어라
    - 코드를 리팩터링해서 사람들이 이해할 수 있게 만들고 요구가 변경되거나 요구를 더 잘 이해하게 되었을 때 코드를 개선할 수 있게 만들어라
  - 그리고 빠르게 만들어라
    - 코드를 리팩터링해서 요구되는 성능을 만족시켜라

### 타깃-하드웨어 병목현상

- 임베디드 개발자들은 임베디드가 아니었다면 다루지 않아도 될 특수한 관심사를 가지고 있음
  - 제한된 메모리 공간, 실시간성 제약과 처리완료 시간, 제한된 입출력, 특이한 UI 등등

#### 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다

- 계층
  - 하드웨어는 기술의 발전과 무어의 법칙에 따라 변함
    - 부품은 낡고, 새로운 부품은 적은 전력을 사용하면서 더 나은 성능을 제공하고 저렴함
  - 하드웨어가 정의된 이후라면 하드웨어와 나머지 시스템 사이의 분리가 주어짐
  - 하드웨어 관련 정보가 코드 전체를 오염시키지 못하게 막아야 함
- 하드웨어는 세부사항이다
  - 임베디드 소프트웨어 개발자가 해야 할 일 하나는 이 경계를 분명하게 만드는 것
- 프로세서는 세부사항이다
  - 프로세서 제작 업체가 제공하는 C 컴파일러는 종종 전역 변수처럼 보이는 것들을 제공하지만 이 기능을 사용해 버리면
  그 코드는 더 이상 C가 아니다
    - 다른 프로세서에서는 컴파일되지 않음
    - 동일 프로세서라도 다른 컴파일러로는 컴파일하지 못함
- 운영체제는 세부사항이다
  - 운영체제를 세부사항으로 취급하고 운영체제에 의존하는 일을 막아야 함
- 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라
- DRY 원칙: 조건부 컴파일 지시자를 반복하지 마라

------------

## 결론

- 모든 코드가 펌웨어가 되도록 내버려두면 제품이 오래 살아남을 수 없다
- 클린 임베디드 아키텍처는 제품이 장기간 생명력을 유지하는 데 도움을 준다