# 벽돌부터 시작하기: 프로그래밍 패러다임

- 패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.
- 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.
- 현재까지 세 종류가 있으며, 이들 세 가지 외의 패러다임은 존재하지 않을 것이다.

## 패러다임 개요

### 구조적 프로그래밍

- 최초로 적용된 패러다임(최초로 만들어진 것은 아님)
  - 1968년 에츠허르 비버 데이크스트라가 발견
- 데이크스트라는 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실을 제시.
  - 이러한 점프들을 if/then/else와 do/while/until과 같이 익숙한 구조로 대체

#### 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대한 규칙을 부과한다.

### 객체 지향 프로그래밍

- 두 번째로 도입된 패러다임
  - 구조적 프로그래밍보다 2년 앞선 1966년 올레 요한 달과 크리스텐 니가드에 의해 등장
- 함수 호출 스택 프레임(stack frame)을 힙(heap)으로 옮기면, 함수 호출이 반환된 이후에도 함수에서
선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다.
  - 함수 -> 클래스의 생성자
  - 지역 변수 -> 인스턴스 변수
  - 중첩 함수 -> 메서드
- 함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장하게 됨

#### 객체지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

### 함수형 프로그래밍

- 최근에 들어서야 겨우 도입되기 시작
  - 가장 먼저 만들어짐
  - 컴퓨터 프로그래밍 자체보다 먼저 등장
    - 람다 계산법
- 람다 계산법의 기초가 되는 개념은 불변성(immutability)으로, 심볼(symbol)의 값이 변경되지 않는다는 개념
  - 할당문이 전혀 없다는 뜻

### 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

### 생각할 거리

- 어느 패러다임도 새로운 권한을 부여하지 않고, 프로그래머에게서 권한을 박탈한다.
  - 각 패러다임은 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과
- 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
- goto문, 함수 포인터, 할당문을 앗아가는데 더 이상 가져갈 수 있는게 없어서 패러다임은 앞으로도 세 가지밖에 없을 것이다.
  - 1958년부터 1968년에 걸친 10년 동안 모두 만들어짐
  - 현재까지 새롭게 등장한 패러다임은 없음

### 결론

- 우리는 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용한다.
- 우리는 함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다.
- 우리는 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용한다.
- 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 연관되는지에 주목해야 한다.

-------------

## 구조적 프로그래밍

- 데이크스트라는 원시적인 환경에서 위대한 발견을 해냈다.

### 증명

- 데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 사실이었다.
- 데이크스트라는 수학자가 유클리드 계층구조를 사용하는 방식을 프로그래머도 사용할 수 있다고 믿었다.
- 프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 코드가 올바르다는 사실을 스스로 증명하게 되는 방식
- 데이크스트라는 이 연구를 진행하면서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다.
  - 모듈을 분해할 수 없다면 분할 정복 접근법을 사용할 수 없게 됨
- 이러한 goto문의 좋은 사용 방식은 분기와 반복(if/then/else, do/while)이라는 단순한 제어 구조에 해당한다는 사실을 발견함.
  - 모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화하는  것이 가능해보였기 때문

### 해로운 성명서

- 데이크스트라는 세 가지 제어 구조에 대한 자신의 의견을 피력했고, 프로그래밍 세계는 불이 붙었다.
  - 극도로 부정적인 편지도 있는 반면 강력하게 지지하는 의견도 있었다.
- 현재 우리 모두는 구조적 프로그래머이며 여기에는 선택의 여지가 없다.
  - 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문

### 기능적 분해

- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었다.
  - 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다.
    - 저수준의 함수들로 다시 분해할 수 있다.
    - 끝없이 반복할 수 있다.
- 구조적 분석이나 구조적 설계와 같은 기법이 인기를 끌었다.

### 엄밀한 증명은 없었다

- 증명은 이루어지지 않았다.
  - 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다.
- 다행히도 무언가가 올바른지를 입증할 때 사용하는 전략에는 수학적인 증명만 있는 것이 아닌 과학적 방법이 있다.

### 과학이 구출하다

- 과학은 증명하는 것이 아닌 실험을 통해 시연하고 경험적 증거를 수집한다.
- 과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작한다.

### 테스트

- 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다
- 부정확함에 대한 증명은 입증 가능한 프로그램에만 적용할 수 있다.
- 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요하고, 테스트를 통해 증명 가능한 세부 기능들이
거짓인지를 증명하려고 시도한다.
- 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.

### 결론

- 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.
- 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 반증 가능성에 의해 주도된다.
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야 한다.
  - 테스트하기 쉽도록

---------------

## 객체 지향 프로그래밍

- 객체 지향 OO 설계 원칙을 이해하고 응용하는 데서 출발
- OO이란?

### 캡슐화?

- OO을 정의하는 요소 중 하나로 캡슐화를 언급한다.
- 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다.
  - private, public
- 하지만 이러한 개념이 OO에만 국한된 것은 아니다.

```
// point.h
struct Point;
struct Point* makePoint(double x, double y);
double distance(struct Point *p1, struct Point *p2);

// point.c
#include "point.h"

...
```
- point.h를 사용하는 측에서 struct Point의 멤버에 접근할 방법이 전혀 없다.
  - OO이 아닌 언어에도 가능하다
- 완벽한 캡슐화이지만 C++ 라는 형태로 OO가 등장했고, C가 제공하던 완전한 캡슐화가 깨지게 되었다.
  - C++ 컴파일러는 기술적인 이유(클래스의 인스턴스 크기를 알 수 있어야 한다)로 클래스의 멤버 변수를 해당 클래스의 헤더 파일에
  선언할 것을 요구했는데 헤더 파일을 이용하는 츠겡서 멤버 변수를 알게되기 때문에 더 나은 캡슐화를 제공하지 못한다.

### 상속?

- OO 언어가 더 나은 캡슐화를 제공하지 못하지만 상속은 제공한다.
  - 하지만 OO 언어가 있기 훨씬 이전에도 언어의 도움 없이 손수 구현할 수 있었다.

```
// namedPoint.h
struct NamedPoint;
struct NamedPoint* makedNamedPoint(double x, double y, char* name);
void setName(struct NamedPoint* np, char* name);
char* getName(struct NamedPoint* np);

// namedPoint.c
# include "namedPoint.h"
# include <stdlib.h>

struct NamedPoint {
    double x,y;
    char* name;
};

...
```

- OO 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었다
- 캡슐화에 대해서는 OO에 점수를 줄 수 없고, 상속에 대해서만 0.5점 정도를 부여할 수 있다.

### 다형성?

```
#include <stdio.h>

void copy() {
    int c;
    while((c=getchar()) != EOF)
        putchar(c);
}
```

- 행위가 STDIN, STDOUT의 타입에 의존한다.
- 함수를 가리키는 포인터를 응용한 것이 다형성이라는 점이다.
- OO 언어는 다형성을 제공하지는 못했지만 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.
- 함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식에는 문제가 있는데
  - 함수 포인터는 위험하다
  - 프로그래머는 관례를 준수해야 하는데, 모든 관례를 알아야한다..

#### 다형성이 가진 힘

- 장치 독립적
  - 어떠한 장치여도 소프트웨어가 동작한다
- 의존성 역전
  - 제어흐름은 시스템의 행위에 따라 결정되며 소스 코드 의존성은 제어흐름에 따라 결정되었으나, 다형성이 있다면 
  소스 코드 의존성이 제어흐름과 반대가 된다.
  - 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻
  - 의존성을 역전시킨다면 각각 컴포넌트들은 의존하는 방향을 서로 다르게 설정할 수 있기 때문에 독립적으로 배포할 수 있다.

### 결론

- OO을 사용하면 아키텍트는 플러그인 아키텍처(장치 독립적)를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은
저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장(의존성 역전)할 수 있다.
- 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

-----------

## 함수형 프로그래밍

- 함수형 프로그래밍이라는 개념은 프로그래밍 그 자체보다 앞서 등장했다.
- 이 패러다임에서 핵심이 되는 기반은 람다 계산법으로 알론조 처치가 1930년대에 발명했다.
- 자바 프로그램은 가변 변수를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다.
  - 반복문을 사용할 때 쓰는 i 와 같은 것
- 클로저는 변수가 한 번 초기화되면 절대로 변하지 않는다.
  - 함수형 언어에서 변수는 변경되지 않는다.

### 불변성과 아키텍처

- 아키텍처를 고려할 때 변수의 가변성을 염려하는 이유는 경합 조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변 변수로 인해
발생하기 때문이다.
- 동시성 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.
- 하지만 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다고 전제할 수 있을 때만 불변성이 실현 가능하다.
  - 타협이 필요하다

### 가변성의 분리

- 불변성과 관련하여 가장 주요한 타협 중 하나는 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.
  - 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며 어떤 가변 변수도 사용되지 않는다.
- 상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터
가변 변수를 보호한다.
- 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 하고, 가변 변수들을 보호하는 적절한
수단을 동원해 뒷받침해야 한다.
- 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

### 이벤트 소싱

- 고객의 계좌 잔고를 관리하는 은행 애플리케이션 예시
  - 입금 트랜잭션과 출금 트랜잭션이 실행되면 잔고를 변경
  - 잔고를 변경하는 대신 트랜잭션 자체를 저장한다면?
  - 잔고 조회를 요청할 때마다 모든 트랜잭션을 단순히 더하면 가변 변수가 하나도 필요 없음
  - 하지만 무한한 저장 공간과 무한한 처리 능력이 필요함
    - 애플리케이션의 수명주기 동안만 문제없이 동작할 정도로 저장 공간과 처리 능력만 있으면 충분
- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략
  - 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리
- 지름길 가능
  - 매일 자정에 상태를 계산하고, 그 이후 상태 정보가 필요해지면 자정 이후의 트랜잭션만 처리
- 저장 공간을 많이 확보해야 하지만 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없음
  - CRUD가 아닌 CR
  - 완전한 함수형으로 만들 수 있음

### 결론

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율
- 함수형 프로그래밍은 변수 할당에 부과되는 규율
- 소프트웨어는 순차, 분기, 반복, 참조 그 이상 그 이하도 아니다.
