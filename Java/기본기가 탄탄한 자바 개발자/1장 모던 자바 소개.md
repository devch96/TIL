# 모던 자바 소개

-------

## 언어와 플랫폼

- 자바 라는 용어는 사람이 읽을 수 있는 프로그래밍 언어 또는 훨씬 더 광범위한 자바 플랫폼을 의미
- 자바 언어:
  - 정적 타입의 객체지향 언어
- 자바 플랫폼:
  - 소프트웨어가 실행될 수 있는 환경을 제공하는 것
  - JVM
- 자바 코드는 사람이 읽을 수 있는 자바 소스로 시작해 javac에 의해 .class 파일로 컴파일된 후 JVM에 로드됨
- 로드 과정에서 클래스를 조작하고 변경하는 것이 일반적임
- JVM 바이트코드는 사람이 읽을 수 있는 소스 코드와 기계어 사이의 중간 단계에 가까움
  - 자바 소스를 바이트코드로 변환하는 과정이 C++이나 Go 와는 다름
- javac는 gcc와 같은 컴파일러가 아니라 자바 소스 코드를 위한 클래스 파일 생성기에 불과
  - 실제 컴파일러는 JIT 컴파일러(Junt In Time)
- 자바 시스템은 '동적으로 컴파일되는' 시스템
  - 컴파일이 빌드 프로세스 중 클래스 파일 생성이 아니라 런타임 시에 발생하는 JIT 컴파일을 강조
  - 컴파일 언어이면서 인터프리터 언어

-------

## 향상된 타입 추론(var 키워드)

- 자바는 전통적으로 장황한 언어로 명성이 높았으나 최근 버전에서는 타입 추론을 점점 더 많이 사용하도록 언어가 발전함
- 소스 코드 컴파일러의 이 기능을 사용하면 컴파일러가 프로그램의 일부 타입 정보를 자동으로 처리할 수 있기에 모든 것을 명시적으로 선언하지 않아도 됨
- 제네릭 메서드가 자바 5에 도입되면서 시작

```java
List<Integer> beforeGeneric = Collections.<Integer>emptyList();

List<Integer> afterGeneric = Collections.emptyList();
```

- 제네릭 처리와 관련해서 자바 7에서 더 발전함
  - 컴파일러가 오른쪽에 있는 타입 정보를 작성해 처리하도록 변경
  - 다이아몬드 구문이라고 함

```java
Map<Integer, Map<String, String>> beforeJava7 = new HashMap<Integer, Map<String, String>>();

Map<Integer, Map<String, String>> afterJava7 = new HashMap<>();
```

- 자바 8에서는 람다 표현식의 도입을 지원하기 위해 더 많은 타입 추론이 추가됨

```java
Function<String, Integer> lengthFn = s -> s.length();
```

- 현대 자바에서는 로컬 변수 타입 추론 (var) 이라고 하는 기능이 도입돼 타입 추론이 한 단계 더 발전됨
- 자바 10에 추가되었음

```java
var afterJava10 = new ArrayList<String>();
```

- 자바에서의 타입 추론은 지역적이며, var의 경우 로컬 변수의 선언만을 검사함
  - 필드, 메서드 인수, 반환 타입에는 사용할 수 없음
- 또한 null은 모든 참조 타입의 변수에 할당할 수 있기 때문에 var 을 사용할 경우 어떤 타입일지 유추할 수 있는 정보가 없어
사용하지 못함

- 언제 로컬 변수 타입 추론(var)을 사용할지에 대한 몇 가지 지침
  - 단순한 초기화에서 오른쪽이 생성자 또는 정적 팩토리 메서드에 대한 호출일 경우
  - 명시적인 타입을 제거하면 반복되거나 중복된 정보가 삭제되는 경우
  - 변수 이름만으로도 타입을 알 수 있는 경우
  - 로컬 변수의 범위와 사용법이 짧고 간단한 경우
- var의 고급 사용법 중 하나인 표현 불가능한 타입
  - 자바에서 유효한 타입이지만 변수의 타입으로는 나타낼 수 없고 표현식의 타입으로 추론해야 함

```java
var duck = new Object() {
                void quack() {
                    System.out.println("Quack!");
                }
            };

duck.quack();
```

-----------

## 자바 11에서의 작은 변경 사항

### 컬렉션 팩토리(JEP 213)

- 컬렉션 리터럴을 선언하는 간단하고 편리한 방법을 지원
- 기존에 배열 리터럴을 지원해왔음

```java
int[] numbers = {1,2,3};
```

- 하지만 Collections의 주요 설계 원칙 중 하나는 클래스가 아닌 인터페이스로 표시된다는 것임
  - 아무리 일반적이라도(ArrayList, HashMap, HashSet...) 구체적인 구현과 직접 결합하는 새로운 구문이 있으면
  의도한 설계 원칙과 반대됨
  - 대신 자바 8에서 인터페이스에 정적 메서드를 가질 수 있는 기능이 추가돼 이를 활용해서 팩토리 메서드를 추가하는 것으로 설계 결정이 이루어짐

```java
Set<String> set = Set.of("a","b","c");
var list = List.of("x", "y");
```

- Set과 List는 최대 10개의 요소에 해당 요소들을 나열한 메서드가 제공되며 10개보다 많은 경우를 위해 가변 인수 형태도 제공됨
  - of(E... elements)
- 맵의 경우 두 개의 일반 매개변수(키 타입, 값 타입)가 있으므로 간단하게 작성할수도 있지만, 가변 인수는 제공하지 않음
  - ofEntries() 다른 팩토리 메서드를 사용해야 함

```java
var map1 = Map.of(k1, v1);
var map2 = Map.of(k1, v1, k2, v2);

var map3 = Map.ofEntries(
        entry(k1, v1),
        entry(k2, v2),
        entry(k3, v3));
```

- 위와 같은 팩토리 메서드는 변경할 수 없는 타입의 인스턴스를 생성함
  - 기존의 ArrayList나 HashMap과 같은 가변 클래스가 아닌 새로운 구현체

### 엔터프라이즈 모듈 제거(JEP 320)

- 플랫폼을 간소화하기 위한 노력으로 엔터프라이즈 모듈들이 제거됨
- 기능을 사용하려면 명시적으로 외부 의존성을 포함해야 함

### HTTP/2 (자바 11)

- HTTP 1.1은 최신 웹 애플리케이션의 성능과 관련해 문제가 있음
  - 헤드 오브 라인 블로킹
  - 단일 사이트로의 제한된 연결
  - HTTP 제어 헤더의 성능 오버헤드
- 클라이언트와 서버 간 바이트 흐름 방식에 중점을 둔 HTTP/2는 실제로 요청/응답, 헤더, 상태 코드, 응답 바디와 같ㅌ은
많은 익숙한 HTTP 개념을 변경하지 않았음

#### 헤드 오브 라인 블록킹

- HTTP 통신은 TCP 소켓을 통해 이루어짐
- HTTP 1.1은 불필요한 연결 설립 비용을 반복하지 않기 위해 개별 소켓을 재사용하도록 돼 있지만 프로토콜은 여러 요청이 소켓을 공유하는 경우에도
요청이 순서대로 반환되도록 함
  - 서버의 느린 응답이 더 빨리 반환될 수 있는 후속 요청을 차단하는 것을 의미
- HTTP/2는 동일한 연결에서 요청을 다중화하도록 설계됨
  - 클라이언트와 서버 간 다중 스트림이 항상 지원됨
  - 단일 요청의 헤더와 본문을 별도로 수신할 수 있음
- HTTP/2 다중화된 응답 사용 시 다른 느린 요청 때문에 애셋이 차단되지 않고 작은 응답이 더 정확하게 캐시될 수 있음

#### 제한된 연결

- HTTP 1.1 사양에서는 서버에 대한 연결을 한 번에 두 개로 제한할 것을 권장함
  - 의무가 아닌 권고
  - 흔히 도메인당 6~8 개의 연결을 허용

#### HTTP 헤더 성능

- 헤더는 HTTP 프로토콜 자체가 상태를 유지하지 않지만 요청 간의 상태를 유지할 수 있게 해줌
  - 로그인한 사실 등
- HTTP 1.1의 페이로드는 클라이언트와 서버가 압축 알고리즘에 대해 합의하면 압축할 수 있지만 헤더는 압축되지 않음
- HTTP/2 는 헤더의 새로운 이진 형식을 통해 문제를 해결

#### TLS의 모든 것

- HTTP/2는 TLS 암호화만 지원
- 운영상 영향을 미치지만 보안에 대한 비용을 줄일 수 있음

#### 기타 고려 사항

- HTTP/2의 채택은 미래를 향한 추세이지만 웹 전반에 걸쳐 배포가 빠르지 않음
  - 로컬 개발에도 영향을 미침

#### 자바11에서 HTTP/2

- java.net.http에 위치한 API는 HTTP 1.1과 HTTP/2를 모두 지원
- 호출된 서버가 HTTP/2를 지원하지 않는 경우 HTTP 1.1로 폴백할 수 있음

```java
var client = HttpClient.newBuilder().build();

var uri = new URI("https://google.com");
var request = HttpRequest.newBuilder(uri).build();

// HTTP 요청을 동기적으로 실행해서 그 응답을 저장하고 요청이 완료될 때까지 블로킹됨
// send 메서드는 응답 본문을 어떻게 처리할 지 알려주는 핸들러가 필요(표준 핸들러를 사용해 본문을 문자열로 반환)
var response = client.send(request, HttpResponse.BodyHandlers.ofString(Charset.defaultCharset()));
```

- 전체 HTTP 호출이 완료될 때까지 응답 객체를 받지 못함
- HTTP/2의 가장 큰 장점은 내장된 멀티플렉싱

```java
var client = HttpClient.newBuilder().build();

var uri = new URI("https://google.com");
var request = HttpRequest.newBuilder(uri).build();

// sendAsync는 HTTP 요청을 시작하지만 future을 반환하고 다음 호출을 차단하지 않음
var handler = HttpResponse.BodyHandlers.ofString();
CompletableFuture.allOf(
        client.sendAsync(request, hander).thenAccept((response) -> System.out.println(response.body()),
        client.sendAsync(request, hander).thenAccept((response) -> System.out.println(response.body()),
        client.sendAsync(request, hander).thenAccept((response) -> System.out.println(response.body())
        ).join();
```

### 단일 소스 코드 프로그램(JEP 330)

- 자바 프로그램을 실행하는 일반적 방법은 소스 코드를 클래스 파일로 컴파일한 후 클래스의 바이트코드를 해석하는 실행 컨테이너 역할의
가상머신 프로세스를 시작하는 것
- JEP 330 출시와 함께 자바 11은 프로그램을 실행하는 새로운 방법을 제공
  - 소스 코드는 메모리에서 컴파일된 다음 디스크에 .class 파일을 생성하지 않고 인터프리터로 실행할 수 있음
  - 파이썬 및 기타 스크립팅 언어와 같은 사용자 경험 제공
- 제약 사항이 있음
  - 단일 소스 파일에 있는 코드로 제한됨
  - 동일한 실행에서 추가적인 소스 파일을 컴파일할 수 없음
  - 소스 파일에 여러 클래스를 포함할 수 있음
  - 소스 파일에서 첫 번째 클래스를 진입점으로 선언해야 함
  - 진입점 클래스에서 main 메서드를 정의해야 함
- 소스 코드 호환성 모드를 지시하기 위해 --source 플래그를 사용

```shell
/usr/bin/java --source 11

public finacl class HTTP2check {
  public static void main(String[] args) {
    if (args.length < 1) {
      usage();

}  }
}

./HTTP2Check https://www.google.com
```

--------------
