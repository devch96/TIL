# 자바 모듈

- 자바 9는 자바 플랫폼 모듈을 도입함
- 모듈의 도입은 애플리케이션 아키텍처에 깊은 영향을 미치며 모듈은 프로세스 풋프린트, 시작 비용, 웜업 시간과 같은 츠겸ㄴ에 관심이 있는
현대 프로젝트에 많은 장점을 제공함
- 모듈은 복잡한 의존성으로 유명한 JAR 지옥 문제를 해결하는 데 도움이 될 수 있음

--------

## 배경 설명

- 모듈은 자바 9부터 도입된 자바 언어에서 새로운 개념
- 모듈은 런타임에 의미를 가지는 응용 프로그램 배포 및 의존성의 단위
- 기본 자바 개념
  - JAR 파일은 런타임에는 보이지 않으며, 단순히 클래스 파일들을 포함하고 있는 압축된 디렉터리
  - 패키지는 실제로 접근 제어를 위해 클래스를 그룹화하기 위한 네임스페이스
  - 의존성은 클래스 레벨에서만 정의됨
  - 접근 제어와 리플렉션이 결합돼 명확한 배포 단위 경계 없이 최소한의 시행으로 근본적으로 개방적인 시스템을 생성함
- 모듈의 특징
  - 모듈 간의 의존성 정보를 정의하므로 컴파일 또는 애플리케이션 시작 시점에서 모든 종류의 해결과 연결 문제를 감지할 수 있음
  - 적절한 캡슐화를 제공해 내부 패키지와 클래스를 조작하려는 사용자로부터 안전하게 보호할 수 있음
  - 최신 자바 런타임에서 이해하고 사용할 수 있는 메타데이터가 포함된 적절한 배포 단위
- 모듈 시스템의 목표는 배포 단위(모듈)를 가능한 한 서로 독립적으로 만드는 것

### 프로젝트 직소

- 모듈 기능을 제공하기 위한 OpenJDK 내 프로젝트는 프로젝트 직소 로 알려야 져있음

#### 모놀리식이 아닌 모듈식 자바 런타임

- 기존의 JAR 형식은 기본적으로 클래스들을 포함하고 있는 zip 파일일 뿐
- 모듈은 프로그램의 생명 주기에서 서로 다른 시점(컴파일/링크 타임, 런타임)에 사용되는 두 가지 새로운 형식(JMOD, JIMAGE)을 제공
  - JMOD 형식은 기존 JAR 형식과 유사하지만 별도의 공유 객체 파일을 제공하지 않고 네이티브 코드를 단일 파일의 일부로 포함할 수 있도록 수정됨
  - JIMAGE 형식은 자바 런타임 이미지를 나타내는 데 사용됨

#### 내부의 캡슐화

- OpenJDK 플랫폼 개발자들은 사용자 애플리케이션의 염려없이 새로운 기능과 더 나은 성능을 제공하기 위해 JVM과 플랫폼 클래스의 구현을
자유롭게 수정함
  - 자바 개발자들은 플랫폼 구현의 일부를 사용하는 경향이 있었음
- 플랫폼 내부를 크게 변경하는 데 있어 가장 큰 접근 제어자인데 리플렉션이나 관련 패키지에 추가 클래스 생성 등 다양한 방법으로
제한을 우회할 수 있었음
- 모듈화는 이러한 레거시 문제를 해결하기 위한 한 가지 방법

#### 모듈식 JVM

- 스택 추적(stack trace) 형식이 자바 8에서 사용되던 형식에서 변경됨
- 스택 프레임은 패키지 이름, 클래스 이름, 라인 번호뿐만 아니라 모듈 이름(java.base)으로도 구분됨

### 모듈 그래프

- 모듈화의 핵시은 모듈이 서로 의존하는 방식을 나타내는 모듈 그래프
- 모듈 그래프는 유향 비순환 그래프이므로 순환 의존성이 있을 수 없음

### 내부 보호하기

- 모듈이 해결해야 할 주요 문제 중 하나는 사용자 자바 프레임워크와 내부 구현의 세부 사항 결합 문제

```java
import sun.net.URLCanonicalizer;

public class MyURLHandler extends URLCanonicalizer {
    public boolean isSimple(String url) {
        return isSimpleHostName(url);
    }
}
```

- 내부 API에 액세스한다는 경고 표시가 뜨지만 컴파일러는 액세스를 허용하고, JDK의 내부 구현에 긴밀하게 결합된 사용자 클래스가 생성됨

### 새로운 접근 제어에 대한 의미

- 모듈은 자바의 접근 제어 모델에 새로운 개념인 패키지 엑스포트 개념을 추가
- 자바8 이전에는 모든 패키지의 공개 클래스에 있는 공개 메서드를 호출할 수 있었음
- 자바8 이전에는 전체 패키지에 접근 제어를 적용할 방법이 없었음
  - JDK 팀은 공용 API를 정의할 수 없음
- 패키지에서 java나 javax로 시작하는 모든 것이 공개 API고 그 외 모든 것은 내부 전용이라는 것은 단지 관습
  - 클래스 로딩 매커니즘은 강제하지 않음
- 어떤 패키지가 공용 API로 간주되는지를 나타내기 위해 exports 키워드가 도입됨

-------

## 기본적인 모듈 구문

- 자바 플랫폼 모듈은 단일 엔티티로 선언되고 로드되는 패키지와 클래스의 모음인 개념적 단위로 정의됨
- 각 모듈은 모듈 기술자라고 하는 새로운 파일(module-info.java)을 선언해야 함
  - 모듈 이름
  - 모듈 의존성
  - 공개 API(내보낸 패키지)
  - 리플렉션 액세스 권한
  - 제공되는 서비스
  - 소비되는 서비스
- 모듈 기술자는 소스 계층구조 내에서 적절한 위치에 배치해야 함

### 모듈 내보내기와 의존 모듈 선언하기

- exports 키워드는 인수로 패키지 이름을 기대함
- requires 키워드는 현재 모듈의 의존성을 선언하며 항상 패키지 이름이 아닌 모듈 이름이 인수로 필요함

---------

## 모듈 로드하기

- 네 가지 유형의 모듈이 존재하는데 일부는 로드 시 동작이 약간 다름
  - 플랫폼 모듈
  - 애플리케이션 모듈
  - 자동 모듈
  - 이름 없는 모듈
- 최신 JVM에는 모듈을 인식하는 클래스로더가 있으며 JRE 클래스가 로드되는 방식이 자바 8과는 상당히 다름
- 클래스 로딩에 대한 모듈식 접근 방식의 기본 원칙
  - 모듈은 과거 방식의 클래스 패스가 아닌 모듈 패스에서 해결
  - 시작 시 JVM은 비순환적이어야 하는 모듈 그래프를 확인
  - 하나의 모듈은 그래프의 루트이며 실행이 시작되는 곳

### 플랫폼 모듈

- 모듈형 JDK 자체의 모듈
- --list-modules 플래그를 통해 플랫폼 모듈의 목록을 가져올 수 있음

### 애플리케이션 모듈

- 라이브러리 모듈이라고도 불림
- JSON을 다루기 위한 Jackson 라이브러리는 모듈화됐으며 애플리케이션 모듈로 간주됨

----------