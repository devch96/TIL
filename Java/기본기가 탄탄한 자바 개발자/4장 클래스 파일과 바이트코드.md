# 클래스 파일과 바이트코드

- 클래스 로딩은 JVM이 실행 중인 프로그램에서 새로운 타입을 찾아 활성화하는 과정

-------

## 클래스 로딩과 클래스 객체

- .class 파일은 필드, 메서드, 상속 정보, 애너테이션, 기타 메타데이터로 구성된 JVM에서의 타입을 정의함
- 개발자가 실행 가능한 JAR 파일이나 기본 애플리케이션 클래스의 이름을 제공하면 JVM이 해당 클래스를 찾아서 실행함
- 모든 애플리케이션의 의존성(JDK 이외의 라이브러리)도 클래스 패스에 있어야 하는데 JVM은 이러한 의존성도 찾아서 로드함

```java
Class<?> clazz = Class.forName("MyClass");
```

- 이 코드 조각은 MyClass라는 클래스를 현재 실행 상태로 로드함
  - MyClass라는 이름에 해당하는 클래스 파일을 찾음
  - 해당 파일에 포함된 클래스를 해석
  - 클래스 파일에서 klass를 성공적으로 추출하면 JVM은 klass의 자바 미러를 생성하고 이는 Class 객체로 자바 코드에 반환됨
  - 실행 중인 시스템에서 해당 타입을 나타내는 Class 객체를 사용할 수 있으며 새로운 인스턴스를 생성할 수 있음
  - clazz는 MyClass 타입에 해당하는 Class 객체를 보유하게 됨
    - klass는 자바 객체가 아닌 JVM 내부 객체여서 clazz가 보유할 수 없음

### 로딩과 링킹

- JVM을 바라보는 한 가지 방법은 실행 컨테이너라고 보는 것
- 이 관점에서 JVM의 목적은 클래스 파일을 소비하고 그 안에 포함된 바이트코드를 실행하는 것
- JVM은 클래스 파일의 내용을 바이트 데이터 스트림으로 조회해서 사용 가능한 형태로 변호나한 후 실행 상태에 추가
- 이 프로세스는 여러 가지 방법으로 나눌 수 있지만 로딩 과 링킹으로 나눔

- 클래스 파일을 구성하는 바이트의 데이터 스트림을 가져오는 것
- 파일 시스템에서 읽어오는 바이트 배열로 시작(다른 방법으로 읽는 것도 가능)
- 스트림을 확보한 후에 유효한 클래스 파일 구조를 포함하고 있는지를 확인(형식 검사)
  - 통과하면 후보 klass가 생성됨
- 후보 klass가 작성되는 동안 몇 가지 기본적인 검사가 수행됨
  - 로드 중인 클래스가 실제로 선언된 슈퍼클래스에 액세스 할 수 있는가?
  - final 메서드를 재정의하려고 시도하는가? 등
- 로딩 프로세스가 끝나도 클래스에 해당하는 데이터 구조는 다른 코드에서 사용할 수 없으며 완전하게 구현된 klass 가 아님
- 클래스를 링크한 후 초기화해야 사용할 수 있음
- 링킹의 과정은 검증, 준비, 해결

#### 검증

- 바이트코드가 허용되지 않거나 악의적인 방법으로 스택을 조작하려고 시도하지 않는지 확인
- 모든 분기 명령어(if or for)에 적절한 대상 명령어가 있는지 확인
- 메서드가 올바른 정적 유형의 매개변수 수로 호출되는지 확인
- 로컬 변수에 적절한 타입의 값만 할당됐는지 확인
- 던질 수 있는 각 예외에 적절한 캐치 핸들러가 있는지 확인

#### 준비

- 클래스 준비에는 메모리를 할당하고 클래스의 정적 변수를 초기화할 수 있도록 준비하는 작업이 포함되지만 변수를 초기화하거나 JVM이 바이트코드를 실행하지는 않음

#### 해결

- 링킹할 클래스의 상위 유형(및 클래스가 구현하는 모든 인터페이스)이 이미 링킹됐는지 확인하고 그렇지 않은 경우
해당 타입들을 링킹함

#### 초기화

- 모든 정적 변수가 초기화되고 모든 정적 초기화 블록이 실행됨
- 그러고 나서 JVM이 새로 로드된 클래스의 바이트코드를 실행함
- 이 단계가 완료되면 런타임에서 클래스를 사용할 수 있으며 클래스의 인스턴스를 생성할 수 있음

### Class 객체

- 로딩과 링킹 프로세스의 최종 결과는 새로 로드되고 링크된 타입을 나타내는 Class 객체
- Class 객체는 메서드, 필드, 생성자 등에 대한 간접적인 액세스를 위해 리플렉션 API와 함께 사용할 수 있음

--------

## 클래스로더

- 자바는 기본적으로 동적 런타임을 갖춘 객체지향 시스템
- 자바 프로그램은 final 타입이 아니거나 sealed 클래스 중 하나가 아닐 경우에 한해 런타임에 알 수 없는 타입으로 확장할 수 있음
- 클래스 로딩 기능은 사용자에게 노출돼있음
- 클래스로더는 ClassLoader를 확장하는 자바의 클래스일 뿐이며 그 자체로 자바의 타입임
- ClassLoader 클래스에는 클래스 파일의 저수준 구문 분석을 담당하는 로드와 링크 부분을 포함해서 몇 가지 네이티브 메서드가 있지만 사용자 클래스로더는
클래스 로딩의 부분을 재정의할 수 없음
- 클래스로더는 핵심 역할 외에도 JAR 파일이나 클래스패스의 다른 위치에서 리소스를 로드하는 데 사용되는 경우가 많음

```java
try (var is = TestMain.class.getResourceAsStream("/resource.csv"); 
var bs = new BufferedReader(new InputStreamReader(is));) {
    
        }
```

### 사용자 정의 클래스 로드

- 클래스로더 클래스가 final이 아니기 때문에 개발자는 각자의 필요에 맞는 자체 클래스로더를 작성하는 것이 가능
- 사용자 정의 클래스로더도 자바의 타입이기 때문에 상위 클래스로더에서 로드해야함
  - 클래스 상속이나 부모 클래스와는 다름
  - 위임 관계
- 사용자 정의 메커니즘의 핵심은 ClassLoader에 정의된 loadClass()와 findClass() 메서드
- loadClass()는 클래스가 이미 로드됐는지 확인한 다음 부모 클래스로더에 요청함
- 클래스 로딩에 실패하면 로딩 프로세스는 findClass()로 위임됨

#### 클래스 로드 중 발생할 수 있는 예외들

- ClassNotFoundException
  - 클래스로더가 지정된 클래스를 로드하려고 시도했지만 로드할 수 없음
  - 로드가 요청된 시점에 해당 클래스를 JVM이 알 수 없었고, JVM이 해당 클래스를 찾지 못함
- NoClassDefFoundError
  - 요청된 클래스의 존재를 알고 있지만 내부 메타데이터에서 해당 클래스에 대한 정의를 찾지 못함
  - 오류임

```java
public class ExampleNoClassDef {
    public static class BadInit {
        private static int thisIsFine = 1 / 0;
    }
    
    public static void main(String[] args) {
        try {
            var init = new BadInit();
        }catch (Throwable t) {
            System.out.println(t);
        }
        var init2 = new BadInit();
        System.out.println(init2.thisIsFine);
    }
}
```

- 위 코드의 경우 NoClassDefFoundError가 발생
- JVM이 BadInit 클래스를 로드하려고 시도했지만 실패했음을 보여줌
- 예외를 포착하고 계속 진행하려고 하지만 두 번째 만났을 때 JVM의 내부 메타데이터 표에 클래스가 인식됐지만 유효한 클래스가
로드되지 않은 것으로 나타남
- UnsupportedClassVersionError
  - 클래스 로드 작업이 런타임이 지원하는 것보다 상위 버전의 자바 소스 코드 컴파일러로 컴파일된 클래스 파일을 로드하려고 할 때 발생하는 에러

#### 첫 번째 사용자 정의 클래스로더

- ClassLoader를 서브클래싱하고 findClass()를 오버라이드하는 것

```java
public class LoadSomeClasses {
    public static class SadClassLoader extends ClassLoader {
        public SadClassLoader() {
            super(SadClassLoader.class.getClassLoader());
        }
        
        public Class<?> findClass(String name) throws ClassNotFoundException {
            System.out.println("----");
            throw new ClassNotFoundException(name);
        }
    }
    
    public static void main(String[] args) {
        if (args.length > 0) {
            var loader = new SadClassLoader();
            for(var name : args) {
                System.out.println(name + " ::");
                try{
                    var clazz = loader.loadClass(name);
                    System.out.println(clazz);
                } catch (ClassNotFoundException x) {
                    x.printStackTrace();
                }
            }
        }
    }
}
```

- 대부분의 사용자 정의 클래스로더는 필요한 특정 기능을 제공하이 위해 findClass()를 재정의하는 것이 전부
  - 네트워크를 통해 클래스를 찾는 것 등

--------

## 리플렉션

- 리플렉션은 객체를 쿼리하거나 내부를 조사해서 런타임에 해당 객체의 기능을 발견하고 사용하는 기능
- 리플렉션 스타일의 프로그래밍을 사용할 때는 정적 타입을 전혀 사용하지 않고 객체를 조작할 수 있음
  - 안좋은 것 처럼 보이지만 모든 타입과 작업할 수 있는 라이브러리, 프레임워크, 도구를 만들 수 있다는 의미

### 리플렉션 소개

```java
Object o = new Object();
Class<?> clz = o.getClass();
```

- olz의 실제 유형은 Class 이지만 제네릭타입을 사용해 처리해야 함
- 리플렉션이 동적인 런타임 메커니즘이기 때문에 소스 코드 컴파일러에게 알려지지 않았기 때문
- 컴파일 시에 어떤 유형인지 알 수 없고 매우 일반적인 방식으로 처리해야 한다면 유연성을 활용해 개방적이고 확장 가능한 시스템을 구축할 수 있음

```java
class Pet{
    public void feed() {
      System.out.println("Feed the pet");
    }
}

var clz = Pet.class;
Object o = clz.newInstance();
```

- newInstance()는 Object 타입을 반환함
  - o를 다시 Pet으로 다운캐스팅할 수 있지만 어떤 타입으로 작업할 지 미리 알아야 하는것임

```java
Method m = clz.getMethod("feed", new Class[0]);
Object ret = m.invoke(o);
```

- Method 클래스는 해당 Method 객체가 나타내는 메서드를 호출하는 효과를 갖는 invoke() 메서드를 정의함

### 클래스 로딩과 리플렉션 결합하기

- protected defineClass() 메서드에 접근

```java
public class NativeMethodChecker {
    public static class EasyLoader extends ClassLoader {
        public EasyLoader() {
            super(EasyLoader.class.getClassLoader());
        }
        
        public Class<?> loadFromDisk(String fName) throws IOEXception {
            var b = Files.readAllBytes(Path.of(fName));
            return defineClass(null, b, 0, b.length);
        }
    }
    
    public static void main(String[] args) {
        if(args.length > 0) {
            var loader = new EasyLoader();
            for (var file: args) {
                System.out.println(file + " ::");
                try{
                    var clazz = loader.loadFromDisk(file);
                    for (var m : clazz.getMethods()) {
                        if (Modifier.isNative(m.getModifiers())) {
                            System.out.println(m.getName());
                        }
                    }
                }
            }
        }
    }
}
```

### 리플렉션의 문제점

- 자바 컬렉션 이전에 만들어진 매우 오래된 API로 배열 타입이 여기저기 존재
- 어떤 메서드 오버로드를 호출할지 결정하는 것은 쉽지 않음
- API에는 메서드에 대한 리플렉션적인 접근을 위해 getMethod()와 getDeclaredMethod()라는 두 가지 메서드가 제공됨
- API는 접근 제어를 무시하는 데 사용할 수 있는 setAccessible() 메서드를 제공
- 리플렉션 호출에 대한 예외 처리가 복잡
  - 체크된 예외가 런타임 예외로 변환됨
- 원시 타입을 전달하거나 반환하는 리플렉션 호출을 수행하려면 박싱과 언박싱이 필요
- 원시 타입에는 플레이스홀더 클래스 객체(int.class 등)가 필요
- void 메서드에는 java.lang.Void 타입을 도입해야 함