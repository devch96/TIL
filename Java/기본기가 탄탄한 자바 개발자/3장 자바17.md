# 자바 17

-------------

## Text 블록

- 지금까지의 자바는 이스케이프 처리해야 안전하게 사용할 수 있는 간단한 한 가지 유형의 문자열만 제공됨
- Text 블록의 구체적인 목표는 자바 프로그래머가 과도한 문자 이스케이프 처리의 번거로움에서 벗어날 수 있도록 도와줄 뿐만 아니라
자바 프로그램에 포함해야 하는 코드 문자열을 읽을 수 있도록 함

```java
String query = """
        SELECT "ORDER_ID", "QUANTITY", "CURRENCY_PAIR" FROM "ORDERS"
        WHERE "CLIENT_ID" = ?
        ORDER BY "DATE_TIME", "STATUS" LIMIT 100;
        """;
```

- """ 시퀀스로 시작 및 종료됨
- 각 줄의 시작 부분에 공백으로 들여쓰기를 할 수 있고 이때 공백은 무시됨
- Text 블록은 문자열 리터럴과 마찬가지로 상수 표현식
  - 클래스 파일에 상수를 기록하기 전에 javac에서 Text 블록을 처리함

---------

## switch 표현식

- 자바는 초기 버전부터 switch 문을 지원했음

```java
switch(month) {
    case 1:
        System.out.println("January");
        break;
    case 2:
        System.out.println("February");
        break;
    ...
}
```

- 자바의 switch 문은 case가 break로 끝나지 않으면 다음 case 이후에도 실행이 계속된다는 속성을 C,C++로부터 이어받음

```java
switch(month) {
    case 12:
    case 1:
    case 2:
        System.out.println("Winter, brrr");
        break;
    case 3:
    case 4:
    case 5:
        System.out.println("Spring has sprung!");
        break;
    ...
}
```

- 하지만 한 번의 break를 생략하는것은 저지르기 쉬운 실수이고 오류가 발생하기도 함
- switch문은 나중에 사용하기위해 값을 저장하려 할 때도 안좋음

```java
String message = null;
switch(month) {
    case 12:
    case 1:
    case 2:
        message = "Winter, brrr";
        break;
    }
```

- break를 놓치는 것과 마찬가지로 모든 경우에 message 변수를 올바르게 설정해야 하며 버그 발생 위험이 있음
- 자바 14(JEP 361)에 도입된 switch 표현식은 단점을 해결할 수 있는 동시에 함수 지향 언어와의 언어적 격차를 줄이는데 도움이 됨

```java
String message = switch(month) {
    case 12:
    case 1:
    case 2:
        yield "Winter, brrr";
    case 3:
    case 4:
    case 5:
        yield "Spring has sprung";
}
```

- 각 case는 새로운 yield 키워드를 사용해서 변수에 할당함
- 더욱 간결한 구문도 제공

```java
String message = switch(month) {
    case 1, 2, 12 -> "Winter, brrr";
    case 3, 4, 5 -> "Spring has sprung";
    default -> {
        throw new IllegalArgumentException("Not a month");
    }
}
```

- ->는 switch 표현식에 있음을 나타내므로 명시적인 yield가 필요하지 않음
- 새로운 라벨링 형식은 유용하고 짧아진 것뿐만 아니라 문제를 해결함
  - 여러 가지 경우를 나타내기 쉬워짐
  - default 가 없으면 컴파일 오류가 발생함
- switch 문과 달리 switch 표현식은 입력 유형에서 가능한 한 모든 경우를 처리해야 하며 그렇지 않으면 코드가 컴파일되지 않음

```java
String message = switch(month) {
    case JANUARY, FEBRUARY, DECEMBER -> "Winter, brrr";
}
```

- int를 받는 switch 표현식의 경우 모든 값을 나열할 수 없으므로 default를 포함해야 함

------

## record

- 새로운 형태의 자바 클래스
  - 데이터 전용 집계 모델링을 위한 최고 수준의 수단 제공
  - 자바의 타입 시스템에서 발생할 수 있는 격차 해소
  - 공통 프로그래밍 패턴을 위한 언어 수준 문법 제공
  - 클래스 상용구 감소
- record는 클래스를 필드로만 명시하는 방법을 만드는 것
- 필드를 명시하면 컴파일러가 자동으로 메서드를 생성
- 보일러 플레이트 코드 작성을 방지
  - toString()
  - hashCode(), equals()
  - Getter
  - 공개 생성자
- 레코드는 모든 필드라 final(불변)
- 레코드 클래스는 새로운 인스턴스를 생성할 수 있도록 상태 설명과 정확히 일치하는 매개변수들의 목록을 가진 생성자(AllArgsConstructor)도 생성
- 레코드 클래스의 슈퍼타입으로 java.lang.Record가 있음
  - equals(), hashCode(), toString()을 추상 메서드로 선언
  - 직접적으로 확장할 수 없음

### 명목적 타이핑

- record의 설계 의도는 개발자가 서로 관련된 필드들을 하나의 불변속성의 데이터 항목으로 그룹화할 수 있도록 하는 것
- 레코드가 생성할 수 있는 메서드의 예시 중 하나는 일부 매개변수에 기본값을 제공하기 위한 정적 팩토리 메서드
- 기본 데이터 캐리어에 많은 추가 메서드 등을 추가하고 싶거나 여러 인터페이스를 구현하고 싶을수록 레코드가 아닌 일반 클래스를 사용해야 함

### 콤팩트 레코드 생성자

- 레코드 클래스의 콤팩트 생성자의 형식 매개변수는 암묵적으로 선언됨
- 콤팩트 생성자는 인수로 전달된 값을 검증하고 정규화하는 역할을 수행

```java
public record FXOrder(int units, CurrencyPair pair, Side side, double price, LocalDateTime sentAt, int ttl) {
    public FXOrder {
        if (units < 1) {
            throw new IllegalArgumentException("FXOrder units must be positive");
        }
        if (ttl < 0) {
            throw new IllegalArgumentException("FXOrder TTL must be positive, or 0 for market orders");
        }
        if (price <= 0.0) {
            throw new IllegalArgumentException("FXOrder price must be positive");
        }
    }
}
```

- 콤팩트 생성자를 사용하지 않고 명시적인 정식 생성자를 사용하고 싶은 경우도 있음
  - 생성자에서 작업을 수행해야 하는 의미인데 데이터 캐리어 클래스로 사용하는 사례는 많지 않음

----------

## sealed 타입

- 클래스 파일 내에서 열거형의 가능한 모든 값은 public static final 변수로 정의되며 생성자는 private이므로 추가적인 인스턴스를 생성할 수 없음
- 열거형은 싱글톤 패턴의 일반화와 비슷하지만 클래스의 인스턴스가 하나만 있는 것이 아니라 유한한 개수가 있다는 점이 다름
- 다양한 주문을 모델링 하고 싶다면 단일 구현 클래스 혹은 추상 클래스를 선언하고 상속하여 구체적 타입을 가지도록 할 수 있음
- 하지만 자바는 기본적으로 확장 가능한 언어이기에 하위 클래스는 언제 만들어질지 모름
- 자바 17은 상속을 더 세밀하게 제어할 수 있는 sealed 타입을 제공함
- 자바에서 sealed가 표현하는 개념은 타입을 확장할 수 있지만 지정된 하위 타입들에 의해서만 확장할 수 있고, 다른 하위 타입들은
확장할 수 없다는 개념

```java
public abstract sealed class Pet {
    private final String name;
    
    protected Pet(String name) {
        this.name = name;
    }
    
    public String name() {
        return name;
    }
    
    public static final class Cat extends Pet {
        public Cat(String name) {
            super(name);
        }
        
        void meow() {
            System.out.println(name() + " meows");
        }
    }

    public static final class Dog extends Pet {
      public Dog(String name) {
        super(name);
      }
  
      void bark() {
        System.out.println(name() + " barks");
      }
    }
}
```

- sealed로 선언된 경우, 해당 클래스는 현재의 컴파일 유닛 내에서만 확장될 수 있음
  - 하위 클래스는 현재 클래스 또는 소스 파일의 비공유 클래스 내에 중첩돼야 함
- sealed는 인터페이스에도 사용할 수 있다(클래스 형식보다 더 쓰임)

```java
public sealed interface FXOrder permits MarketOrder, LimitOrder {
    int units();
    CurrencyPair pair();
    Side side();
    LocalDateTime sentAt();
}

public record MarketOrder(int units, CurrencyPair pair, Side side,
                          LocalDateTime sentAt, boolean allOrNothing) 
        implements FXOrder {
}

public record LimitOrder(int units, CurrencyPair pair, Side side,
                          LocalDateTime sentAt, double price, int ttl)
        implements FXOrder {
}
```

- 개발자가 sealed 인터페이스를 구현할 수 있는 클래스들을 나열할 수 있도록 해주는 permits를 사용함
- 이러한 타입으로 프로그래밍하면 발생 가능한 모든 FXOrder 인스턴스는 MarketOrder 또는 LimitOrder여야 한다는 것을 알 수 있음
- 자바의 객체지향 모델은 타입 간의 관계에 타입 X는 Y의 일종(IS-A) 와 타입 X는 Y를 가지고 있음(HAS-A)만 있었지만 sealed 타입이 등장하면서
타입 X는 Y 또는 Z 중 하나(IS-EITHER-A) 관계를 나타낼 수 있게 됨
- 자바의 sealed 타입은 허용된 모든 타입이 확장하는 베이스 클래스(또는 허용된 모든 타입이 구현해야 하는 공통의 인터페이스)가 있어야 한다는 것

---------

## instanceof의 새로운 형식

- x instanceof Y는 값 x를 Y 유형의 변수에 할당할 수 있으면 true, 아니면 false를 반환
  - null instanceof Y는 모든 Y에 대해서 false를 반환
- 개발자가 컴파일 시점에 완전히 알 수 없는 유형을 가진 객체에 직면해야 하는 경우 사용하기 좋음
  - 리플렉션을 통해 얻은 객체 등
- instanceof를 사용해서 타입이 예상대로인지 확인한 다음 다운캐스트를 수행하는 것이 바람직함

```java
Object o = ...
if (o instanceof String) {
    String s = (String) o;
    System.out.println(s.length());
} else{
    System.out.println("Not a String");
}
```

- 자바 17에서 사용할 수 있는 새로운 instanceof 기능은 형 변환하지 않아도 되는 방법을 제공하는 것

```java
if (o instanceof String s) {
    System.out.println(s.length());
} else{
    System.out.println("Not a String");
}
```

--------

## 패턴 매칭과 프리뷰 기능

- switch 표현식, records, sealed 타입 등 새로운 언어 기능은 프리뷰 기능으로 시작해서 한 차례 이상의 공개 프리뷰를 거친 후 최종 기능으로 제공 됨
- instanceof에서 siwtch로 패턴 매칭을 확장하는 프리뷰 기능이 17에 추가됨

```java
if (o instanceof String s) {
    System.out.println("String of length: " + s.length());
} else if (o instanceof Integer i) {
    System.out.println("Integer: " + i);
} else {
    System.out.println("Not a String or Integer");
}
```

- 코드가 불편하고 장황해지니 switch 표현식에 타입 패턴을 도입하는 프리뷰 기능을 사용할 수 있음

```java
var msg = switch (o) {
    case String s -> "String of length: " + s.length();
    case Integer i -> "Integer: " + i;
    case null, default -> "Not a String or Integer"; // null을 case 레이블로 사용해 NPE를 방지할 수 있음
}
System.out.println(msg);
```

- 프리뷰 기능을 사용하는 코드를 컴파일할때는 프리뷰 기능을 활성화해야 함

```shell
javac --enable-preview -source 17
java --enable-preview 
```

- 프리뷰 기능을 사용하여 컴파일한 경우 표준 클래스 파일을 얻지 못하므로 대부분의 팀은 프로덕션 환경에서 해당 코드를 실행해서는 안됨
- 자바 17의 패턴 매칭 프리뷰 버전에는 Sealed 타입과 긴밀하게 통합할 수 있는 기능도 있음

```java
public sealed interface FXOrderResponse permits FXAccepted, FXFill, FXReject, FXCancelled {
    LocalDateTime timestamp();
    long orderId();
}

FXOrderResponse resp = ...
var msg = switch(resp) {
    case FXAceepted a -> a.orderId() + "Acceped";
    case FXFill f -> f.orderId() + " Filled " + f.units();
    case null -> "Order is null";
}
```

- case null을 포함시켜 null-safe 하게 작동하고 default가 필요없음
- 첫 번째 프리뷰에는 불리언 조건으로 패턴을 꾸밀 수 있는 가드 패턴도 포함돼 있는데 패턴의 술어와 가드가 모두 참인 경우에만 전체 패턴이 일치함

```java
case FXFill f && f.units() < 100 -> f.orderId() + " Small Fill";
case FXFill f -> f.orderId() + " Fill " + f.units();
```