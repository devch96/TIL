# 자바 동시성 기초

- 자바는 두 가지 동시성 API를 가지고 있음
  - 블록 구조 동시성
  - 동기화 기반 동시성(클래식 동시성)
- 동기화 기반 동시성이라는 대체 이름에서 알 수 있듯 플랫폼에 내장된 언어 수준의 API로 synchronized와 volatile 키워드에 의존

--------

## 동시성 이론 입문

### 하드웨어

- 동시성 프로그래밍은 근본적으로 성능에 관한 것
- 실행 중인 시스템의 성능이 직렬 알고리즘(순차적)으로 작동하기에 충분하다면 동시성 알고리즘을 구현할 이유가 없음
- 최신 컴퓨터 시스템에는 여러 개의 프로세싱 코어가 있음
- 모든 자바 프로그램은 멀티스레드
- JVM 자체가 다중 코어를 사용할 수 있는 멀티스레드 바이너리

### 암달의 법칙

- 암달의 법칙(Amdahl's law)은 여러 실행 단위에서 작업을 공유할 때의 효율성을 추론하기 위한 간단하고 대략적인 모델
  - 실행 단위는 스레드 혹은 프로세스 혹은 작업을 수행할 수 있는 엔티티일 수도 있음
  - 기본적인 전제 사항은 작업 처리를 위해 더 작은 단위로 세분화할 수 있는 작업이 하나 있다는 것
- 프로세서(또는 작업을 수행할 스레드)가 N개일 경우, 경과 시간은 T1/N이 될것이라고 단순하게 예상할 수 있음
  - 하지만 작업을 분할하는 것은 무료가 아님
  - 작업을 세분화하고 재결합하는데 오버헤드가 발생
- 통신 오버헤드가 몇 퍼센트에 해당하는 오버헤드라고 가정하고 이를 숫자 s로 나타낼 수 있다고 가정
  - s의 일반적인 값은 0.05 (5%)
- 따라서 얼마나 많은 처리 유닛을 투입하든 상관없이 작업을 완료하는 데 항상 최소 s * T1이 소요
  - s가 N에 의존하지 않는다고 가정하지만 N이 증가함에 따라 s가 나타내는 작업의 분할이 더 복잡해지고 더 많은 시간이 필요할 수 있음
  - s가 일정하다는 최상의 시나리오
- 암달의 법칙을 가장 쉽게 생각하는 방법은 s가 0과 1 사이인 경우 달성할 수 있는 최대 속도 향상은 1 / s^3
  - 통신 오버헤드가 2%에 불과해도 달성할 수 있는 최대 속도 향상은 50배
  - 1 / (1 - s)

### 자바의 스레드 모델 설명

- 자바의 스레드 모델 기본 개념
  - 공유되며 기본적으로 보이는 가변상태(변수나 상태)
  - 운영체제에 의한 선점형 스레드 스케줄링
- 객체는 프로세스 내의 모든 스레드 간에 공유 가능
- 객체에 대한 참조가 있는 모든 스레드에서 객체 변경 가능
- 스레드 스케줄러(OS)는 언제든 코어에 스레드를 할당하거나 제거 가능
- 메서드는 실행 중에도 교체할 수 있어야 함
  - 그러지 않으면 무한 루프가 있는 메서드가 CPU를 영원히 점유함
- 예측할 수 없는 스레드 스왑이 발생하여 메서드가 반쯤 완료된 상태에서 일관되지 않은 상태의 객체가 발생할 수 있음
- 취약한 데이터를 보호하기 위해 객체를 잠글 수 있음
  - synchronized 키워드
- 자바의 스레드와 잠금 기반 동시성은 매우 저수준이기에 java.util.concurrent 동시성 라이브러리가 자바 5에 도입됨

----------

## 디자인 콘셉트

- java.util.concurrent를 제작하는 작업을 수행하면서 분류한 설계 요인
  - 안전성(동시성 타입 안전성)
  - 활성성
  - 성능
  - 재사용 가능성

### 안전성과 동시성 타입 안전성

- 안전성은 다른 동작들이 동시에 발생하는 상황에서도 객체 인스턴스가 항상 자기 일관성을 유지하도록 보장하는 것을 의미
- 비동시성 코드에서는 객체의 공개 메서드를 호출하더라도 해당 메서드가 끝나면 객체는 잘 정의되고 일관된 상태를 유지해야 함
  - 일반적으로 객체의 상태를 비공개로 유지하고 디자인 도메인에 맞는 방식으로만 객체의 상태를 변경하는 공개 API 메서드 제공
- 동시성 타입 안전성은 객체에 대한 타입 안전성과 기본 개념은 동일하지만 다른 스레드가 동시에 다른 CPU 코어에서 동일한 객체에 대해 잠재적으로 수행할 수 있는
더 복잡한 세계에 대한 이야기

```java
public class StringStack {
    private String[] values = new Stirng[6];
    private int current = 0;
    public boolean push(String s) {
        if (current < value.length) {
            values[current++] = s;
            return true;
        }
        return false;
    }
    
    public String pop() {
        if(current < 1) {
            return null;
        }
        return values[current--];
    }
}
```

- 단일 스레드 클라이언트 코드에서 사용할 땐 괜찮
- 실행 스레드 간의 콘텍스트 전환이 value를 망가트릴 수 있음
- 안전을 위한 한 가지 전략은 일관되지 않은 상태의 비공개가 아닌 메서드에서는 절대 반환하지 않고,
일관되지 않은 상태에서는 비공개가 아닌 어떤 메서드도 호출하지 않는 것

### 활성성

- 활성성이란 모든 시도된 작업이 최종적으로 진행되거나 실패하는 시스템을 말함
- 일시적인 실패
  - 잠금 또는 잠금 획득 대기
  - I/O 와 같은 입력 대기
  - 에셋의 일시적 오류
  - 스레드 실행을 위한 CPU 시간이 충분하지 않음
- 영구적인 장애
  - 교착상태(데드락)
  - 복구 불가능한 에셋 문제
  - 신호 누락

### 오버헤드의 원인

- 동시성 시스템의 여러 측면이 내재적으로 오버헤드의 원인이 될 수 있음
  - 모니터(잠금 및 조건 변수)
  - 콘텍스트 스위치 수
  - 스레드 수
  - 스케줄링
  - 메모리 위치
  - 알고리즘 설계

---------

## 블록 구조 동시성(자바 5 이전)

### 동기화와 잠금

- synchronized 키워드는 블록이나 메서드에 적용할 수 있음
  - 블록이나 메서드에 들어가기 전에 스레드가 적절한 잠금을 획득해야 한다는 것

```java
public synchronized boolean withdraw(int amount) {
    if (balance >= amount) {
        balance -= amount;
        return true;
    }
    return false;
}
```

- 메서드는 객체 인스턴스에 속한 잠금을 획득해야 함
  - static synchronized 메서드의 경우 Class 객체에 속한 잠금을 획득
- 블록의 경우 어떤 객체의 잠금을 획득할지 명시해야 함
- 한 번에 한 스레드만 객체의 동기화된 블록이나 메서드를 통과할 수 있음
  - 다른 스레드가 들어가려고 시도하면 JVM에 의해 중단됨
- 자바의 동기화와 잠금
  - 원시 자료형이 아닌 객체만 잠글 수 있음
  - 객체들의 배열을 잠가도 개별 객체는 잠기지 않음
  - 동기화된 메서드는 전체 메서드를 포괄하는 블록과 동일하다고 생각할 수 있음
  - static synchronized 메서드는 잠글 인스턴스 객체가 없기 때문에 Class 객체를 잠금
  - Class 객체를 잠가야 하는 경우 하위 클래스에서 접근 방식에 따라 동작이 다를 수 있으므로 명시적으로 잠가야 하는지 getClass()를
  사용해 잠가야 하는지 고려해야 함
  - 내부 클래스의 동기화는 외부 클래스와 독립적임
  - synchronized 메서드는 메서드 시그니처의 일부가 아니기 때문에 인터페이스의 메서드 선언에 표시될 수 없음
  - 동기화되지 않은 메서드는 잠금 상태를 고려하지 않고 신경쓰지 않음

### 스레드의 상태 모델

- 자바에는 Thread.State라는 열거형이 있으며 운영체제의 스레드 상태를 추상화한 것
- 자바 스레드 객체는 처음에 NEW 상태로 생성됨
  - 이때 OS 스레드는 아직 존재하지 않으며 후로도 존재하지 않을 수 있음
  - 실행 스레드를 생성하려면 Thread.start()를 호출해야 함
  - 이러면 OS가 실제로 스레드를 생성함
- 스케줄러는 새로운 스레드를 실행 대기열에 배치하고 나중에 실행할 코어를 찾음
- 코어에 배치돼 실행되고 다시 실행 대기열에 배치되는 동안 자바 Thread 객체는 RUNNABLE 상태로 유지됨
- 스레드 자체가 자신이 현재 코어를 사용할 수 없음을 나타낼 수 있음
  - Thread.sleep() 호출하여 스레드가 진행하기 전에 일정 시간을 기다려야 함을 나타냄
  - Object.wait()를 호출함
  - 두 경우 모두 스레드는 OS에 의해 즉시 코어에서 제거되지만 동작은 각 경우마다 다름
    - Thread.sleep()의 경우 스레드가 TIMED_WAITING 상태로 전환되고 OS가 타이머를 설정, 타이머가 만료되면 스레드가 깨어남
    - Object.wait()의 경우 스레드는 WATING 상태로 전환돼 무기한 대기함
  - 스레드가 I/O를 대기 중이거나 다른 스레드가 보유한 잠금을 획득하기 위해 BLOCKED 상태로 전환될 수 있음
  - 자바 스레드에 해당하는 OS 스레드가 실행을 중단한 경우 해당 스레드 객체는 TERMINATED 상태로 전환됨

### 완전히 동기화된 객체

- 완전히 동기화된 객체는 스레드 안전하며 라이브 상태를 유지함
- 완전히 동기화된 클래스의 조건
  - 모든 필드는 모든 생성자에서 일관된 상태로 초기화됨
  - public 필드가 없음
  - 객체 인스턴스는 private 메서드에서 반환된 후에도 일관성이 보장됨
  - 모든 메서드는 유한한 시간 안에 종료된다는 것이 증명돼야 함
  - 모든 메서드는 동기화돼야 함
  - 어떤 메서드도 불일치한 상태에서 다른 인스턴스의 메서드를 호출하지 않음
  - 어떤 메서드도 불일치한 상태에서 현재 인스턴스의 비공개 메서드를 호출하지 않음

```java
public class FSOAccount {
    private double balance;
    
    public FSOAccount(double openingBalance) {
        balance = openingBalance;
    }
    
    public synchronized boolean withdraw(int amount) {
        if (balance >= amount) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    public synchronized void deposit(int amount) {
        balance += amount;
    }
    
    public synchronized double getBalance() {
        return balance;
    }
}
```

- 클래스가 안전하고 라이브 상태를 유지한다는 점에서 좋아보이지만 성능 측면에서 문제가 발생함
- 모든 접근은 synchronized를 사용해야 하며 성능을 저하시킴
- 코드의 무결성이 취약함
  - balance가 synchronized 메서드 외부에서 접근하지 않은 것을 확인할 수 있지만 코드의 양이 적어서 가능한 것
  - 대규모 시스템에선 눈으로 파악하기 힘듬

### 교착상태

- 동시성의 또 다른 문제는 교착상태(deadlock)

```java
public synchronized boolean transferTo(FSOAccount other, int amount) {
    try {
        Thread.sleep(10);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
    if (balance >= amount) {
        balance -= amount;
        other.deposit(amount);
        return true;
    }
    return false;
}

public class FSOMain {
    private static final int MAX_TRANSFERS = 1_000;
    
    public static void main(String[] args) throws InterruptedException {
        FSOAccount a = new FSOAccount(10_000);
        FSOAccount b = new FSOAccount(10_000);
        Thread tA = new Thread(() -> {
            for (int i = 0; i < MAX_TRANSFERS; i++) {
                boolean ok = a.transferTo(b, 1);
                if (!ok) {
                    System.out.println("Thread A failed at " + i);
                }
            }
        });
        Thread tB = new Thread(() -> {
          for (int i = 0; i < MAX_TRANSFERS; i++) {
            boolean ok = b.transferTo(a, 1);
            if (!ok) {
              System.out.println("Thread A failed at " + i);
            }
          }
        });
        tA.start();
        tB.start();
        tA.join();
        tB.join();
        
        System.out.println("End: " + a.getBalance() + " : " + b.getBalance());
    }
}
```

- 두 개의 트랜잭션이 별도의 스레드에 의해 수행되고 있기에 합리적으로 보임
- 하지만 transferTo() 메서드에서 sleep을 사용하였기 때문에 교착상태에 빠짐
- 교착상태를 처리하는 한 가지 방법은 모든 스레드에서 항상 동일한 순서로 잠금을 획득하는 것

### 왜 동기화해야 하는가?

- 동시성 프로그래밍의 간단한 개념적 모델은 CPU의 타임셰어링, 단일 코어에서 스레드가 켜졌다 꺼졌다 하는 것
- 오늘날 하드웨어는 여러 개의 코어가 있으므로 맞지 않는 설명
- 동시에 실행되는 여러 스레드가 다른 코어에서 동시에 실행됨
- 잠금이 걸린 객체의 서로 다른 스레드 간의 메모리가 동기화되는 것
- synchronized 메서드가 완료된 후에는 잠금이 해제되기 전에 잠금이 걸린 객체에 대한 모든 변경 사항이 메인 메모리로 플러시됨
- 잠금을 획득한 후 동기화된 블록에 진입할 때 잠긴 객체에 대한 모든 변경 사항이 메인 메모리에서 읽히므로 동기화됨

### volatile 키워드

- 원시 요소를 포함한 객체 필드의 동시성 처리를 하는 간단한 방법
- volatile 필드에 적용되는 규칙
  - 스레드가 보는 값은 사용하기 전에 항상 주 메모리에서 다시 읽음
  - 바이트코드 명령이 완료되기 전에 스레드가 쓴 모든 값은 항상 주 메모리로 플러시됨
- 단일 연산에 대한 작은 동기화된 블록과 같다고 설명하기도 하지만 잠금이 포함되지 않기 때문에 오해의 소지가 있음
- synchronized 동작은 객체에 상호 배제 잠금을 사용해 하나의 스레드만 해당 객체에서 동기화된 메서드를 실행할 수 있도록 하는 것
- volatile의 핵심은 메모리 위치에 대해 하나의 작업만 허용하며 즉시 메모리에 플러시된다는 점
- volatile 변수는 변수의 쓰기가 변수의 현재 상태에 의존하지 않는 경우메나 사용해야 함
  - 단일 작업만을 보장하기 때문
  - ++, -- 연산자
- volatile은 경우에 따라 단순화된 코드를 작성할 수 있도록 해주지만 모든 액세스마다 추가적인 플러시 비용이 발생함
- volatile은 잠금을 도입하지 않기 때문에 교착상태를 유발할 수 없음

### 스레드 상태와 메서드

- java.lang.Thread 객체는 힙에 존재하며 현재 존재하거나 이전에 존재했거나 미래에 존재할 수 있는 운영체제 스레드에 대한 메타데이터를 포함함
- NEW: Thread 객체가 생성됐지만 실제 OS 스레드는 아직 생성되지 않음
- RUNNABLE: 스레드가 실행 가능한 상태. OS가 스레드 스케줄링을 담당함
- BLOCKED: 스레드가 실행 중이 아니며 잠금을 획득해야 하거나 시스템 호출 중인 상태
- WAITING: 스레드가 실행되지 않고, Object.wait() 또는 Thread.join()을 호출함
- TIMED_WAITING: 스레드가 실행되지 않고, Thread.sleep()을 호출함
- TERMINATED: 스레드가 실행되지 않으며 실행이 완료됨
- 스레드에 대한 메타데이터를 읽은 메서드
  - getId()
  - getName()
  - getState()
  - getPriority()
  - isAlive()
  - isDaemon()
  - isInterrupted()
- 이름과 데몬 상태와 같은 일부 메타데이터는 설정될 수 있음
  - setDaemon()
  - setName()
  - setPriority()
  - setUncaughtExceptionHandler()
- 실행 중인 다른 스레드와 상호작용하기 위한 메서드
  - start()
  - interrupt()
  - join()

```java
Runnable r = () -> {
    var start = System.currentTimeMillis();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    var thisThread = Thread.currentThread();
    System.out.println(thisThread.getName() + " slept for " + (System.currentTimeMillis() - start));
};

var t = new Thread(r); // 스레드의 메타데이터 객체가 생성됨
t.setName("Worker");
t.start(); // 운영체제가 실제 스래드를 생성
Thread.sleep(100);
t.join(); // 메인 스레드가 일시 중지되고 워커가 종료될때까지 기다렸다가 진행함
System.out.println("Exiting");
```

#### 스레드 인터럽트

- 스레드로 작업할 때 스레드가 수행 중인 작업을 안전하게 중단하고 싶은 경우가 흔함

```java
var t = new Thread(() -> { while (true);});
t.start();

t.interrupt();
t.join();
```

- join()이 영원히 차단됨
  - 스레드 중단이 선택적이기 때문
- 스레드에서 호출되는 메서드는 명시적으로 중단 상태를 확인하고 이에 응답해야 하는데 while 루프는 그러한 확인을 수행하지 않음

```java
var t = new Thread(() -> {while (!Thread.interrupted());});
t.start();

t.interrupt();
t.join();
```

- JDK에서 IO를 차단하거나 잠금을 기다리는 등 차단되는 메서드가 스레드의 인터럽트 상태를 확인하는 것은 일반적임
  - 확인된 예외인 InterruptedException을 던짐
  - Thread.sleep()이 메서드 시그니처에 InterruptedException을 추가하거나 처리해야 하는 이유
- 스레드의 인터럽트 상태를 확인하는 코드는 그 상태를 재설정하기에 표준 InterruptedException을 던지는 코드는 해당 인터럽트를 지워버림
- 인터럽트됐음을 유지하려면 직접 처리해야 함

#### 예외나 스레드로 작업하기

- 스레드 API는 스레드를 시작하기 전에 잡히지 않은 예외 처리기를 스레드에 추가할 수 있는 기능을 제공

```java
var badThread = new Thread(() -> {
    throw new UnsupportedOperationException();
});

badThread.setName("An Exceptional Thread");

badThread.setUncaughtExceptionHandler((t, e) -> {
    System.err.println(~)
});
badThread.start();

public interface UncaughtExceptionHandler{
    void uncaughtExceptionHandler(Thread t, Throwable e);
}
```

#### 더 이상 사용되지 않는 스레드 메서드

- stop()
  - 경고 없이 다른 스레드를 종료시키며, 종료된 스레드가 잠긴 객체를 안전하게 처리할 수 있는 방법이 없음
- suspend()
  - 모니터를 해체하지 않기 때문에 중단된 스레드가 잠근 동기화된 코드에 접근하려고 할 경우 영원히 블록될 수 있음
- 자바 1.2 버전 이후로 deprecated 됨

### 불변성

- 불변객체를 사용하는 것이 큰 도움
  - 상태가 없거나 final 필드만 있는 객체
- 상태가 변경될 수 없어 일관되지 않은 상태가 될 수 없기 때문에 항상 안전하고 살아 있음
- 문제점은 특정 객체를 초기화하는 데 필요한 모든 값을 생성자에 전달해야 하는것
  - 복잡한 생성자의 호출이 문제
  - 팩토리 메서드를 대신 사용

```java
public final class Deposit {
  private final double amount;
  private final LocalDate date;
  private final Account payee;

  private Deposit(double amount, LocalDate date, Account payee) {
    this.amount = amount;
    this.date = date;
    this.payee = payee;
  }

  public static Deposit of(double amount, LocalDate date, Account payee) {
      return new Deposit(amount, date, payee);
  }
  
  public static Deposit of(double amount, Account payee) {
      return new Deposit(amount, LocalDate.now(), payee);
  }
}
```

- 불변객체는 변경할 수 없기 때문에 변경이 필요한 경우 아예 새로운 객체를 전달함

```java
public Deposit roll() {
    return new Deposit(amount, date.plusDay(1), payee);
}

public Deposit amend(double newAmount) {
    return new Deposit(newAmount, date, payee);
}
```

- 팩토리 메서드에 전달할 매개변수가 많을 수 있는데 이럴 경우 빌더 패턴을 사용할 수 있음

```java
public final class Deposit {
  private final double amount;
  private final LocalDate date;
  private final Account payee;

  private Deposit(double amount, LocalDate date, Account payee) {
    this.amount = amount;
    this.date = date;
    this.payee = payee;
  }
  
  public static class DepositBuilder implements Builder<Deposit> {
      private double amount;
      private LocalDate date;
      private Amount payee;
      
      public DepositBuilder amount(double amount) {
          this.amount = amount;
          return this;
      }
      
      public DepositBuilder date(LocalDate date) {
          this.date = date;
          return this;
      }
      
      public DepositBuilder payee(Account payee) {
          this.account = payee;
          return this;
      }
      
      @Overried
      public Deposit builder() {
          return new Deposit(amount, date, payee);
      }
  }
}
```

- 빌더는 소위 단일 추상 메서드 타입이며 람다 표현식의 타깃 타입으로 사용할 수 있지만 빌더의 목적은 불변 인스턴스를 생성하는 것이지
함수나 콜백을 나타내는 것이 아니기에 타깃 타입으로 사용하는 것이 유용하지 않음
  - 무언가를 할 수 있다고 해서 반드시 해야 한다는 의미가 아님
- 빌더가 스레드에 안전하지 않음
  - 사용자가 암묵적으로 스레드 간에 빌더를 공유하지 않는다고 가정함
  - 한 스레드가 빌더를 사용해서 필요한 모든 상태를 집계한 다음 다른 스레드와 공유할 수 있는 불변객체를
  생성하는 것이 빌더 API의 올바른 사용법
- 자바에서 final 키워드는 참조 자체에 적용되며 참조가 가리키는 객체의 상태에는 적용되지 않음
  - 참조를 다른 객체로 재할당할 수 없음은 보장
  - 참조가 가리키는 객체의 내부 상태는 변경 가능함
- 불변성은 매우 강력한 기술이며 가능하면 항상 사용해야 하지만 객체의 상태를 변경할 때마다 새로운 객체를 생성해야 하므로
효율적으로 개발할 수 없는 경우도 있음

-------

## 자바 메모리 모델

- Happens-Before
  - 이 관계는 한 블록의 코드가 완전히 완료된 후 다른 블록이 시작될 수 있음을 나타냄
- Synchronizes-With
  - 어떤 동작은 주 메모리와 객체의 뷰를 동기화한 후 계속함
- 자바 메모리 모델의 규칙
  - 모니터의 unlock 동작은 Synchronizes-With 이후에 발생하는 lock 동작과 동기화됨
  - volatile 변수에 대한 쓰기 동작은 Synchronizes-With 이후에 발생하는 해당 변수의 읽기 동작과 동기화됨
  - 동작 A가 동작 B와 Synchronizes-With 관계에 있다면 동작 A는 동작 B보다 먼저 발생함
  - 하나의 스레드 내에서 프로그램 순서에 따라 동작 A가 동작 B 전에 나온다면 동작 A는 동작 B 이전에 Happens-Before 관계를 형성함
- 쓰기 시 스레드가 보유하는 잠금은 다른 작업(읽기 포함)에서 잠금을 획득하기 전에 해제됨
  - 한 스레드가 volatile 변수에 값을 쓰면 나중에 해당 변수를 읽는 모든 스레드가(다른 쓰기가 발생하지 않았다는 가정 하에) 쓰여진 값을 볼 수 있도록
  보장함

----------
