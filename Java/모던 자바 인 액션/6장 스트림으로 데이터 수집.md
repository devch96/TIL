# 스트림으로 데이터 수집

- 중간 연산은 한 스트림을 다른 스트림으로 변환하는 연산으로서, 여러 연산을 연결할 수 있다.
- 중간 연산은 스트림 파이프라인을 구성하며, 스트림의 요소를 소비하지 않는다.
- 최종 연산은 스트림의 요소를 소비해서 최종 결과를 도출한다.
- 최종 연산은 스트림 파이프라인을 최적화하면서 계산 과정을 짧게 생략하기도 한다.

--------------

## 컬렉터란 무엇인가?

### 고급 리듀싱 기능을 수행하는 컬렉터

- collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 컬렉터의 최대 강점이다.
- 스트림에 collect를 호출하면 스트림의 요소에 컬렉터로 파라미터화된 리듀싱 연산이 수행된다.
- collect에서는 리듀싱 연산을 이용해서 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리한다.
- 함수를 요소로 변환(toList 처럼 데이터 자체를 변환하는 것보다는 데이터 저장 구조를 변환할 때가 많다)할 때는 컬렉터를 적용하며
최종 결과를 저장하는 자료구조에 값을 누적한다.
- Collectors 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 팩터리 메서드를 제공한다.

### 미리 정의된 컬렉터

- Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.
  - 스트림 요소를 하나의 값으로 리듀스하고 요약
    - 리스트에서 총합을 찾는 등의 다양한 계산을 수행할 때 유용하게 활용
  - 요소 그룹화
    - 다수준으로 그룹화하거나 각각의 결과 서브그룹에 추가로 리듀싱 연산을 적용할 수 있다.
  - 요소 분할
    - 그룹화의 특별한 연산인 분할
    - 분할(프리디케이트를 그룹화 함수로 사용)

--------------------

## 리듀싱과 요약

- 컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있다.
- 트리를 구성하는 다수준 맵, 단순한 정수 등 다양한 형식으로 결과가 도출될 수 있다.

### 스트림값에서 최댓값과 최솟값 검색

- Collectors.maxBy, Collectors.minBy 두 개의 메서드를 이용해서 스트림의 최댓값과 최솟값을 계산할 수 있다.
- 두 컬렉터는 스트림의 요소를 비교하는 데 사용할 Comparator를 인수로 받는다.
```java
Comparator<Dish> dishCaloriesComparator =
    Comparator.comparingInt(Dish::getCalories);

Optinal<Dish>< mostCalorieDish = menu.stream().collect(Collectors.maxBy(dishCaloriesComparator));
```
- 스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱 기능이 자주 사용된다.
  - 이러한 연산을 요약 연산이라 부른다.

### 요약 연산

- Collectors 클래스는 Collectors.summingInt라는 특별한 요약 팩터리 메서드를 제공한다.
- summingInt는 객체를 int로 매핑하는 함수를 인수로 받는다.
- summingInt의 인수로 전달된 함수는 객체를 int로 매핑한 컬렉터를 반환한다.
- summingInt가 collect 메서드로 전달되면 요약 작업을 수행한다.
```java
int totalCalories = menu.stream().collect(Collectors.summingInt(Dish::getCalories));
```
- Collectors.summingLong과 Collectors.summingDouble 메서드도 같은 방식으로 동작한다.
- 평균값 계산 등의 연산도 요약 기능으로 제공된다.

```java
double avgCalories = menu.stream().collect(Collectors.averagingInt(Dish::getCalories));
```

- 여러 요약 연산을 한 번에 수행해야 할 때도 있다.
```java
IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));
// IntSummaryStatistics{count=9, sum=4300, min=120, average=477.777778, max=800}
```
- count, sum, min, average, max 값을 준다.

### 문자열 연결

- 컬렉터에 joining 팩터리 메서드를 사용하면 스트림의 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다.
```java
String shortMenu = menu.stream().map(Dish::getName).collect(Collectors.joining());
```
- 두 요소 사이에 구분 문자열을 넣을 수 있도록 오버로드된 joining 팩터리 메서드도 있다.
```java
String shortMenu = menu.stream().map(Dish::getName).collect(Collectors.joining(", "));
```

### 범용 리듀싱 요약 연산

- 위의 모든 컬렉터는 reducing 팩터리 메서드로도 정의할 수 있다.
```java
int totalCalories = menu.stream().collect(Collectors.reducing(0, Dish::getCalories, (i,j) -> i+j));
```
- Collectors.reducing은 인수 세 개를 받는다.
  1. 리듀싱 연산의 시작값이거나 스트림에 인수가 없을 때는 반환값이다.(숫자 합계에서는 인수가 없을 때 반환값으로 0이 적합)
  2. 변환 함수
  3. 두 항목을 더하는 람다

### 자신의 상황에 맞는 최적의 해법 선택

- 함수형 프로그래밍에서는 하나의 연산을 다양한 방법으로 해결할 수 있음을 보여준다.
- 스트림 인터페이스에서 직접 제공하는 메서드를 이용하는 것에 비해 컬렉터를 이용하는 코드가 더 복잡하다는 사실도 보여준다.
  - 코드가 좀 더 복잡한 대신 재사용성과 커스터마이즈 가능성이 제공하는 높은 수준의 추상화와 일반화를 얻을 수 있다.
- 문제를 해결할 수 있는 다양한 해결 방법을 확인한 다음에 가장 일반적으로 문제에 특화된 해결책을 고르는 것이 바람직하다

----------------

## 그룹화

- 명령형으로 그룹화를 구현하려면 까다롭고, 할일이 많으며, 에러도 많이 발생한다.
- 자바 8의 함수형을 이용하면 가독성 있는 한 줄의 코드로 그룹화를 구현할 수 있다.
- Collectors.groupingBy를 이용해서 쉽게 메뉴를 그룹화할 수 있다.
```java
Map<Dish.Type, List<Dish>> dishesByType = menu.stream()
        .collect(Collectors.groupingBy(Dish::getType));
```
- groupingBy는 이 함수를 기준으로 스트림이 그룹화되므로 이를 분류 함수(classification function)라고 한다.
- 단순한 속성 접근자 대신 더 복잡한 분류 기준이 필요한 상황에서는 메서드 참조를 분류 함수로 사용할 수 없다.
```java
public enum CaloricLevel {DIET, NORMAL, FAT}
  
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream().collect(
        Collectors.groupingBy(dish -> {
            if(dish.getCalories() <= 400){
                return CaloriecLevel.DIET;
            } else if(dish.getCalories() <= 700){
                return CaloricLevel.NORMAL;
            }else{
                return CaloricLevel.FAT;
            }
        }));
```

### 그룹화된 요소 조작

- 요소를 그룹화 한 다음에는 각 결과그룹의 요소를 조잫가는 연산이 필요하다
  - 500 칼로리가 넘는 요리만 필터링
```java
Map<Dish.Type, List<Dish>> caloricDishesByType = menu.stream()
        .filter(dish -> dish.getCalories() > 500)
        .collect(Collectors.groupingBy(Dish::getType));
```
- 이렇게 하면 filter를 먼저 하고 그룹하기 때문에 필터 프레디케이트를 만족하지 않는 키는 맵에서 사라지게 된다.
- groupingBy를 하고 filter를 해야 하기 때문에 groupingBy의 오버로드 메서드를 사용하면 된다.
```java
Map<Dish.Type, List<Dish>> caloricDishesByType = menu.stream()
        .collect(Collectors.groupingBy(Dish::getType), 
        Collectors.filtering(dish -> dish.getCalories() > 500, toList()));
```
- filtering 메서드는 Collectors 클래스의 또 다른 정적 팩터리 메서드로 프레디케이트를 인수로 받는다.
- 그룹화된 항목을 조작하는 다른 유용한 기능 중 또 하나로 매핑 함수를 이용해 요소를 변환하는 작업이 있다.
```java
Map<Dish.Type, List<String>> dishNamesByType = menu.stream()
        .collect(groupingBy(Dish::getType), mapping(Dish::getName, toList()));
```

