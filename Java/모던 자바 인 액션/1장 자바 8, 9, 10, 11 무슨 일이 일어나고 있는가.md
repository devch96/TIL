# 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

- 1996년에 자바 개발 키트(Java Development Kit, JDK 1.0)가 발표된 이후로 수많은 프로그래머, 프로젝트 관리자, 학생 등이 크고 작은
프로젝트에 표현 언어인 자바를 적극적으로 활용했다.
- 자바는 새로운 기능과 더불어 계속 발전했다

-----------------------

## 역사의 흐름은 무엇인가?

- 자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어났다.
  - 사과 목록을 무게순으로 정렬하는 코드
    - 고전
      ```java
      Collections.sort(inventory, new Comparator<Apple>() {
          public int compare(Apple a1, Apple a2){
              return a1.getWeight().compareTo(a2.getWeight());
          }
      });
      ```
    - 자바8 이후
      ```java
      inventory.sort(comparing(Apple::getWeight))
      ```
- 멀티코어 CPU 대중화와 같은 하드웨어적 변화도 자바 8에 영향을 미쳤다.
  - 자바 8이 등장하기 이전엔 나머지 코어를 활용하려면 스레드를 사용하는 것이 좋다고 했다.
  - 하지만 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점이 있다.
- 자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다.
- 자바 8에서 제공하는 새로운 기술
  - 스트림 API
    - 자바 8은 데이터베이스 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원하는 스트림이라는 새로운 API를 제공한다.
    - 데이터베이스 질의 언어에서 고수준 언어로 원하는 동작을 표현하면, 구현에서 최적의 저수준 실행 방법을 선택하는 방식으로 동작한다.
    - 즉 스트림을 이용하면 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 synchronized를 사용하지 않아도 된다.
  - 메서드에 코드를 전달하는 기법
    - 함수형 프로그래밍에서 위력을 발휘한다.
  - 인터페이스의 디폴트 메서드

--------------

## 왜 아직도 자바는 변화하는가?

- 새로운 언어가 등장하면서 진화하지 않은 기존 언어는 사장되었다.
- 특정 분야에서 장점을 가진 언어는 다른 경쟁 언어를 도태시킨다.
  - 단지 새로운 하나의 기능 때문에 기존 언어를 버리고 새로운 언어와 툴 체인으로 바꾼다는 것은 쉽지 않은 일이다.
  - 하지만 새로 프로그래밍을 배우는 사람은 자연스럽게 새로운 언어를 선택하게 되며 기존 언어는 도태된다.

### 프로그래밍 언어 생태계에서 자바의 위치

- 자바는 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작했다.
- 코드를 JVM 바이트 코드로 컴파일하는 특징, 모든 브라우저에서 가상 머신 코드를 지원하기 때문에 자바는 인터넷 애플릿 프로그램의 주요 언어가 되었다.
- 하지만 프로그래머는 빅데이터(테라바이트 이상의 데이터셋)라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서
빅데이터를 효과적으로 처리할 필요성이 커졌는데 지금까지의 자바로는 충분히 대응할 수 없었다.
- 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념을 소개한다.

### 스트림 처리(Stream Processing)

- 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.
- 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다.
- 즉 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.
- 자바 8에는 java.util.stream 패키지에 스트림 API가 추가되었다.
- 스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 또한 스트림 파이프라인을
이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 있다.
- 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다.

### 동작 파라미터화로 메서드에 코드 전달하기

- 코드 일부를 API로 전달하는 기능이다.
- 자바 8 이전의 자바에서는 메서드를 다른 메서드로 전달할 방법이 없었다. 전달하려면 객체를 만들어서 메서드에 전달해야 했었다.
- 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다.
- 이러한 기능을 동작 파라미터화(Behavior Parameterization)라고 부른다.

### 병렬성과 공유 가변 데이터

- 병렬성을 공짜로 얻을 수 있다 라는 말이 있다.
- 세상에 공짜는 없다는 말이 있듯이 병렬성을 얻으려면 스트림 메서드로 전달하는 코드의 동작 방식을 바꿔야 한다.
- 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다.
  - 공유된 가변 데이터(shared mutable data)에 접근하지 않아야 한다.
  - 순수(pure) 함수, 부작용 없는(side-effect-free) 함수, 상태 없는(stateless) 함수라 부른다.
- 물론 기존처럼 synchronized를 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수 있으나 synchronized를 사용하면 다중 처리 코어에서
코드가 순차적으로 실행되어야 하므로 병렬이라는 목적을 무력화시키면서 비싼 대가를 치러야 할 수 있다.
- 공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은 함수형 프로그래밍 패러다임의 핵심적인 사항이다.

### 자바가 진화해야 하는 이유

- 자바는 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가선다.
- 이러한 변화에 익숙해지면 그것이 가져다주는 편리함을 누릴 수 있다.
- 또한 두 가지 프로그래밍 패러다임의 장점을 모두 활용할 수 있다.
  - 어떤 문제를 더 효율적으로 해결할 수 있는 다양한 도구를 얻게 된다.
- 언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다.

---------------------

## 자바 함수

- 프로그래밍 언어에서 함수(function)라는 용어는 메서드(method) 특히 정적 메서드(static method)와 같은 의미로 사용된다.
- 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다.
- 자바 8에서는 함수를 새로운 값의 형식으로 추가했다.
- 자바 프로그램에서 조작할 수 있는 값은 기본값, 객체, 등이다. 그런데 함수가 필요한 이유는 뭘까?
- 프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 역사적 전통적으로 프로그래밍 언어에서는 이 값을 일급(first-class) 혹은 시민(citizens) 값이라고 부른다.
- 자바 프로그래밍 언어에서 다양한 구조체(메서드,클래스)가 값의 구조를 표현하는 데 도움이 될 수 있지만, 프로그램을 실행하는 동안 이러한 모든 구조체를
자유롭게 전달할 수는 없다. 이를 이급 시민이라 그런다.

### 메서드와 람다를 일급 시민으로

- 스칼라와 그루비 같은 언어에서 메서드를 일급값으로 사용하면 프로그래머가 활용할 수 있는 도구가 다양해지면서 프로그래밍이 수월해진다는 사실을 확인했다.
- 자바 8의 설계자들은 메서드를 값으로 취급할 수 있게, 그리하여 프로그래머들이 더 쉽게 프로그램을 구현할 수 있는 환경이 제공되도록 자바 8을 설계하기로
결정했다.
- 더불어 자바 8에서 메서드를 값으로 취급할 수 있는 기능은 스트림 같은 다른 자바 8 기능의 토대를 제공했다

#### 메서드 참조(method reference)

- 디렉터리에서 모든 숨겨진 파일을 필터링한다
- 자바 8 이전
```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
        public boolean accept(File file){
            return file.isHidden();
        }
});
```
- File 클래스에는 이미 isHidden 이라는 메서드가 있는데 왜 굳이 FileFilter로 isHidden을 감싼 다음에 FileFilter를 인스턴스화해야 할까?
- 자바 8 이후
```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```
- isHidden이라는 함수는 이미 있으므로 자바 8의 메서드 참조 ::(이 메서드를 값으로 사용하라는 의미)를 이용해서 직접 전달할 수 있다.
- 기존에 비해 문제 자체를 더 직접적으로 설명한다

#### 람다 : 익명 함수

- 자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 람다를 포함하여 함수도 값으로 취급할 수 있다.
- 직접 메서드를 정의해서 메서드 참조 할 수 있으나 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드를 구현할 수 있다.

### 코드 넘겨주기 : 예제

- 모든 녹색 사과를 선택해서 리스트를 반환하는 프로그램을 구현하려 함
- 특정 항목을 선택해서 반환하는 동작을 필터(filter)라고 함
- 자바 8 이전
```java
public static List<Apple> filterGreenApples(List<Apple> inventory){
    List<Apple> result = new ArrayList<>();
    for(Apple apple : inventory){
        if (GREEN.equals(apple.getColor())){
            result.add(apple);
        }
    }
    return result;
}
```
- 다른 필터가 필요하면? 또 작성해야 한다
```java
public static List<Apple> filterHeavyApples(List<Apple> inventory){
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory){
        if (apple.getWeight() > 150){
            result.add(apple);
        }
    }
    return result;
}
```
- 자바 8 이후에는 코드를 인수로 넘겨줄 수 있으므로 filter 메서드를 중복으로 구현할 필요가 없다.
```java
public static boolean isGreenApple(Apple apple){
    return GREEN.equals(apple.getColor());
}

public static boolean isHeavyApple(Apple apple){
    return apple.getWeight() > 150;
}

public interface Predicate<T>{
    boolean test(T t);
}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p){
    List<Apple> result = new ArrayList<>();
    for(Apple apple : inventory){
        if (p.test(apple)){
            result.add(apple);
        }
    }
    return result;
}

filterApples(inventory, Apple:isGreenApple);
filterApples(inventory, Apple:isHeavyApple);
```
- 수학에서는 인수로 값을 받아 true, false를 반환하는 함수를 프레디케이트라고 한다.

### 메서드 전달에서 람다로

- 메서드를 값으로 전달하는 것은 분명 유용한 기능이지만 한두 번만 사용할 메서드를 매번 정의하는 것은 귀찮은 일이다.
- 익명 함수 또는 람다라는 새로운 개념을 이용해서 코드를 구현할 수 있다.
```java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
filterApples(inventory, (Apple a) -> a.getWeight(0 < 80 || RED.equals(a.getColor())));
```
- 한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다.
- 하지만 람다가 몇 줄 이상으로 길어진다면(조금 복잡한 동작을 수행하는 상황) 익명 람다 보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고
메서드 참조를 활용하는 것이 바람직하다. 코드의 명확성이 우선시되어야 한다.
- 멀티코어 CPU가 아니었다면 자바 8 설계자들의 계획은 여기까지였을 것이다.

----------------

## 스트림

- 거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용한다.
- 스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있다.
- 컬렉션에서는 반복 과정을 for-each 루프를 이용해서 각 요소를 반복하면서 작업을 수행한다.
  - 이를 외부 반복(external iteration)이라고 한다.
- 스트림 API를 이용하면 루프를 신경 쓸 필요가 없다. 라이브러리 내부에서 모든 데이터가 처리된다.
  - 이를 내부 반복(internal iteration)이라고 한다.
- 컬렉션을 이용했을 때 많은 요소를 가진 목록을 반복한다면 오랜 시간이 걸릴 수 있으나 최근에는 멀티코어가 많으므로 병렬로 작업하면 빠르게 작업을 처리할 수 있다.

### 멀티스레딩은 어렵다

- 멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 갱신할 수 있다.
- 결과적으로 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있다.
- 멀티스레딩 모델은 순차적인 모델보다 다루기가 어렵다.
- 자바 8은 스트림 API로 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제 그리고 멀티코어 활용 어려움이라는 두 가지 문제를 모두 해결했다.
- 기존의 컬렉션에서는 반복적인 패턴으로 데이터를 처리하는 부분이 많아서 라이브러리에서 제공하면 좋을 것이라는 아이디어가 변화의 동기가 되었다.
  - 주어진 조건에 따라 데이터를 필터링(filtering)
  - 데이터를 추출(extracting)
  - 데이터를 그룹화(grouping)
- 이러한 동작들을 쉽게 병렬화할 수 있다는 점도 변화의 동기가 되었다.
  - 두 CPU를 가진 환경에서 리스트를 필터링할 때 한 CPU는 리스트의 앞부분을 처리하고, 다른 CPU는 리스트의 뒷부분을 처리하도록 요청
  - 이 과정을 포킹 단게(forking step)라고 함
  - 각각의 CPU는 자신이 맡은 절반의 리스트를 처리
  - 마지막으로 하나의 CPU가 두 결과를 정리
- 컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다.

-------------------

## 디폴트 메서드와 자바 모듈

- 요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있는데, 지금까지 자바에서는 특별한 구조가 아닌 평범한 자바 패키지 집합을 포함하는
JAR 파일을 제공하는 것이 전부였다.
- 이러한 패키지의 인터페이스를 바꿔야 하는 상황에서는 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야 했으므로 고통스러운 작업이었다.
- 자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있다.
- 모듈 덕분에 JAR 같은 컴포넌트에 구조를 적용할 수 있으며 문서화와 모듈 확인 작업이 용이해졌다.
- 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다.(디폴트 메서드)
- 디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.
```java
default void sort(Comparator<? supre E> c){
    Collections.sort(this,c);
}
```
- 하나의 클래스에서 여러 인터페이스를 구현할 수 있고 여러 인터페이스에 다중 디폴트 메서드가 존재할 수 있다는 것은 다중 상속이 허용된다는 것은 아니지만
어느 정도는 그렇다라고 말할 수 있다.

-----------------

## 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

- 자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 Optional 클래스를 제공한다.
- Optional는 값을 갖고나 갖지 않을 수 있는 컨테이너 객체다.
- (구조적 structural) 패턴 매칭 기법도 있다.
  - f(0) = 1
  - f(n) = n * f(n-1) 그렇지 않으면
- 자바에서는 if-then-else나 switch문을 이용했을 것이다.

-------------------------

## 마치며

- 언어 생태계에서 모든 언어는 변화해서 살아남거나 그대로 머물면서 사라지게 된다.
- 자바 8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 개념과 기능을 제공한다.
- 함수는 일급값이다.
- 자바 8의 스트림 개념 중 일부는 컬렉션에서 가져온 것이다. 스트림과 컬렉션을 적절하게 활용하면 스트림의 인수를 병렬로 처리할 수 있으며
더 가독성이 좋은 코드를 구현할 수 있다.