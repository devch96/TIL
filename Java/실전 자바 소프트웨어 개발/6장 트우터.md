# 트우터

## 목표

- 큰 그림(전체적 상황)을 서로 다른 작은 아키텍처 문제로 쪼개는 방법
- 테스트 더블(모킹)로 코드베이스의 다른 컴포넌트와의 상호작용을 고립하고 테스트하는 방법
- 요구 상항이 응용프로그램 도메인 코어로 이어지도록 뒤집어 생각하는 방법

## 트우터 요구 사항

- 고유의 사용자 ID와 비밀번호로 트우터에 로그인
- 각 사용자는 자신이 팔로우하는 사용자 집합을 가짐
- 사용자는 트웃을 전송할 수 있으며 로그인한 모든 팔로워는 이 트웃을 바로 볼 수 있음
- 사용자가 로그인하면 최종 로그인한 이후로 게시된 팔로워의 모든 트웃을 볼 수 있음
- 자신의 트웃을 삭제할 수 있고, 팔로워는 삭제된 트웃을 볼 수 없음
- 사용자는 모바일이나 웹사이트로 로그인할 수 있음

## 설계 개요

- 보통 소프트웨어 개발자는 이런 문제를 클라이언트 서버 모델로 해결
  - 데스크톱, 스마트폰으로 트우터를 실행하기 때문에 다양한 환경의 사용자가 통신해야 함
- 클라이언트 그룹은 서비스를 사용하는 그룹
- 서버는 관련 서비스를 제공하는 그룹
- 트웃 서비스의 핵심은 사용자 인터페이스는 서버로 트웃을 전송할 뿐만 아니라 서버로부터 트웃을 받을 수 있어야 함
  - 풀 기반
  - 푸시 기반

### 풀 기반

- 클라이언트가 서버로 정보를 요청함
  - 점대점 또는 요청 응답 통신 형식이라고도 불림
- 클라이언트가 어떤 정보를 로딩할지 결정하는 상황이라면 특히 풀 기반 통신이 유용함

### 푸시 기반

- 리액티브 또는 이벤트 주도 통신이라고도 부름
- 작성자가 방출한 이벤트 스트림을 여러 구독자가 수신함
  - 일대일 통신뿐만 아니라 일대다 통신도 지원함
- 여러 컴포넌트 간에 다양ㅎ나 이벤트의 의사소통이 발생하는 상황에서 특히 유용
  - 주식 시장 거래 프로그램을 설계할 때 다양한 회사의 가격과 틱 정보가 필요할 때마다 요청하는 것이 아닌
  연속적으로 정보가 제공되어야 함
- 트우터에서는 트웃이 스트림을 주를 이루므로 이벤트 주도 통신 형식이 가장 적합함

-------------

## 이벤트에서 설계까지

### 통신

- 프로젝트에 사용할 수 있는 다양한 기술들
  - 웹소켓
    - tcp 스트림으로 양방향 이벤트 통신을 지원한느 가벼운 통신 프로토콜
    - 최신 브라우저에서 지원하는 웹 서버와 웹 브라우저 사이의 이벤트 주도 통신에 주로 사용됨
  - 아마존의 단순 큐 서비스(Simple Queue Service)
    - 호스트된 클라우드 기반 메시지 큐를 메시지 송출이나 수신에 점점 많이 사용함
    - 메시지 큐는 그룹 내의 프로세스 중 한 프로세스가 전송된 메시지를 받아 처리하는 상호 프로세스 통신 방식
    - 호스트된 서비스를 이용하면 안정적인 호스팅을 제공하기 위해 직접 관리하지 않아도 되므로 편리함
  - 메시지 전송이나 메시지 큐를 구현하는 오픈 소스
    - Aeron, ZeroMQ, AMPQ
    - 특정 회사에 의존하지 않는다는 장점이 있느 반면 메시지 큐로 상호작용할 수 있는 클라이언트 선택에 제한이 있을 수 있음
    - 웹 브라우저라면 오픈 소스 구현을 선택하지 않는 것이 좋음

### GUI

- UI 통신 기술이나 UI를 서버의 비즈니스 로직과 결합하면 몇 가지 단점이 발생함
  - 테스트하기 어렵고 테스트 실행도 느려짐
  - 단일 책임 원칙을 위반함
  - 클라이언트가 반드시 UI를 갖는다고 가정함
- 메시징을 코어 비즈니스 로직과 분리할 수 있도록 신중하게 추상화해야 함
  - 클라이언트에게 메시지를 전송하고 클라이언트의 메시지를 수신하는 인터페이스가 필요함

### 영구 저장

- 직접 인덱스하고 검색할 수 있는 일반 텍스트 파일
  - 기록된 데이터를 쉽게 볼 수 있으며 다른 응용프로그램과의 디펜던시를 줄일 수 있음
- 전통적 SQL 데이터베이스
  - 잘 검증된 시스템으로 강력한 질의를 지원함
- NoSQL 데이터베이스
  - 다양한 유스 케이스, 질의 언어, 데이터 저장 모델을 지원하는 여러 데이터베이스

### 육각형 아키텍처

- 포트와 어댑터라 불리는 조금 더 일반화된 아키텍처를 적용
- 응용프로그램의 코어는 우리가 구현하는 비즈니스 로직, 다양한 구현은 코어 로직으로부터 분리되어 있음
- 코어 비즈니스 로직과 분리하려는 특정 기술이 있다면 포트를 이용함
  - 외부 이벤트는 포트를 통해 코어 비즈니스 로직으로 전달됨
- 어댑터는 포트로 연결하는 특정 기술을 이용한 구현 코드

-------------

## 작업 순서

- 먼저 설계를 충분히 고민해야 하지만 코딩 없는 아키텍처는 금방 무너지고 현실과 동떨어진 결가가 되기 쉬움

#### TwootrTest 사용자 로그인 기능 테스트

```java
@Test
void shouldBeAbleToAuthenticateUser() {
    // 유효 사용자의 로그온 메시지 수신
    // 로그온 메서드는 새 엔드포인트 반환
    // 엔드포인트 유효성을 확인하는 어서션
}
```

```java
@Test
void shouldNotAuthenticateUserWithWrongPassword() {
    final Optional<SenderEndPoint> endPoint = twootr.onLogon(
            TestData.USER_ID, "bad password", reveiverEndPoint);
    assertFalse(endPoint.isPresent());
}
```

- TDD는 소프트웨어 설계를 방해한다는 비판을 종종 받는다
  - 테스트 구현에 초점을 맞춘 나머지 빈약한 도메인 모델을 양산하고 어느 시점엔 코드를 다시 구현해야 함
    - 빈약한 도메인 모델이란 비즈니스 로직을 갖지 않으며 다양한 메서드에 절차적 형식으로 흩어져 정의된 도메인 객체

----------

## 팔로워와 트웃

- 소프트웨어 설계를 크게 두 가지 방법으로 접근함
  - 상향식 기법
    - 응용프로그램의 코어 설계에서 시작해 시스템 전체를 만드는 방법
  - 하향식 기법
    - 사용자 요구 사항이나 스토리에서 출발해 기능 개발 후 모델 추가
