# 익명 클래스보다는 람다를 사용하라

- 1997년 JDK 1.1이 등장하면서 함수 객체를 만드는 주요 수단은 익명 클래스가 되었다.

### 익명 클래스의 인스턴스를 함수 객체로 사용 - 낡은 기법!

```java
Collections.sort(words, new Comparator<String>(){
    public int compare(String s1, String s2){
        return Integer.compare(s1.length(), s2.length())
        }
});
```

- 익명 클래스 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않았다.
- 자바 8에 와서 추상 메서드 하나짜리 인터페이스는 특별한 의미를 인정받아 특별한 대우를 받게 되었다.

### 람다식을 함수 객체로 사용 - 익명 클래스 대체

```java
Collections.sort(words,
        (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

- 여기서 람다, 매개변수, 반환값의 타입은 각각 Comparator<String>, String, int 지만 코드에서는 언급이 없다.
- 컴파일러가 타입을 추론한다.
- 이래서 더더욱 제네릭을 사용해야 한다.
- 타입을 명시해야 코드가 더 명확할 때만 제외하고는 람다의 모든 매개변수 타입은 생략하자.

### 람다 자리에 비교자 생성 매서드

```java
Collections.sort(words, comparingInt(String::length));
```

### 자바 8에 추가된 sort 메서드

```java
words.sort(compartingInt(String::length));
```

### 상수별 클래스 몸체는 더 이상 사용하지 않는다?

- 람다가 깔끔하고 편리하지만 메서드나 클래스와 달리 이름이 없고 문서화도 못한다.
- 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
- 람다는 한 줄일 때 가장 좋고 길어야 세 줄 안에 끝내는 게 좋다.

### 람다로 대체할 수 없는 곳

- 람다는 함수형 인터페이스에서만 쓰인다.
- 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니 익명 클래스를 써야한다.
- 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다.
- 람다는 자신을 참조할 수 없다. this 키워드는 바깥 인스턴스를 가리킨다.
- 익명 클래스에서의 this는 익명 클래스의 인스턴스 자신을 가리키기 때문에 함수 객체가 자신을 참조해야 한다면 익명 클래스를 써야 한다.
- 람다를 직렬화하는 일은 극히 삼가야 한다.

## 핵심 정리

- 익명 클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하라.
- 람다는 작은 함수 객체를 아주 쉽게 표현할 수 있어 함수형 프로그래밍의 지평을 열었다.