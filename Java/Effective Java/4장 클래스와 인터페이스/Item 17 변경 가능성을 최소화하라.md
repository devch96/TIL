# 변경 가능성을 최소화하라

- 불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스다.
- 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.
- String, 기본 타입의 박싱된 클래스, BigInteger, BigDemical이 불변 클래스들 중 하나다.
- 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.

## 클래스를 불변으로 만드는 다섯 가지 규칙

1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
   - 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막는다.
   - 클래스를 final로 선언하는 것이지만 다른 방법도 있다.
3. 모든 필드를 final로 선언한다.
   - 시스템이 강제하는 수단을 이용해 설계자의 의도를 드러내는 방법이다.
   - 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장하는 데도 필요하다.
4. 모든 필드를 private으로 선언한다.
   - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막는다.
   - 참조하는 필드를 public final로 선언해도 불변 객체가 되지만 지양해야 하는 일이다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
   - 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.
   - 클라이언트가 제공한 객체 참조를 가리키게 해서는 안 되며, 접근자 메서드가 그 필드를 반대로 반환해서도 안된다.

### 불변 복소수 클래스
```java
public final class Complex{
    private final double re;
    private final double im;
    
    public Complex(double re, double im){
        this.re = re;
        this.im = im;
    }
    
    public double realPart(){
        return re;
    }
    public double imaginaryPart(){
        return im;
    }
    public Complex plus(Complex c){
        return new Complex(re + c.re, im + c.im);
    }
    ...
    
}
```
- 접근자 메서드와 사칙연산 메서드들이 있다.
- 사칙연산 메서드들이 인스턴스 자신은 수정하지 않고 새로운 인스턴스를 만들어 반환한다.
- 이처럼 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 함수형 프로그래밍이라 한다.
- 메서드 이름도 add(동사) 가 아닌 plus(전치사)를 사용한 점도 객체의 값을 변경하지 않는다는 사실을 강조하려는 의도다.

### 불변 객체는 단순하다.

- 불변 객체는 생성된 시점의 상태를 파괴할 때까지 그대로 간직한다.
- 모든 생성자가 클래스 불변식을 보장한다면 그 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않더라도 불변으로 남는다.

### 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.

- 여러 스레드가 동시에 사용해도 절대 훼손되지 않는다.
- 클래스를 스레드 안전하게 만드는 가장 쉬운 방법이다.

### 불변 객체는 안심하고 공유할 수 있다.

- 불변 객체에 대해서는 어떤 스레드도 다른 스레드에 영향을 줄 수 없기 때문이다.
- 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기를 권한다.
- 가장 쉬운 재활용 방법은 자주 쓰이는 값들을 상수로 제공하는 것이다.
```java
public static final Complex ZERO = new Complex(0,0);
public static final Complex ONE = new Complex(1,0);
public static final Complex I = new Complex(0,1);
```
- 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩토리를 제공할 수 있다.
- 새로운 클래스를 설계할 때 public 생성자 대신 정적 팩토리를 만들어두면, 클라이언트를 수정하지 않고도 필요에 따라 캐시 기능을
나중에 덧붙일 수 있다.
- 불변 클래스는 복사해봐야 원본과 똑같으니 복사 자체가 의미가 없기 때문에 clone 메서드나 복사 생성자는 제공하지 않는 게 좋다.

### 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.

- BigInteger 클래스는 내부에서 값이 부호 와 크기를 따로 표현한다.
- 부호에는 int 변수, 크기에는 int[]를 사용한다.
- negate 메서드는 크기가 같고 부호만 반대인 새로운 BigInteger을 사용하는데 배열은 비록 가변이지만 복사하지 않고 원본
인스턴스와 공유해도 된다.
- 그 결과 새로 만든 BigInteger 인스턴스도 원본 인스턴스가 가리키는 내부 배열을 가리킨다.

### 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.

- 불변 객체는 맵의 키와 집합의 원소로 쓰기에 좋다.

### 불변 객체는 그 자체로 실패 원자성을 제공한다.

- 실패 원자성이란 메서드에서 예외가 발생한 후에도 그 객체는 여전히 매서드 호출 전과 똑같은 유효 상태여야 한다라는 뜻이다.
- 불변 객체의 메서드는 내부 상태를 바꾸지 않으니 이 성질을 만족한다.

### 불변 클래스에도 단점은 있다.

- 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.
- 값의 가짓수가 많다면 생성하는데 비용이 많이 든다.

### 클래스가 불변임을 보장하려면 자신을 상속하지 못하게 해야 한다.

- 가장 쉬운 방법은 final 클래스로 선언하는 것.
- 더 유연한 방법은 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩토리를 제공하는 방법
- public이나 protected 생성자가 없으니 다른 클래스에서는 이 클래스를 확장하는 게 불가능하다.

### 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.

- 단순한 값 객체는 항상 불변으로 만들자.

### 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.

- 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.

## 정리

- 클래스는 합당한 이유가 없다면 불변이어야 한다.
- 객체가 최대한 바뀌지 않고, 최대한 드러내지 않는다면 결국 그 객체는 신뢰받는 객체가 될 수 있을 것이다.

