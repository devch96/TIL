# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

### 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.

- 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있다.
- 그런데 마침 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다.
- 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다.
- API 문서의 메서드 설명 끝에서 종종 "Implementation Requirements"로 시작하는 절은 그 메서드의
내부 동작 방식을 설명하는 곳이다.
- 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다.

### 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면

- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.

### 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 `유일`하다.

- 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 드러난다.
- 거꾸로 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않은 protected 멤버는 사실 private이었어야 할 가능성이 크다.
- 이러한 검증은 하위 클래스 3개정도 만들어 보아야 한다. 그 중 하나 이상은 제 3자가 작성해봐야 한다.

### 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

```java
public class Super {
    public Super() {
        overrideMe();
    }

    public void overrideMe() {
    }
}

public final class Sub extends Super {
    private final Instant insant;

    Sub() {
        instant = Instant.now();
    }
    
    @Override
    public void overrideMe(){
        System.out.println(instant);
    }
}
```

- 이 규칙을 어기면 프로그램이 오동작할 것이다.
- 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.
- 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다.
- private, final, static 메서드는 재정의가 불가능하니 생성자에서 호출해도 된다.

## 핵심 정리

- 상속용 클래스를 설계하는 것은 어렵다.
- 따라서 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 낫다.
- 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.