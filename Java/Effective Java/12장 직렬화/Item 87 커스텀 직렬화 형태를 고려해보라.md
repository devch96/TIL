# 커스텀 직렬화 형태를 고려해보라

- 클래스가 Serializable을 구현하고 기본 직렬화 형태를 사용한다면 다음 릴리스 때 버리려 한 현재의 구현에
영훤히 발을 묶이게 된 것이다.
- 실제로도 BigInteger 같은 일부 자바 클래스가 이 문제에 시달리고 있다.

### 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라.

- 기본 직렬화 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해라.
- 커스텀 직렬화를 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다.

### 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.

```java
public class Name implements Serializable{
    private final String lastName;
    private final String firstName;
    private final String middleName;
}
```
- 이름은 논리적으로 이름, 성, 중간이름이라는 3개의 문자열로 구성되며 앞 코드의 인스턴스 필드들은 이 논리적 구성요소를 정확히 반영했다.

### 기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.

### 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 생기는 문제점

1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
   - 다음 릴리스에서 내부 표현 방식을 바꾸더라도 이전으로 표현된 입력 처리도 할 수 있어야 한다.
2. 너무 많은 공간을 차지할 수 있다.
   - 직렬화 형태가 너무 커져서 디스크에 저장하거나 네트워크로 전송하는 속도가 느려질 수 있다.
3. 시간이 너무 많이 걸릴 수 있다.
   - 객체 그래프의 위상에 관한 정보가 없으니 그래프를 직접 순회해볼 수 밖에 없다.
4. 스택 오버플로를 일으킬 수 있다.
   - 객체 그래프를 재귀 순환하는데 자칫 스택오버플로를 일으킬 수 있다.

### 기본 직렬화를 수용하든 하지 않든 defaultWriteObject 메서드를 호출하면 transient로 선언하지 않은 모든 인스턴스 필드가 직렬화된다.

- 따라서 transient로 선언해도 되는 인스턴스 필드에는 모두 transient 한정자를 붙여야 한다.
- 해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야 한다.

### 기본 직렬화 사용 여부와 상관없이 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.

### 어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.

- 직렬 버전 UID가 일으키는 잠재적인 호환성 문제가 사라진다.
- 직렬 버전 UID를 명시하지 않으면 런타임에 이 값을 생성하느라 복잡한 연산을 수행하기 때문에 명시하면 성능도 조금 빨라진다.

### 구버전으로 직렬화된 인스턴스들과 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하지 말자.

## 핵심 정리

- 클래스를 직렬화하기로 했다면 어떤 직렬화 형태를 사용할지 심사숙고 해야 한다.
- 잘못된 직렬화 형태를 선택하면 해당 클래스의 복잡성과 성능에 영구히 부정적인 영향을 남긴다.