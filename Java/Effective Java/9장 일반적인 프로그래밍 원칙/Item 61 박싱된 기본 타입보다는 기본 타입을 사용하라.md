# 박싱된 기본 타입보다는 기본 타입을 사용하라

- 자바의 데이터 타입은 크게 기본 타입과 참조 타입으로 나눌 수 있다.
- 그리고 각각의 기본 타입에 대응하는 참조 타입이 하나씩 있으며 이를 박싱된 기본 타입이라 한다.
  - Integer, Double, Boolean ...

- 오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만 차이가 사라지는 것은 아니다.
- 둘 사이에는 분명한 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다.

### 기본 타입과 박싱된 기본 타입의 차이점

1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다.
   - 박싱된 기본 타입은 두 인스턴스의 값이 같아도 서로 다르다고 식별될 수 있다.

2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값(null)을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

### 박싱된 기본 타입의 문제점

```java
Comparator<Integer> naturalOrder =
        (i, j) -> (i < j) ? -1 : (i==j ? 0 : 1);

naturalOrder.compare(new Integer(42), new Integer(42)); // expected 0 but 1
```

- 첫번째 연산 (i < j) 는 오토언박싱으로 계산이 잘 작동한다.
- 하지만 두번째 연산에서 (i == j) 첫 번째 인스턴스와 두 번째 인스턴스는 같은 인스턴스가 아니므로 1이 반환된다.
- 같은 객체를 비교하는 게 아니라면 박싱된 기본 타입에 == 연산자를 사용하면 오류가 난다.
- 이 문제를 고치려면 언박싱을 미리 해서 식별성 검사를 막아야 한다.
```java
Comparator<Integer> naturalOrder =(iBoxed, jBoxed) -> {
        int i = iBoxed, j = jBoxed;
        return i < j ? -1 : (i==j ? 0 : 1);
        }
        
naturalOrder.compare(new Integer(42), new Integer(42));
```

### 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 거의 예외없이 자동으로 풀린다.

```java
public class Unbelievable{
    static Integer i;

    public static void main(String[] args) {
        if (i==42){
            ...
        }
    }
}
```

- i 를 초기화하지 않았기 때문에 다른 참조 타입 필드와 마찬가지로 null이 초기값이라 NPE가 던져진다.

### 반복문에서 사용하면 성능이 엄청 안좋아진다.

```java
public static void main(String[]args){
        Long sum = 0L
        for(long i = 0; i <= Integer.MAX_VALUE; i++){
            sum+=i;
        }
}
```
- long 타입인 i 가 Long 타입인 sum 에 더해질 때마다 Long 인스턴스가 만들어진다.

### 박싱된 기본 타입은 언제 써야 하나?

1. 컬렉션의 원소, 키, 값 으로 쓴다.
   - 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야한다.
2. 매개변수화 타입이나 매개변수화 메서드, 타입 매개변수로는 박싱된 기본 타입을 써야 한다.
3. 리플렉션을 통해 메서드를 호출할 때 써야 한다.

## 핵심 정리

- 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.
- 언박싱 과정에서 NPE를 던질 수 있다.
- 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.
