# 적시에 방어적 복사본을 만들라

- 자바는 네이티브 메서드를 사용하지 않으니 C, C++ 에서 보이는 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌
오류에서 안전하다.
- 하지만 아무리 자바라 해도 다른 클래스로부터의 침범을 아무런 노력 없이 다 막을 수 있는 건 아니다.

### 클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍 해야 한다.

- 악의적인 의도를 가진 사람들이 시스템의 보안을 뚫으려 할 수도 있다.
- 평범한 프로그래머도 순전히 실수로 오작동하게 만들 수 있다.
- 어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하지만, 주의를 기울이지 않으면 자기도 모르게
내부 수정을 허락하는 경우가 생긴다.

### 기간을 표현하는 클래스 - 불변식을 지키지 못함

```java
public final class Period{
    private final Date start;
    private final Date end;
    
    public Period(Date start, Date end){
        if(start.compareTo(end) > 0){
            throw new IllegalArgumentException(
                    start + " after " + end;
            )
        }
        this.start = start;
        this.end = end;
    }
    
    public Date start(){
        return start;
    }
    
    public Date end(){
        return end;
    }
}
```

### Period 인스턴스 내부 공격

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p의 내부가 수정됨.
```

- Date 대신 불변인 Instant를 사용하면 된다.(혹은 LocalDateTime이나 ZonedDateTime)

### 외부 공격으로부터 인스턴스 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.

```java
public Period(Date start, Date end){
    this.start=new Date(start.getTime());
    this.end=new Date(end.getTime());
    if(this.start.compareTo(this.end)>0){
        ...
    }
}
```

- 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고 이 복사본으로 유효성을 검사했다.
- 순서가 부자연스러워 보이지만 이렇게 해야한다.
- 이유는 멀티스레딩 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가
원본 객체를 수정할 위험이 있기 때문이다.
- 방어적 복사를 유효성 검사 전에 수행하면 이런 위험에서 해방될 수 있다.
- 컴퓨터 보안에서 이를 검사시점/사용시점 공격이라 한다(TOCTOU: Time-Of-Check/Time-Of-Use)
- Date는 final이 아니므로 clone이 Date가 정의한 게 아닐 수도 있기 때문에 clone을 사용하지 않는다.
- 매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.

### 접근자 메서드가 내부의 가변 정보를 직접 드러내면 안 된다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
p.end().setYear(78);
```

### 가변 필드의 방어적 복사본을 반환하면 된다.

```java
public Date start(){
    return new Date(start.getTime());
}

public Date end(){
    return new Date(end.getTime());
}
```

- 생성자와 달리 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다.
- Period가 가지고 있는 Date 객체는 확실한 Date 객체이기 때문이다.
- 하지만 인스턴스를 복사하는 데는 일반적으로 생성자나 정적 팩터리를 쓰는 게 좋다.

### 매개변수를 방어적으로 복사하는 목적이 불변 객체를 만들기 위해서만은 아니다.

- 매서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로
변경될 수 있는지를 생각해 봐야 한다.
- 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지를 따져봐야 한다.
- 확신할 수 없다면 복사본을 만들어서 저장해야 한다.
- 예를들어 클라이언트가 건네준 객체를 내부의 Set 혹은 Map의 키로 사용한다면 추후 그 객체가 변경될 때 Set 혹은 Map의 불변식이 깨질 수 있다.
- 내부 객체를 클라이언트에 건네주기 전에 방어적 복사본을 만드는 이유도 마찬가지 이다.

### 방어적 복사에는 성능 저하가 따르고, 또 항상 쓸 수 있는 것도 아니다.

- 호출자가 컴포넌트 내부를 수정하지 않으리라 확신하면 방어적 복사를 생략할 수 있다.
- 이러한 상황이라도 호출자에서 해당 매개변수나 반환값을 수정하지 말아야 함을 명확히 문서화하는 게 좋다.
- 또한 메서드나 생성자의 매개변수로 넘기는 행위가 그 객체의 통제권을 명백히 이전함을 뜻하는 경우도 있다.
- 통제권을 넘겨받기로 한 메서드나 생성자를 가진 클래스들은 악의적인 클라이언트의 공격에 취약하기 때문에
해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때, 혹은 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때로 한정해야 한다.
  - 래퍼 클래스의 특성상 클라이언트는 래퍼에 넘긴 객체에 여전히 접근할 수 있어 래퍼 클래스의 불변식을 쉽게 파괴할 수 있지만 그 영향은
  오직 클라이언트 자신만 받는다.

## 핵심 정리

- 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
- 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의
책임이 클라이언트에 있음을 문서에 명시하도록 하자.
