# 주니어 자바 개발자를 위한 100가지 질문

1. 기초

    - 📌 JDK와 JRE의 차이점은 무엇입니까?
        
        
        JRE(Java Runtime Environment)는 자바 실행 환경이다. JVM 뿐만 아니라 Java binaries, Java 클래스 라이브러리 등을 포함하고 있어 자바 프로그램의 실행을 지원한다. 하지만 컴파일러나 디버거등의 도구는 포함하지 않는다. 따라서 자바 프로그램을 개발하는 것이 아니라 실행하기만 원한다면 JRE를 설치하면 된다.
        
        JDK(Java Development Kit)는 자바 개발 키드이다. JDK는 자바 애플리케이션을 개발하기 위한 환경을 지원한다. JDK는 JRE를 포함할 뿐만 아니라 컴파일러(javac), javadoc, jar 등 개발에 유용한 도구들을 포함하고 있다. 따라서 자바 프로그램을 개발하기 위해서는 JDK를 다운로드 하여야 한다.
        
        JRE는 자바 실행환경, JDK 는 자바 개발 도구
        
        [https://code-lab1.tistory.com/253](https://code-lab1.tistory.com/253)
        
    - 📌 ==와 equals의 차이점은 무엇입니까?
        
        
        String변수를 생성할때는 두 가지 방법이 있다.
        
        1. 리터럴(literal)을 이용한 방식
        String str1 = “apple”;
        2. new 연산자를 이용한 방식
        String str2 = new String(”banana”);
        
        == 는 객체가 같은지를 비교하지만 객체가 갖고 있는 문자열을 비교하지 않는다.
        
        == 연산자의 경우 참조 타입 변수들 간의 연산은 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다.
        
        equals매서드는 두 비교대상의 주소 값이 아닌 데이터값을 비교하기 때문에 어떻게 String을 생성하느냐에 따라 결과가 달라지지 않고 정확한 비교를 할 수 있다.
        
        compareTo() 매서드는 두개의 문자열을 비교한다. 동일한지의 여부만 확인할 수 있는 equals와 다르게 어떤 문자가 사전적인 순서로 앞에 있는지도 리턴해준다. 따라서 compareTo()를 이용하면 리스트를 오름차순으로 정렬하거나 내림차순으로 정렬할 수 있다. 리턴 값은 0, 음수, 양수의 int가 리턴되며 0 은 두개의 문자열이 동일, 양수는 호출하는 객체가 인자보다 사전적으로 순서가 앞설 때, 음수는 인자가 객체보다 사전적으로 순서가 앞설 때 이다.
        
        [https://sudo-minz.tistory.com/93](https://sudo-minz.tistory.com/93)
        
    - 📌 두 객체가 동일한 hashCode를 가지면 Equals()가 참이어야 합니다, 그렇죠?
        
        
        아니다. 두 객체의 해시 코드가 같다고 해서 두 객체가 동일하다는 보장은 없다. 해시 충돌이 발생할 수 있기 때문이다. 해시 충돌이란 서로 다른 두 객체가 동일한 해시 코드를 가지는 상황을 말한다. 따라서 두 객체의 동등성을 판단하려면 해시 코드뿐만 아니라 equals() 메서드를 사용하여 비교해야 한다.
        
    - 📌 자바에서 final의 기능은 무엇입니까?
        
        
        Java에서 `final` 키워드는 변수, 메서드, 클래스에 적용될 수 있으며, 각각의 경우에 다른 의미와 동작을 가집니다.
        
        1. 변수에 적용된 `final`: `final`로 선언된 변수는 상수(constant)로 취급되어, 한 번 초기화되면 값을 변경할 수 없습니다. `final` 변수는 선언 시 직접 초기화하거나 생성자를 통해 초기화해야 합니다. 메서드나 블록 내에서 재할당이나 수정이 불가능하므로, 값이 변하지 않는 상수 값을 표현할 때 사용됩니다.
            
            ```java
            final int x = 10; // 변수 x는 상수로, 한 번 초기화되면 값이 변경될 수 없음
            
            ```
            
        2. 메서드에 적용된 `final`: `final`로 선언된 메서드는 하위 클래스에서 오버라이딩(재정의)할 수 없습니다. 이를 통해 메서드의 구현을 불변하게 만들어, 오버라이딩에 의한 변경을 방지할 수 있습니다. 주로 상속 관계에서 부모 클래스의 기능을 보호하고자 할 때 사용됩니다.
            
            ```java
            class Parent {
                final void printMessage() {
                    System.out.println("This is a final method.");
                }
            }
            class Child extends Parent {
                // 아래의 오버라이딩 시도는 컴파일 오류 발생
                // final 메서드는 오버라이딩할 수 없음
                // void printMessage() { }
            }
            
            ```
            
        3. 클래스에 적용된 `final`: `final`로 선언된 클래스는 다른 클래스에서 상속받을 수 없습니다. 이는 클래스를 확장하지 못하도록 제한하여, 클래스의 기능과 구현을 변경할 수 없게 합니다. `final` 클래스는 보안, 불변성, 성능 등 특정 목적을 위해 사용됩니다.
            
            ```java
            final class FinalClass {
                // final 클래스는 상속할 수 없음
            }
            // 아래의 상속 시도는 컴파일 오류 발생
            // final 클래스는 상속받을 수 없음
            // class SubClass extends FinalClass { }
            
            ```
            
        
        `final` 키워드는 코드의 안정성과 안정성을 강화하고, 의도적인 변경을 방지하는 데 사용됩니다. 주의할 점은, `final`로 선언된 요소의 변경이 제한되지만, 내부 객체의 상태가 변경될 수 있다는 점입니다. 즉, `fina`로 선언된 변수가 가리키는 객체의 상태는 변경될 수 있습니다.
        
    - 📌 자바에서 Math.round(-1.5)는 무엇을 의미합니까?
        
        **`Math.round(-1.5)`**는 -1.5를 반올림하여 가장 가까운 정수로 변환하는데, 여기서 가장 가까운 정수는 -1입니다. 따라서 **`Math.round(-1.5)`**의 결과는 -1이 됩니다.
        
    - 📌 String은 기본 데이터 타입입니까?
        
        
        Java에서 **`String`**은 기본 데이터 타입(primitive data type)이 아니라 참조 타입(reference type)입니다.
        
        기본 데이터 타입에는 **`int`**, **`double`**, **`boolean`**, **`char`** 등이 있으며, 이러한 데이터 타입은 메모리에 직접 값을 저장합니다. 반면에 **`String`**은 문자열을 나타내는 참조 타입으로, 문자열 데이터를 다룰 때 사용됩니다. **`String`**은 객체로 취급되며, 힙(heap) 메모리에 저장되고 해당 객체에 대한 참조를 가리키는 변수가 생성됩니다.
        
        따라서, Java에서 **`String`**은 기본 데이터 타입이 아니라 참조 타입으로 분류됩니다.
        
    - 📌 자바에서 문자열을 조작하는 클래스는 무엇이 있습니까? 각 클래스의 차이점은 뭘까요?
        
        
        Java에서 문자열을 조작하는 클래스는 여러 가지가 있습니다. 주요한 클래스는 다음과 같습니다:
        
        1. `String`: `String` 클래스는 변경할 수 없는(immutable) 문자열을 나타내는데 사용됩니다. 문자열을 생성한 후에는 해당 문자열을 변경할 수 없으며, 문자열 조작 작업 시 새로운 문자열 객체가 생성됩니다.
        2. `StringBuilder`: `StringBuilder` 클래스는 가변(mutable) 문자열을 조작하는데 사용됩니다. `StringBuilder`는 문자열을 변경할 수 있는 메서드를 제공하며, 동일한 객체 내에서 문자열 조작 작업이 이루어집니다. 문자열 조작이 빈번하게 발생하는 상황에서 성능이 더 좋을 수 있습니다.
        3. `StringBuffer`: `StringBuffer` 클래스는 `StringBuilder`와 기능적으로 동일하며, 동기화(synchronization)를 지원하는 차이점이 있습니다. 따라서 멀티스레드 환경에서 안전하게 사용할 수 있습니다.
        
        차이점:
        
        - `String` 클래스는 변경할 수 없는(immutable) 문자열을 다루며, `StringBuilder`와 `StringBuffer`는 변경 가능한(mutable) 문자열을 다룹니다.
        - `StringBuilder`와 `StringBuffer`는 동일한 기능을 제공하지만, `StringBuffer`는 동기화를 지원하여 멀티스레드 환경에서 안전하게 사용할 수 있습니다.
        - `String` 클래스는 문자열 조작 작업마다 새로운 문자열 객체를 생성하므로, 문자열 조작이 빈번한 경우에는 성능 저하가 발생할 수 있습니다. 반면에 `StringBuilder`와 `StringBuffer`는 기존 객체를 변경하므로 성능상 이점이 있을 수 있습니다. 따라서, 문자열 조작이 자주 발생하는 경우에는 `StringBuilder` 또는 `StringBuffer`를 사용하는 것이 좋습니다.
        
    - 📌 String str ="i"와 String str = new String("i")가 동일합니까?
        
        `String str = "i"`와 `String str = new String("i")`는 동일하지 않습니다.
        
        1. `String str = "i"`: 이 구문은 문자열 리터럴("i")을 사용하여 `str` 변수에 문자열을 할당합니다. Java에서 문자열 리터럴은 내부적으로 `String` 객체로 처리됩니다. 따라서, 이 구문은 문자열 리터럴 "i"에 대한 새로운 `String` 객체를 생성하지 않고, 이미 존재하는 문자열 풀(string pool)에서 해당 문자열을 참조합니다.
        2. `String str = new String("i")`: 이 구문은 `new` 키워드를 사용하여 `String` 객체를 명시적으로 생성합니다. `"i"` 문자열을 가진 새로운 `String` 객체를 생성하고, `str` 변수에 할당합니다. 이 경우에는 새로운 `String` 객체가 생성되며, 문자열 리터럴이 아니라 동적으로 `String` 객체를 생성합니다..

    - 📌 문자열을 반전시키는 가장 좋은 방법은 무엇인가요?
        
        
        문자열을 반전시키는 가장 좋은 방법은 다음과 같습니다:
        
        1. `StringBuilder` 또는 `StringBuffer` 사용: `StringBuilder` 또는 `StringBuffer` 클래스를 사용하여 문자열을 반전시킬 수 있습니다. 이들 클래스는 가변(mutable)한 문자열을 다루는데 최적화되어 있으므로 문자열을 효율적으로 조작할 수 있습니다. `reverse()` 메서드를 사용하여 문자열을 반전시킬 수 있습니다.
            
            예시:
            
            ```java
            String str = "Hello, World!";
            StringBuilder reversed = new StringBuilder(str).reverse();
            String result = reversed.toString();
            System.out.println(result); // 출력: !dlroW ,olleH
            
            ```
            
        2. 문자열을 문자 배열로 변환 후 반전: 문자열을 문자 배열로 변환한 후에 배열을 반전시키는 방법도 있습니다. 이후 문자 배열을 다시 문자열로 변환할 수 있습니다.
            
            예시:
            
            ```java
            String str = "Hello, World!";
            char[] charArray = str.toCharArray();
            int left = 0;
            int right = charArray.length - 1;
            while (left < right) {
                char temp = charArray[left];
                charArray[left] = charArray[right];
                charArray[right] = temp;
                left++;
                right--;
            }
            String result = new String(charArray);
            System.out.println(result); // 출력: !dlroW ,olleH
            
            ```
            
        
        두 가지 방법 모두 문자열을 반전시키는데 사용할 수 있으며, `StringBuilder` 또는 `StringBuffer`를 사용하는 방법이 좀 더 간단하고 성능적으로 효율적일 수 있습니다.
        
    - 📌 String 클래스의 일반적인 메서드는 무엇이 있나요?
        
        
        String 클래스는 Java 프로그래밍 언어에서 가장 기본적이고 널리 사용되는 클래스 중 하나입니다. String 클래스에는 다양한 메서드가 있으며, 일반적으로 사용되는 몇 가지 메서드는 다음과 같습니다:
        
        1. length(): 문자열의 길이를 반환합니다.
        2. charAt(int index): 주어진 인덱스에 해당하는 문자를 반환합니다.
        3. substring(int beginIndex): 주어진 인덱스부터 문자열의 끝까지의 부분 문자열을 반환합니다.
        4. substring(int beginIndex, int endIndex): 주어진 범위에 해당하는 부분 문자열을 반환합니다.
        5. concat(String str): 주어진 문자열을 현재 문자열에 연결하여 새로운 문자열을 반환합니다.
        6. equals(Object obj): 주어진 객체와 현재 문자열을 비교하여 같으면 true를 반환합니다.
        7. isEmpty(): 문자열이 비어 있는지 여부를 확인합니다.
        8. toLowerCase(): 문자열의 모든 문자를 소문자로 변환한 새로운 문자열을 반환합니다.
        9. toUpperCase(): 문자열의 모든 문자를 대문자로 변환한 새로운 문자열을 반환합니다.
        10. trim(): 문자열의 앞뒤 공백을 제거한 새로운 문자열을 반환합니다.
        11. indexOf(int ch): 주어진 문자 또는 문자의 인덱스를 반환합니다.
        12. replace(char oldChar, char newChar): 주어진 문자열 내의 모든 oldChar를 newChar로 대체한 새로운 문자열을 반환합니다.
        13. split(String regex): 주어진 정규 표현식을 기준으로 문자열을 분할하여 문자열 배열로 반환합니다.
        14. startsWith(String prefix): 주어진 접두사로 시작하는지 여부를 확인합니다.
        15. endsWith(String suffix): 주어진 접미사로 끝나는지 여부를 확인합니다.
        
        이 외에도 다양한 메서드가 있으며, String 클래스는 불변(immutable) 클래스이므로 문자열을 수정하는 메서드는 원래의 문자열을 변경하는 대신 새로운 문자열을 반환합니다.
        
    - 📌 추상 클래스에서 추상 메서드는 필수적인가요?
        
        
        추상 클래스는 무조건 추상 메서드를 가져야 할 필요는 없습니다. 추상 클래스는 일반 메서드와 함께 추상 메서드를 가질 수 있습니다. 따라서 추상 클래스는 다음과 같은 경우에 사용될 수 있습니다:
        
        1. 추상 메서드를 가지는 경우: 추상 클래스가 추상 메서드를 가지는 경우, 이 추상 메서드는 하위 클래스에서 반드시 구현되어야 합니다. 추상 클래스를 상속받는 하위 클래스는 추상 메서드를 구현해야만 인스턴스화될 수 있습니다.
        2. 추상 메서드가 없는 경우: 추상 클래스가 추상 메서드를 가지지 않는 경우에는 하위 클래스에서 메서드 구현이 필요하지 않습니다. 하지만 추상 클래스로 선언된 경우, 해당 추상 클래스를 직접 인스턴스화할 수 없습니다. 대신, 추상 클래스를 상속받는 하위 클래스를 통해 인스턴스화해야 합니다.
        
        추상 클래스는 다른 클래스에게 공통적인 기능을 제공하고, 하위 클래스에게 특정 동작을 구현하도록 유도하는 역할을 할 수 있습니다. 추상 클래스는 인스턴스화될 필요가 없거나, 인스턴스화되어도 추상 클래스의 일반 메서드를 활용하기 위해 사용될 수 있습니다.
        
    - 📌 보통의 클래스와 추상 클래스의 차이는 무엇인가요?
        
        
        보통의 클래스와 추상 클래스의 주요 차이점은 다음과 같습니다:
        
        1. 인스턴스화 가능 여부: 보통의 클래스는 직접 인스턴스화할 수 있습니다. 즉, 해당 클래스의 객체를 생성하여 사용할 수 있습니다. 추상 클래스는 추상 메서드를 가지는 경우에는 직접 인스턴스화할 수 없으며, 추상 클래스를 상속받는 하위 클래스를 통해 인스턴스화해야 합니다.
        2. 추상 메서드 포함 여부: 보통의 클래스는 추상 메서드를 가질 수 없습니다. 모든 메서드는 구현되어 있어야 합니다. 추상 클래스는 추상 메서드를 포함할 수 있습니다. 추상 메서드는 메서드의 시그니처만을 정의하고 구현 내용은 제공하지 않습니다. 추상 클래스는 하위 클래스에서 이러한 추상 메서드를 반드시 구현해야 합니다.
        3. 상속 목적: 보통의 클래스는 다른 클래스에서 상속받아 사용될 수 있습니다. 보통의 클래스의 주요 목적은 코드 재사용과 확장성을 위해 상속 계층을 형성하는 것입니다. 추상 클래스는 보통의 클래스와 마찬가지로 다른 클래스에서 상속받을 수 있지만, 주로 하위 클래스에서 공통된 기능과 동작을 정의하기 위해 사용됩니다. 추상 클래스는 일부 메서드를 구현하지 않고 남겨두는 추상 메서드를 포함하여 하위 클래스에서 메서드 구현을 강제화할 수 있습니다.
        4. 인스턴스 변수 및 일반 메서드: 보통의 클래스와 추상 클래스 모두 인스턴스 변수와 일반 메서드를 가질 수 있습니다. 인스턴스 변수는 객체의 상태를 저장하고, 일반 메서드는 객체의 동작을 정의합니다. 이러한 면에서 보통의 클래스와 추상 클래스는 유사합니다.
        
        요약하자면, 추상 클래스는 하위 클래스에서 공통된 기능을 정의하고, 추상 메서드를 통해 하위 클래스에서 메서드 구현을 강제화하는 용도로 사용됩니다. 반면에 보통의 클래스는 주로 객체의 상태와 동작을 정의하고, 인스턴스화하여 사용하는 일반적인 클래스입니다.
        
    - 📌 final은 추상 클래스를 수정할 때 사용할 수 있나요?
        
        
        `final` 키워드는 클래스, 메서드 또는 변수를 수정할 수 없도록 지정하는 데 사용됩니다.
        
        추상 클래스에 `final` 키워드를 사용하는 것은 일반적으로 권장되지 않습니다. 추상 클래스는 상속을 통해 확장하고 기능을 추가하기 위해 설계되기 때문에, `final`을 사용하여 수정을 금지하는 것은 상속 및 확장의 목적에 어긋날 수 있습니다.
        
        추상 클래스는 하위 클래스에서 추상 메서드를 구현하고 추가적인 동작을 제공하기 위해 사용됩니다. `final` 키워드를 사용하면 하위 클래스에서 해당 추상 클래스를 상속받아 사용할 수 없게 됩니다. 따라서, 추상 클래스를 수정할 수 없도록 하려면 `final` 키워드를 사용하는 대신 클래스 내부의 메서드나 변수에 `final` 키워드를 사용하여 특정 메서드나 변수의 재정의나 재할당을 막을 수 있습니다.
        
        즉, 추상 클래스를 수정할 때 `final` 키워드를 사용하는 것은 일반적으로 권장되지 않으며, 주로 클래스의 특정 메서드나 변수에 적용되어 재정의나 재할당을 막는 데 사용됩니다.
        