3. Multi-Threading

<br><br>
    - 📌 병렬과 동시성의 차이점을 말해주세요.
<br><br>
  
        병렬성(Parallelism)과 동시성(Concurrency)은 컴퓨터 프로그래밍에서 다른 개념을 나타냅니다.

        병렬성은 여러 작업을 동시에 실행하여 전체 작업을 가속화하는 것을 의미합니다. 이는 여러 개의 실행 스레드 또는 프로세스를 동시에 실행하여 각각의 작업을 병렬로 처리하는 것을 말합니다. 병렬성은 물리적인 하드웨어적인 측면에서 동작하며, 여러 개의 CPU 코어 또는 다중 처리 장치를 이용하여 작업을 분산 처리합니다. 병렬 실행은 동시에 실행되는 작업들이 서로 영향을 주지 않고 독립적으로 실행되는 것을 목표로 합니다.

        동시성은 동시에 여러 작업이 진행되는 것을 나타냅니다. 이는 작업을 작은 단위로 나누어 번갈아 가면서 실행하는 것을 말합니다. 여러 개의 스레드가 하나의 CPU 코어 또는 다중 처리 장치에서 번갈아가며 실행되는 것을 통해 동시성을 구현합니다. 동시성은 주로 I/O 작업이나 작업 간 상호작용이 필요한 경우에 유용합니다. 동시성은 병렬성과 달리 여러 작업들이 동시에 진행되는 것처럼 보이지만, 실제로는 작업을 작은 단위로 번갈아가면서 실행합니다.

        간단히 말하자면, 병렬성은 작업을 물리적으로 동시에 실행하여 성능 향상을 이끌어내는 것이고, 동시성은 작업을 논리적으로 동시에 실행하여 작업 간 상호작용과 응답성을 개선하는 것입니다.

<br><br>       
    - 📌 스레드와 프로세스의 차이를 말해주세요.
<br><br>

        스레드(Thread)와 프로세스(Process)는 컴퓨터에서 동시에 실행되는 실행 단위를 나타내는 용어입니다. 그러나 스레드와 프로세스는 몇 가지 중요한 차이점이 있습니다.

        프로세스(Process)는 운영체제로부터 자원을 할당받아 실행 중인 프로그램을 의미합니다. 각 프로세스는 독립된 메모리 공간을 가지고 실행되며, 각각의 프로세스는 별도의 주소 공간에서 실행되는 독립된 인스턴스입니다. 이는 프로세스 간에 데이터를 공유하기 위해서는 명시적인 IPC(Inter-Process Communication) 메커니즘을 사용해야 한다는 것을 의미합니다. 또한, 각 프로세스는 최소한 하나의 스레드(메인 스레드)를 가지고 있습니다.

        스레드(Thread)는 프로세스 내에서 실행되는 경량화된 실행 단위입니다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다. 스레드는 같은 프로세스 내에서 동시에 실행되며, 해당 프로세스의 주소 공간을 공유합니다. 따라서 스레드 간에 데이터를 공유하는 것이 비교적 간단하고 효율적입니다. 스레드는 프로세스 내의 코드 실행 흐름을 나타내는데, 동일한 프로세스 내에서 스레드 간에는 코드와 자원을 공유하여 작업을 동시에 수행할 수 있습니다. 그러나 스레드 간에는 동기화와 같은 문제를 고려해야 하며, 스레드 간의 경쟁 상태(Race Condition)와 같은 문제가 발생할 수 있습니다.

        스레드는 경량화되어 있기 때문에 프로세스보다 작은 자원을 사용하며, 스레드 간의 전환은 빠릅니다. 따라서 여러 작업을 동시에 처리하고 응답성을 개선하기 위해 스레드를 사용하는 것이 일반적입니다. 프로세스는 더 큰 단위로 자원을 할당받기 때문에 더 많은 오버헤드가 발생하며, 각각의 프로세스는 독립된 주소 공간에서 실행되므로 상대적으로 더 격리되어 있습니다.

        요약하자면, 프로세스는 실행 중인 프로그램을 나타내는 독립된 인스턴스로서 메모리 공간과 자원을 할당받으며, 스레드는 프로세스 내에서 동시에 실행되는 경량화된 실행 단위로서 프로세스의 주소 공간을 공유합니다. 스레드는 프로세스의 자원을 공유하므로 작업을 동시에 처리할 수 있고, 응답성을 개선할 수 있습니다.

<br><br>
    - 📌 데몬 스레드는 무엇인가요?
<br><br>

        데몬 스레드(Daemon Thred)는 백그라운드에서 실행되는 스레드로, 주 스레드(main 스레드)의 작업을 보조하거나 지원하는 역할을 합니다. 데몬 스레드는 일반 스레드와는 다르게 백그라운드에서 실행되는 동안 프로그램이 종료될 때 자동으로 종료되는 특징을 갖고 있습니다.

        데몬 스레드는 일반 스레드와는 다르게 운영체제에서 프로그램이 종료될 때 까지 실행되어야 하는 작업을 처리하기 위해 사용됩니다. 예를 들어, 가비지 컬렉션(Garage Collection) 스레드는 대표적인 데몬 스레드입니다. 가비지 컬렉션은 프로그램에서 더이상 사용되지 않는 메모리를 자동으로 회수하는 작업을 수행하는데, 이 작업은 주 스레드의 작업을 보조하면서 프로그램이 종료될 때까지 계속 실행되어야 합니다.

        데몬 스레드를 생성하려면 `setDaemon(true)` 메서드를 사용하면 됩니다. `setDaemon(true)`를 호출하여 스레드를 데몬 스레드로 설정하면, 해당 스레드는 현재 스레드(일반 스레드)의 하위 스레드로 생성됩니다. 데몬 스레드는 일반 스레드가 종료되면 자동으로 종료되므로, 주 스레드가 종료되면 모든 데몬 스레드도 함께 종료됩니다.

        데몬 스레드는 보조적인 작업을 처리하는 데 유용하며, 주 스레드의 작업을 지원하는 역할을 합니다. 그러나 데몬 스레드는 자원을 정리하거나 데이터를 저장하는 등의 종료 작업을 수행하지 않으므로, 중요한 작업이나 자원을 사용하는 작업에는 사용되지 않습니다.

<br><br>
    - 📌 스레드를 만드는 방법을 나열해주세요.
<br><br>

        스레드(Thread)를 생성하는 방법은 여러 가지가 있습니다. Java에서 스레드를 만들기 위한 주요한 방법들을 아래에 나열하였습니다:

        1. Thread 클래스 상속: Thread 클래스를 상속받은 사용자 정의 클래스를 만들고, 해당 클래스에서 run() 메서드를 오버라이딩하여 스레드가 실행할 작업을 구현합니다. 그리고 생성한 클래스의 인스턴스를 생성하여 start() 메서드를 호출하여 스레드를 시작합니다.

            ```java
            class MyThread extends Thread {
                public void run() {
                    // 스레드가 실행할 작업 구현
                }
            }

            // 스레드 인스턴스 생성 및 시작
            MyThread thread = new MyThread();
            thread.start();
            ```

        2. Runnable 인터페이스 구현: Runnable 인터페이스를 구현하는 클래스를 만들고, 해당 클래스에서 run() 메서드를 구현합니다. 그리고 Runnable 객체를 Thread 생성자에 전달하여 스레드를 생성하고, start() 메서드를 호출하여 스레드를 시작합니다.

            ```java
            class MyRunnable implements Runnable {
                public void run() {
                    // 스레드가 실행할 작업 구현
                }
            }

            // Runnable 객체를 전달하여 스레드 생성 및 시작
            MyRunnable runnable = new MyRunnable();
            Thread thread = new Thread(runnable);
            thread.start();
            ```

        3. 람다 표현식 사용: Runnable 인터페이스의 익명 구현체로 람다 표현식을 사용하여 스레드를 생성하고 시작할 수 있습니다.

            ```java
            Runnable runnable = () -> {
                // 스레드가 실행할 작업 구현
            };

            // 람다 표현식으로 스레드 생성 및 시작
            Thread thread = new Thread(runnable);
            thread.start();
            ```

        4. ExecutorService를 사용: Java의 ExecutorService를 사용하여 스레드 풀을 생성하고 작업을 제출하여 스레드를 실행할 수 있습니다.

            ```java
            ExecutorService executor = Executors.newFixedThreadPool(5);

            // 작업을 제출하여 스레드 실행
            executor.execute(() -> {
                // 스레드가 실행할 작업 구현
            });

            // ExecutorService 종료
            executor.shutdown();
            ```

        이러한 방법들을 사용하여 스레드를 생성하고 실행할 수 있으며, 각각의 방법은 특정 상황이나 요구에 따라 선택하여 사용할 수 있습니다.

<br><br>
    - 📌 runnable과 callable의 차이는 무엇인가요?
<br><br>

        Runnable과 Callable은 둘 다 Java에서 스레드를 실행하기 위해 사용되는 인터페이스입니다. 그러나 Runnable과 Callable 사이에는 몇 가지 중요한 차이점이 있습니다.

      1. 반환값의 유무:
         - Runnable: 반환값이 없으며, `run()` 메서드에서 작업을 실행하고 완료될 때까지 기다리지 않습니다.
         - Callable: `call()` 메서드를 통해 작업을 실행하고, 작업이 완료되면 결과를 반환합니다. 반환값은 Future 객체를 통해 얻을 수 있습니다.

      2. 예외 처리:
         - Runnable: 작업 내에서 발생하는 예외를 직접 처리해야 합니다.
         - Callable: 작업 내에서 발생하는 예외를 던질 수 있으며, 호출자는 예외를 처리할 수 있습니다. 예외는 Future 객체를 통해 얻을 수 있습니다.

      3. Generic 타입:
         - Runnable: Runnable은 제네릭 타입을 가지지 않고, 반환값을 가질 수 없습니다.
         - Callable: 제네릭 타입을 사용하여 반환값의 타입을 지정할 수 있습니다.

      4. 사용 예:
         - Runnable: 주로 비동기 작업, 스레드 풀 등에서 사용됩니다.
         - Callable: 주로 작업의 결과를 반환해야 할 때, 작업의 성공 여부를 확인하고자 할 때 사용됩니다.

      Runnable과 Callable은 각각의 특징과 용도에 따라 선택하여 사용해야 합니다. Runnable은 단순한 작업을 수행하거나 비동기적으로 실행되는 작업을 처리할 때 유용하며, Callable은 작업의 결과를 반환하고 예외 처리가 필요한 경우에 사용됩니다.

<br><br>
    - 📌 스레드의 여러가지 상태에 대해 말해주세요.
<br><br>

        스레드는 다양한 상태를 가질 수 있으며, 주요한 스레드 상태는 다음과 같습니다:

      1. New (생성):
         - 스레드가 생성되었지만 아직 `start()` 메서드가 호출되지 않은 상태입니다.

      2. Runnable (실행 가능):
         - `start()` 메서드가 호출되어 스레드가 실행 가능한 상태입니다.
         - 실제로 실행되기 위해서는 스케줄러에 의해 선택되어 CPU를 할당받아야 합니다.

      3. Running (실행):
         - 스레드가 CPU를 할당받아 실행 중인 상태입니다.
         - 실제로 스레드의 작업이 실행되고 있는 상태입니다.

      4. Blocked (차단):
         - 스레드가 일시적으로 작업을 일시 중지한 상태입니다.
         - 다른 스레드가 사용 중인 공유 자원에 접근하거나, 스레드가 락을 획득할 수 없는 상태에 있을 때 발생합니다.
         - 차단된 스레드는 다시 실행 가능한 상태가 될 때까지 기다려야 합니다.

      5. Waiting (대기):
         - 스레드가 다른 스레드로부터 신호를 기다리는 상태입니다.
         - `wait()` 메서드, `join()` 메서드 등이 호출되어 스레드가 대기 상태에 들어갑니다.
         - 신호가 도착하면 대기 상태에서 벗어나 실행 가능한 상태가 됩니다.

      6. Timed Waiting (제한된 대기):
         - 스레드가 일정 시간 동안 대기하는 상태입니다.
         - `sleep()` 메서드, `wait(long timeout)` 메서드 등이 호출되어 스레드가 제한된 대기 상태에 들어갑니다.
         - 지정된 시간이 경과하거나 신호가 도착하면 제한된 대기 상태에서 벗어나 실행 가능한 상태가 됩니다.

      7. Terminated (종료):
         - 스레드의 작업이 완료되거나, 강제로 종료되어 더 이상 실행되지 않는 상태입니다.
         - 스레드는 자신의 작업을 마치고 정상적으로 종료되거나, 예외가 발생하여 종료될 수 있습니다.

      스레드는 이러한 상태들을 전환하며 동작하며, 스레드 상태의 변화는 스레드 스케줄러에 의해 관리됩니다. 상황에 따라 스레드는 상태를 변경하며 실행되고, 차단되거나 대기하는 등의 동작을 수행합니다.

<br><br>
    - 📌 sleep()과 wait()의 차이는 무엇인가요?
<br><br>

        sleep()과 wait()은 스레드의 동작을 제어하기 위해 사용되는 메서드입니다. 그러나 두 메서드 간에는 중요한 차이점이 있습니다.

        1. 대상 객체:
           - sleep(): Thread 클래스의 정적 메서드로, 현재 실행 중인 스레드를 일시적으로 정지시킵니다.
           - wait(): Object 클래스의 인스턴스 메서드로, 스레드가 특정 객체의 모니터(lock)를 놓고 대기하도록 합니다.

        2. 동작:
           - sleep(): 주어진 시간 동안 스레드를 일시 중지시킵니다. 시간이 경과하면 스레드는 자동으로 실행 가능한 상태가 됩니다.
           - wait(): 다른 스레드가 특정 객체의 notify() 또는 notifyAll() 메서드를 호출할 때까지 스레드를 대기 상태로 만듭니다. 스레드는 대기 상태에서 벗어날 때까지 기다립니다.

        3. 사용 방법:
           - sleep(): 일시적으로 스레드를 일시 중지시키는 경우에 사용됩니다. 예를 들어, 시간 지연이 필요하거나 정기적인 작업을 수행하는 경우에 활용됩니다.
           - wait(): 다른 스레드와의 상호작용이 필요한 경우에 사용됩니다. 주로 스레드 간의 통신 및 동기화를 위해 활용되며, wait() 호출 후 다른 스레드가 notify() 또는 notifyAll()을 호출하여 스레드를 깨우는 시그널을 보낼 수 있습니다.

        4. 호출 가능한 위치:
           - sleep(): 어디서든지 호출할 수 있습니다.
           - wait(): synchronized 블록 내에서 호출되어야 합니다. wait() 메서드는 모니터(lock)를 놓고 대기하므로, synchronized 블록 내에서 호출되어야 하고, 모니터를 소유한 스레드에 의해 호출되어야 합니다.

        중요한 차이점은 sleep()은 단지 시간 지연을 위해 사용되는 반면, wait()은 스레드 간의 통신과 동기화를 위해 사용되는 것입니다. 또한 wait()은 notify() 또는 notifyAll()에 의해 대기 상태에서 벗어날 때까지 기다립니다. 따라서 wait()은 스레드의 동기화와 상호작용에 사용되는 더 유연한 방법입니다.

<br><br>
    - 📌 notify()와 notifyAll()의 차이는 무엇인가요?
<br><br>

        notify()와 notifyAll()은 모두 wait() 메서드에 의해 대기 상태에 있는 스레드를 깨우는 데 사용되는 메서드입니다. 그러나 두 메서드 간에는 몇 가지 중요한 차이점이 있습니다.

        1. 깨워지는 스레드:
           - notify(): 대기 상태에 있는 스레드 중에서 임의의 하나의 스레드를 선택하여 깨웁니다.
           - notifyAll(): 대기 상태에 있는 모든 스레드를 깨웁니다.

        2. 소유권:
           - notify(): 현재 모니터(lock)를 소유하고 있는 스레드에서 호출해야 합니다. 다른 스레드가 모니터를 소유하고 있을 때 호출하면 IllegalMonitorStateException이 발생합니다.
           - notifyAll(): 현재 모니터(lock)를 소유하고 있는 스레드 또는 다른 스레드에서 호출할 수 있습니다.

        3. 경쟁 상황:
           - notify(): 대기 상태에 있는 스레드 중 하나만 깨우므로, 여러 스레드가 경쟁하여 깨어날 수 있습니다.
           - notifyAll(): 대기 상태에 있는 모든 스레드가 깨어나므로, 경쟁 없이 모든 스레드가 동시에 실행 가능한 상태가 됩니다.

        일반적으로 notify()는 하나의 스레드를 깨우는 데 사용되며, notifyAll()은 모든 스레드를 깨우는 데 사용됩니다. notify()는 일부 스레드만 깨워야 할 때 유용하며, notifyAll()은 모든 스레드가 중요한 상태 변화를 알아야 할 때 유용합니다. 경쟁이 발생하지 않고 모든 스레드에게 동시에 상태 변화를 알려야 할 경우에는 notifyAll()을 사용하는 것이 안전하고 일관된 방법입니다.