# 주니어 자바 개발자를 위한 100가지 질문

1. 기초
    - 📌 JDK와 JRE의 차이점은 무엇입니까?
        
        
        JRE(Java Runtime Environment)는 자바 실행 환경이다. JVM 뿐만 아니라 Java binaries, Java 클래스 라이브러리 등을 포함하고 있어 자바 프로그램의 실행을 지원한다. 하지만 컴파일러나 디버거등의 도구는 포함하지 않는다. 따라서 자바 프로그램을 개발하는 것이 아니라 실행하기만 원한다면 JRE를 설치하면 된다.
        
        JDK(Java Development Kit)는 자바 개발 키드이다. JDK는 자바 애플리케이션을 개발하기 위한 환경을 지원한다. JDK는 JRE를 포함할 뿐만 아니라 컴파일러(javac), javadoc, jar 등 개발에 유용한 도구들을 포함하고 있다. 따라서 자바 프로그램을 개발하기 위해서는 JDK를 다운로드 하여야 한다.
        
        JRE는 자바 실행환경, JDK 는 자바 개발 도구
        
        [https://code-lab1.tistory.com/253](https://code-lab1.tistory.com/253)
        
    - 📌 ==와 equals의 차이점은 무엇입니까?
        
        
        String변수를 생성할때는 두 가지 방법이 있다.
        
        1. 리터럴(literal)을 이용한 방식
        String str1 = “apple”;
        2. new 연산자를 이용한 방식
        String str2 = new String(”banana”);
        
        == 는 객체가 같은지를 비교하지만 객체가 갖고 있는 문자열을 비교하지 않는다.
        
        == 연산자의 경우 참조 타입 변수들 간의 연산은 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다.
        
        equals매서드는 두 비교대상의 주소 값이 아닌 데이터값을 비교하기 때문에 어떻게 String을 생성하느냐에 따라 결과가 달라지지 않고 정확한 비교를 할 수 있다.
        
        compareTo() 매서드는 두개의 문자열을 비교한다. 동일한지의 여부만 확인할 수 있는 equals와 다르게 어떤 문자가 사전적인 순서로 앞에 있는지도 리턴해준다. 따라서 compareTo()를 이용하면 리스트를 오름차순으로 정렬하거나 내림차순으로 정렬할 수 있다. 리턴 값은 0, 음수, 양수의 int가 리턴되며 0 은 두개의 문자열이 동일, 양수는 호출하는 객체가 인자보다 사전적으로 순서가 앞설 때, 음수는 인자가 객체보다 사전적으로 순서가 앞설 때 이다.
        
        [https://sudo-minz.tistory.com/93](https://sudo-minz.tistory.com/93)
        
    - 📌 두 객체가 동일한 hashCode를 가지면 Equals()가 참이어야 합니다, 그렇죠?
        
        
        아니다. 두 객체의 해시 코드가 같다고 해서 두 객체가 동일하다는 보장은 없다. 해시 충돌이 발생할 수 있기 때문이다. 해시 충돌이란 서로 다른 두 객체가 동일한 해시 코드를 가지는 상황을 말한다. 따라서 두 객체의 동등성을 판단하려면 해시 코드뿐만 아니라 equals() 메서드를 사용하여 비교해야 한다.
        
    - 📌 자바에서 final의 기능은 무엇입니까?
        
        
        Java에서 `final` 키워드는 변수, 메서드, 클래스에 적용될 수 있으며, 각각의 경우에 다른 의미와 동작을 가집니다.
        
        1. 변수에 적용된 `final`: `final`로 선언된 변수는 상수(constant)로 취급되어, 한 번 초기화되면 값을 변경할 수 없습니다. `final` 변수는 선언 시 직접 초기화하거나 생성자를 통해 초기화해야 합니다. 메서드나 블록 내에서 재할당이나 수정이 불가능하므로, 값이 변하지 않는 상수 값을 표현할 때 사용됩니다.
            
            ```java
            final int x = 10; // 변수 x는 상수로, 한 번 초기화되면 값이 변경될 수 없음
            
            ```
            
        2. 메서드에 적용된 `final`: `final`로 선언된 메서드는 하위 클래스에서 오버라이딩(재정의)할 수 없습니다. 이를 통해 메서드의 구현을 불변하게 만들어, 오버라이딩에 의한 변경을 방지할 수 있습니다. 주로 상속 관계에서 부모 클래스의 기능을 보호하고자 할 때 사용됩니다.
            
            ```java
            class Parent {
                final void printMessage() {
                    System.out.println("This is a final method.");
                }
            }
            class Child extends Parent {
                // 아래의 오버라이딩 시도는 컴파일 오류 발생
                // final 메서드는 오버라이딩할 수 없음
                // void printMessage() { }
            }
            
            ```
            
        3. 클래스에 적용된 `final`: `final`로 선언된 클래스는 다른 클래스에서 상속받을 수 없습니다. 이는 클래스를 확장하지 못하도록 제한하여, 클래스의 기능과 구현을 변경할 수 없게 합니다. `final` 클래스는 보안, 불변성, 성능 등 특정 목적을 위해 사용됩니다.
            
            ```java
            final class FinalClass {
                // final 클래스는 상속할 수 없음
            }
            // 아래의 상속 시도는 컴파일 오류 발생
            // final 클래스는 상속받을 수 없음
            // class SubClass extends FinalClass { }
            
            ```
            
        
        `final` 키워드는 코드의 안정성과 안정성을 강화하고, 의도적인 변경을 방지하는 데 사용됩니다. 주의할 점은, `final`로 선언된 요소의 변경이 제한되지만, 내부 객체의 상태가 변경될 수 있다는 점입니다. 즉, `fina`로 선언된 변수가 가리키는 객체의 상태는 변경될 수 있습니다.
        
    - 📌 자바에서 Math.round(-1.5)는 무엇을 의미합니까?
        
        **`Math.round(-1.5)`**는 -1.5를 반올림하여 가장 가까운 정수로 변환하는데, 여기서 가장 가까운 정수는 -1입니다. 따라서 **`Math.round(-1.5)`**의 결과는 -1이 됩니다.
        
    - 📌 String은 기본 데이터 타입입니까?
        
        
        Java에서 **`String`**은 기본 데이터 타입(primitive data type)이 아니라 참조 타입(reference type)입니다.
        
        기본 데이터 타입에는 **`int`**, **`double`**, **`boolean`**, **`char`** 등이 있으며, 이러한 데이터 타입은 메모리에 직접 값을 저장합니다. 반면에 **`String`**은 문자열을 나타내는 참조 타입으로, 문자열 데이터를 다룰 때 사용됩니다. **`String`**은 객체로 취급되며, 힙(heap) 메모리에 저장되고 해당 객체에 대한 참조를 가리키는 변수가 생성됩니다.
        
        따라서, Java에서 **`String`**은 기본 데이터 타입이 아니라 참조 타입으로 분류됩니다.
        
    - 📌 자바에서 문자열을 조작하는 클래스는 무엇이 있습니까? 각 클래스의 차이점은 뭘까요?
        
        
        Java에서 문자열을 조작하는 클래스는 여러 가지가 있습니다. 주요한 클래스는 다음과 같습니다:
        
        1. `String`: `String` 클래스는 변경할 수 없는(immutable) 문자열을 나타내는데 사용됩니다. 문자열을 생성한 후에는 해당 문자열을 변경할 수 없으며, 문자열 조작 작업 시 새로운 문자열 객체가 생성됩니다.
        2. `StringBuilder`: `StringBuilder` 클래스는 가변(mutable) 문자열을 조작하는데 사용됩니다. `StringBuilder`는 문자열을 변경할 수 있는 메서드를 제공하며, 동일한 객체 내에서 문자열 조작 작업이 이루어집니다. 문자열 조작이 빈번하게 발생하는 상황에서 성능이 더 좋을 수 있습니다.
        3. `StringBuffer`: `StringBuffer` 클래스는 `StringBuilder`와 기능적으로 동일하며, 동기화(synchronization)를 지원하는 차이점이 있습니다. 따라서 멀티스레드 환경에서 안전하게 사용할 수 있습니다.
        
        차이점:
        
        - `String` 클래스는 변경할 수 없는(immutable) 문자열을 다루며, `StringBuilder`와 `StringBuffer`는 변경 가능한(mutable) 문자열을 다룹니다.
        - `StringBuilder`와 `StringBuffer`는 동일한 기능을 제공하지만, `StringBuffer`는 동기화를 지원하여 멀티스레드 환경에서 안전하게 사용할 수 있습니다.
        - `String` 클래스는 문자열 조작 작업마다 새로운 문자열 객체를 생성하므로, 문자열 조작이 빈번한 경우에는 성능 저하가 발생할 수 있습니다. 반면에 `StringBuilder`와 `StringBuffer`는 기존 객체를 변경하므로 성능상 이점이 있을 수 있습니다. 따라서, 문자열 조작이 자주 발생하는 경우에는 `StringBuilder` 또는 `StringBuffer`를 사용하는 것이 좋습니다.
        
    - 📌 String str ="i"와 String str = new String("i")가 동일합니까?
        
        `String str = "i"`와 `String str = new String("i")`는 동일하지 않습니다.
        
        1. `String str = "i"`: 이 구문은 문자열 리터럴("i")을 사용하여 `str` 변수에 문자열을 할당합니다. Java에서 문자열 리터럴은 내부적으로 `String` 객체로 처리됩니다. 따라서, 이 구문은 문자열 리터럴 "i"에 대한 새로운 `String` 객체를 생성하지 않고, 이미 존재하는 문자열 풀(string pool)에서 해당 문자열을 참조합니다.
        2. `String str = new String("i")`: 이 구문은 `new` 키워드를 사용하여 `String` 객체를 명시적으로 생성합니다. `"i"` 문자열을 가진 새로운 `String` 객체를 생성하고, `str` 변수에 할당합니다. 이 경우에는 새로운 `String` 객체가 생성되며, 문자열 리터럴이 아니라 동적으로 `String` 객체를 생성합니다..
    - 📌 문자열을 반전시키는 가장 좋은 방법은 무엇인가요?
        
        
        문자열을 반전시키는 가장 좋은 방법은 다음과 같습니다:
        
        1. `StringBuilder` 또는 `StringBuffer` 사용: `StringBuilder` 또는 `StringBuffer` 클래스를 사용하여 문자열을 반전시킬 수 있습니다. 이들 클래스는 가변(mutable)한 문자열을 다루는데 최적화되어 있으므로 문자열을 효율적으로 조작할 수 있습니다. `reverse()` 메서드를 사용하여 문자열을 반전시킬 수 있습니다.
            
            예시:
            
            ```java
            String str = "Hello, World!";
            StringBuilder reversed = new StringBuilder(str).reverse();
            String result = reversed.toString();
            System.out.println(result); // 출력: !dlroW ,olleH
            
            ```
            
        2. 문자열을 문자 배열로 변환 후 반전: 문자열을 문자 배열로 변환한 후에 배열을 반전시키는 방법도 있습니다. 이후 문자 배열을 다시 문자열로 변환할 수 있습니다.
            
            예시:
            
            ```java
            String str = "Hello, World!";
            char[] charArray = str.toCharArray();
            int left = 0;
            int right = charArray.length - 1;
            while (left < right) {
                char temp = charArray[left];
                charArray[left] = charArray[right];
                charArray[right] = temp;
                left++;
                right--;
            }
            String result = new String(charArray);
            System.out.println(result); // 출력: !dlroW ,olleH
            
            ```
            
        
        두 가지 방법 모두 문자열을 반전시키는데 사용할 수 있으며, `StringBuilder` 또는 `StringBuffer`를 사용하는 방법이 좀 더 간단하고 성능적으로 효율적일 수 있습니다.
        
    - 📌 String 클래스의 일반적인 메서드는 무엇이 있나요?
        
        
        String 클래스는 Java 프로그래밍 언어에서 가장 기본적이고 널리 사용되는 클래스 중 하나입니다. String 클래스에는 다양한 메서드가 있으며, 일반적으로 사용되는 몇 가지 메서드는 다음과 같습니다:
        
        1. length(): 문자열의 길이를 반환합니다.
        2. charAt(int index): 주어진 인덱스에 해당하는 문자를 반환합니다.
        3. substring(int beginIndex): 주어진 인덱스부터 문자열의 끝까지의 부분 문자열을 반환합니다.
        4. substring(int beginIndex, int endIndex): 주어진 범위에 해당하는 부분 문자열을 반환합니다.
        5. concat(String str): 주어진 문자열을 현재 문자열에 연결하여 새로운 문자열을 반환합니다.
        6. equals(Object obj): 주어진 객체와 현재 문자열을 비교하여 같으면 true를 반환합니다.
        7. isEmpty(): 문자열이 비어 있는지 여부를 확인합니다.
        8. toLowerCase(): 문자열의 모든 문자를 소문자로 변환한 새로운 문자열을 반환합니다.
        9. toUpperCase(): 문자열의 모든 문자를 대문자로 변환한 새로운 문자열을 반환합니다.
        10. trim(): 문자열의 앞뒤 공백을 제거한 새로운 문자열을 반환합니다.
        11. indexOf(int ch): 주어진 문자 또는 문자의 인덱스를 반환합니다.
        12. replace(char oldChar, char newChar): 주어진 문자열 내의 모든 oldChar를 newChar로 대체한 새로운 문자열을 반환합니다.
        13. split(String regex): 주어진 정규 표현식을 기준으로 문자열을 분할하여 문자열 배열로 반환합니다.
        14. startsWith(String prefix): 주어진 접두사로 시작하는지 여부를 확인합니다.
        15. endsWith(String suffix): 주어진 접미사로 끝나는지 여부를 확인합니다.
        
        이 외에도 다양한 메서드가 있으며, String 클래스는 불변(immutable) 클래스이므로 문자열을 수정하는 메서드는 원래의 문자열을 변경하는 대신 새로운 문자열을 반환합니다.
        
    - 📌 추상 클래스에서 추상 메서드는 필수적인가요?
        
        
        추상 클래스는 무조건 추상 메서드를 가져야 할 필요는 없습니다. 추상 클래스는 일반 메서드와 함께 추상 메서드를 가질 수 있습니다. 따라서 추상 클래스는 다음과 같은 경우에 사용될 수 있습니다:
        
        1. 추상 메서드를 가지는 경우: 추상 클래스가 추상 메서드를 가지는 경우, 이 추상 메서드는 하위 클래스에서 반드시 구현되어야 합니다. 추상 클래스를 상속받는 하위 클래스는 추상 메서드를 구현해야만 인스턴스화될 수 있습니다.
        2. 추상 메서드가 없는 경우: 추상 클래스가 추상 메서드를 가지지 않는 경우에는 하위 클래스에서 메서드 구현이 필요하지 않습니다. 하지만 추상 클래스로 선언된 경우, 해당 추상 클래스를 직접 인스턴스화할 수 없습니다. 대신, 추상 클래스를 상속받는 하위 클래스를 통해 인스턴스화해야 합니다.
        
        추상 클래스는 다른 클래스에게 공통적인 기능을 제공하고, 하위 클래스에게 특정 동작을 구현하도록 유도하는 역할을 할 수 있습니다. 추상 클래스는 인스턴스화될 필요가 없거나, 인스턴스화되어도 추상 클래스의 일반 메서드를 활용하기 위해 사용될 수 있습니다.
        
    - 📌 보통의 클래스와 추상 클래스의 차이는 무엇인가요?
        
        
        보통의 클래스와 추상 클래스의 주요 차이점은 다음과 같습니다:
        
        1. 인스턴스화 가능 여부: 보통의 클래스는 직접 인스턴스화할 수 있습니다. 즉, 해당 클래스의 객체를 생성하여 사용할 수 있습니다. 추상 클래스는 추상 메서드를 가지는 경우에는 직접 인스턴스화할 수 없으며, 추상 클래스를 상속받는 하위 클래스를 통해 인스턴스화해야 합니다.
        2. 추상 메서드 포함 여부: 보통의 클래스는 추상 메서드를 가질 수 없습니다. 모든 메서드는 구현되어 있어야 합니다. 추상 클래스는 추상 메서드를 포함할 수 있습니다. 추상 메서드는 메서드의 시그니처만을 정의하고 구현 내용은 제공하지 않습니다. 추상 클래스는 하위 클래스에서 이러한 추상 메서드를 반드시 구현해야 합니다.
        3. 상속 목적: 보통의 클래스는 다른 클래스에서 상속받아 사용될 수 있습니다. 보통의 클래스의 주요 목적은 코드 재사용과 확장성을 위해 상속 계층을 형성하는 것입니다. 추상 클래스는 보통의 클래스와 마찬가지로 다른 클래스에서 상속받을 수 있지만, 주로 하위 클래스에서 공통된 기능과 동작을 정의하기 위해 사용됩니다. 추상 클래스는 일부 메서드를 구현하지 않고 남겨두는 추상 메서드를 포함하여 하위 클래스에서 메서드 구현을 강제화할 수 있습니다.
        4. 인스턴스 변수 및 일반 메서드: 보통의 클래스와 추상 클래스 모두 인스턴스 변수와 일반 메서드를 가질 수 있습니다. 인스턴스 변수는 객체의 상태를 저장하고, 일반 메서드는 객체의 동작을 정의합니다. 이러한 면에서 보통의 클래스와 추상 클래스는 유사합니다.
        
        요약하자면, 추상 클래스는 하위 클래스에서 공통된 기능을 정의하고, 추상 메서드를 통해 하위 클래스에서 메서드 구현을 강제화하는 용도로 사용됩니다. 반면에 보통의 클래스는 주로 객체의 상태와 동작을 정의하고, 인스턴스화하여 사용하는 일반적인 클래스입니다.
        
    - 📌 final은 추상 클래스를 수정할 때 사용할 수 있나요?
        
        
        `final` 키워드는 클래스, 메서드 또는 변수를 수정할 수 없도록 지정하는 데 사용됩니다.
        
        추상 클래스에 `final` 키워드를 사용하는 것은 일반적으로 권장되지 않습니다. 추상 클래스는 상속을 통해 확장하고 기능을 추가하기 위해 설계되기 때문에, `final`을 사용하여 수정을 금지하는 것은 상속 및 확장의 목적에 어긋날 수 있습니다.
        
        추상 클래스는 하위 클래스에서 추상 메서드를 구현하고 추가적인 동작을 제공하기 위해 사용됩니다. `final` 키워드를 사용하면 하위 클래스에서 해당 추상 클래스를 상속받아 사용할 수 없게 됩니다. 따라서, 추상 클래스를 수정할 수 없도록 하려면 `final` 키워드를 사용하는 대신 클래스 내부의 메서드나 변수에 `final` 키워드를 사용하여 특정 메서드나 변수의 재정의나 재할당을 막을 수 있습니다.
        
        즉, 추상 클래스를 수정할 때 `final` 키워드를 사용하는 것은 일반적으로 권장되지 않으며, 주로 클래스의 특정 메서드나 변수에 적용되어 재정의나 재할당을 막는 데 사용됩니다.
        

1. Container
    - 📌 자바 컨테이너란 무엇인가요?
        
        
        자바 컨테이너는 다른 객체를 저장하고 관리하는 자바 클래스입니다. 컨테이너는 객체를 추가, 제거, 검색 및 조작하는 기능을 제공하여 데이터 구조를 구성하고 관리하는 데 사용됩니다.
        
        자바에서는 다양한 종류의 컨테이너 클래스를 제공합니다. 몇 가지 주요한 자바 컨테이너 클래스에는 다음과 같은 것들이 있습니다:
        
        1. ArrayList: 크기가 가변적인 배열로 구현된 리스트 컨테이너입니다. 요소들을 순차적으로 저장하고 인덱스를 통해 접근할 수 있습니다.
        2. LinkedList: 이중 연결 리스트로 구현된 리스트 컨테이너입니다. 각 요소는 이전 요소와 다음 요소를 가리키는 링크로 연결되어 있습니다.
        3. HashSet: 중복을 허용하지 않는 요소들의 모임인 집합 컨테이너입니다. 해시 함수를 사용하여 요소를 저장하고 검색합니다.
        4. HashMap: 키-값 쌍으로 이루어진 요소들을 저장하는 맵 컨테이너입니다. 각 요소는 고유한 키와 연결되어 있으며, 키를 사용하여 값을 검색하고 조작할 수 있습니다.
        5. Stack: 후입선출(LIFO) 방식으로 요소를 저장하고 접근하는 스택 컨테이너입니다. 주로 임시 데이터를 저장하거나 반복적인 작업에서 사용됩니다.
        6. Queue: 선입선출(FIFO) 방식으로 요소를 저장하고 접근하는 큐 컨테이너입니다. 주로 작업 대기열, 이벤트 처리 등에 사용됩니다.
        
        이 외에도 자바에서는 다양한 컨테이너 클래스와 인터페이스를 제공하며, 각각의 컨테이너는 다른 용도와 특징을 가지고 있습니다. 이러한 자바 컨테이너들은 데이터 구조의 유연성과 편의성을 제공하여 개발자가 객체를 보다 쉽게 저장, 관리 및 조작할 수 있도록 도와줍니다.
        
    - 📌 Collection과 Collections의 차이는 무엇인가요?
        
        
        Collection과 Collections은 자바에서 제공하는 두 가지 다른 개념입니다.
        
        1. Collection: Collection은 자바 컬렉션 프레임워크의 인터페이스입니다. java.util.Collection 인터페이스는 객체들의 그룹을 관리하기 위한 기본적인 동작을 정의합니다. Collection은 객체의 모임을 표현하며, 객체를 추가, 제거, 조회, 수정하는 메서드 등을 제공합니다. Collection은 다양한 하위 인터페이스를 가지고 있으며, 대표적으로 List, Set, Queue 인터페이스 등이 있습니다. Collection 인터페이스는 객체들을 단순히 그룹화하고 관리하는 기능을 제공하며, 객체의 저장 순서, 중복 허용 여부 등은 하위 인터페이스에서 다양하게 정의됩니다.
        2. Collections: Collections는 자바에서 제공하는 유틸리티 클래스입니다. java.util.Collections 클래스는 Collection 인터페이스를 구현한 클래스들에 대한 유용한 메서드를 제공합니다. Collections 클래스는 정적 메서드로 구성되어 있으며, 컬렉션 객체를 조작하고 정렬하고 검색하는 데 사용됩니다. 예를 들어, Collections 클래스는 컬렉션의 정렬, 검색, 복사, 변경 등의 작업을 수행할 수 있는 메서드들을 제공합니다. 이러한 유틸리티 메서드를 사용하여 컬렉션 객체를 효율적으로 조작할 수 있습니다.
        
        요약하면, Collection은 자바 컬렉션 프레임워크의 인터페이스로서 객체의 그룹화 및 관리를 위한 기본적인 동작을 정의합니다. Collections는 자바의 유틸리티 클래스로서 컬렉션 객체를 조작하고 정렬하고 검색하는 데 사용되는 메서드들을 제공합니다.
        
    - 📌 List, Set, Map의 차이점을 말해주세요.
        
        
        List, Set, Map은 자바 컬렉션 프레임워크에서 다른 목적과 특징을 가진 세 가지 인터페이스입니다.
        
        1. List:
        - List는 순서가 있는 컬렉션으로, 요소들을 순차적으로 저장하고 인덱스로 접근할 수 있습니다.
        - List는 중복된 요소를 허용합니다. 즉, 동일한 요소를 여러 번 포함할 수 있습니다.
        - List는 인터페이스로서 ArrayList, LinkedList 등의 구현체가 있습니다.
        1. Set:
        - Set은 중복을 허용하지 않는 컬렉션으로, 고유한 요소들의 모임입니다.
        - Set은 순서가 보장되지 않습니다. 따라서 요소를 추가한 순서대로 접근할 수 없습니다.
        - Set은 동일한 요소를 중복해서 저장하지 않습니다. 이미 존재하는 요소를 추가하려고 하면 추가되지 않습니다.
        - Set은 인터페이스로서 HashSet, TreeSet 등의 구현체가 있습니다.
        1. Map:
        - Map은 키-값(key-value) 쌍으로 데이터를 저장하는 컬렉션입니다.
        - 각 키는 고유해야 하며, 키를 통해 해당 값을 검색할 수 있습니다.
        - Map은 순서가 보장되지 않으며, 중복된 키를 허용하지 않습니다. 동일한 키로 다른 값을 추가하면 이전 값을 대체합니다.
        - Map은 인터페이스로서 HashMap, TreeMap, LinkedHashMap 등의 구현체가 있습니다.
        
        요약하자면, List는 순서가 있는 중복을 허용하는 컬렉션, Set은 순서가 없고 중복을 허용하지 않는 컬렉션, Map은 키-값 쌍을 저장하는 컬렉션입니다. 각각의 인터페이스는 서로 다른 용도와 특징을 가지며, 다양한 상황에 맞게 사용될 수 있습니다.
        
    - 📌 HashMap과 Hashtable의 차이는 무엇인가요?
        
        
        HashMap과 Hashtable은 둘 다 키-값 쌍을 저장하기 위한 자료 구조입니다. 그러나 둘 사이에는 몇 가지 중요한 차이점이 있습니다.
        
        1. 동기화(synchronization): Hashtable은 동기화된 메소드를 제공하여 여러 스레드가 동시에 접근할 때 안전하게 사용할 수 있도록 합니다. 즉, Hashtable은 스레드 안전(thread-safe)한 자료 구조입니다. 반면에 HashMap은 동기화를 제공하지 않으므로 여러 스레드가 동시에 접근할 때 외부에서 동기화를 보장해주어야 합니다.
        2. Null 허용: HashMap은 null 키와 null 값 모두를 허용합니다. 그러나 Hashtable은 null 키 또는 null 값이 될 수 없습니다. Hashtable에 null을 넣으려고 하면 NullPointerException이 발생합니다.
        3. 속도: 일반적으로 HashMap은 Hashtable보다 더 빠릅니다. 이는 HashMap이 동기화를 제공하지 않으므로 동기화 관련 오버헤드가 없기 때문입니다. 동기화가 필요하지 않은 경우에는 HashMap을 사용하는 것이 성능상 이점이 있습니다.
        4. 반복 순서: HashMap은 요소의 순서를 보장하지 않습니다. 반면에 Hashtable은 요소의 삽입 순서를 유지합니다. 따라서 순서가 중요한 경우에는 Hashtable을 사용하는 것이 좋습니다.
        5. 상속 가능성: Hashtable은 Dictionary 클래스를 확장하고 있으며, HashMap은 AbstractMap 클래스를 확장하고 있습니다. 따라서 Hashtable은 Dictionary 클래스의 메소드를 상속받아 사용할 수 있습니다. 그러나 HashMap은 AbstractMap 클래스의 메소드를 사용합니다.
        
        일반적으로는 동기화가 필요하지 않고 null 허용이 필요한 경우를 제외하고는 HashMap을 더 권장합니다.
        
    - 📌 각각 어떤 상황에서 HashMap과 TreeMap을 선택하나요?
        
        
        HashMap과 TreeMap은 둘 다 자바의 Map 인터페이스를 구현한 자료 구조입니다. 그러나 그들 사이에는 몇 가지 중요한 차이점이 있습니다.
        
        1. 데이터 정렬: HashMap은 요소의 순서를 보장하지 않습니다. 데이터가 삽입된 순서와는 관계없이 내부적으로 해시 함수를 사용하여 요소를 저장하므로, 요소들의 순서는 예측할 수 없습니다. 반면에 TreeMap은 요소들을 정렬된 순서로 유지합니다. 기본적으로는 키에 대해 오름차순으로 정렬되며, 키의 자연적인 순서 또는 Comparator를 사용하여 정렬할 수 있습니다.
        2. 성능: HashMap은 해시 함수를 사용하여 데이터를 저장하므로, 검색, 삽입, 삭제 작업의 평균적인 시간 복잡도는 O(1)입니다. 반면에 TreeMap은 레드-블랙 트리(Red-Black Tree)라는 균형 이진 검색 트리를 사용하여 데이터를 저장하므로, 이러한 작업의 시간 복잡도는 O(log n)입니다. 따라서 TreeMap은 일반적으로 HashMap보다는 조금 더 느릴 수 있습니다.
        3. 정렬 기능: TreeMap은 정렬된 데이터를 유지하므로, 범위 검색이나 정렬된 순서로 요소에 접근해야 할 때 유용합니다. 반면에 HashMap은 정렬이 필요하지 않거나 요소의 순서가 중요하지 않은 경우에 더 적합합니다.
        4. 동기화: HashMap은 동기화를 제공하지 않으므로 여러 스레드가 동시에 접근할 때 외부에서 동기화를 보장해주어야 합니다. TreeMap은 동기화를 지원하는 NavigableMap 인터페이스의 구현체이므로 멀티 스레드 환경에서 안전하게 사용할 수 있습니다.
        5. Null 허용: HashMap은 null 키와 null 값을 허용합니다. TreeMap은 null 키를 허용하지 않습니다. null 값을 허용하는지 여부는 자료 구조를 선택할 때 고려해야 하는 중요한 요소 중 하나입니다.
        
        따라서, 요소의 순서가 중요하지 않고 빠른 검색 및 삽입이 필요한 경우에는 HashMap을 사용하는 것이 적합하며, 요소의 정렬이 필요하거나 범위 검색이 필요한 경우에는 TreeMap을 선택하는 것이 좋습니다.
        
    - 📌 HashMap 구현 원칙은 무엇인가요?
        
        
        HashMap은 해시 테이블을 기반으로한 자료 구조로, 효율적인 데이터 검색과 삽입을 위해 설계되었습니다. HashMap의 구현 원칙은 다음과 같습니다:
        
        1. 해시 함수 사용: HashMap은 해시 함수를 사용하여 키(key)와 해시 코드(hash code)를 매핑합니다. 해시 함수는 키를 해시 코드로 변환하는 역할을 합니다. 이 해시 코드는 배열의 인덱스로 사용됩니다.
        2. 동등성 비교: HashMap은 동일한 해시 코드를 가진 키를 처리하기 위해 동등성 비교(equality comparison)를 수행합니다. 동등성 비교는 equals() 메소드를 사용하여 키 간에 동등성을 확인합니다. 동등한 키는 동일한 버킷(bucket)에 저장될 수 있도록 해시 맵 내에서 동일한 해시 코드를 가진 다른 키들과 비교됩니다.
        3. 충돌 해결: 해시 함수는 일반적으로 키 공간이 무한하지 않기 때문에, 서로 다른 키가 동일한 해시 코드를 가질 수 있습니다. 이를 해시 충돌(hash collision)이라고 합니다. HashMap은 충돌을 해결하기 위해 개방 주소법(open addressing) 또는 연결리스트(chaining)를 사용합니다. 개방 주소법은 동일한 버킷에 새로운 키를 저장할 다른 위치를 찾는 방법입니다. 연결리스트는 동일한 버킷에 속하는 모든 키들을 연결 리스트로 관리하여 충돌을 해결합니다.
        4. 초기 용량과 로드 팩터: HashMap은 초기 용량(initial capacity)과 로드 팩터(load factor)라는 두 가지 매개변수를 가집니다. 초기 용량은 해시 맵이 저장할 수 있는 최대 요소 수를 결정합니다. 로드 팩터는 해시 맵이 자동으로 크기를 조정할 때 사용되는 임계값을 나타냅니다. 로드 팩터를 초과하는 요소의 추가로 인해 해시 맵의 크기가 증가하면, 해시 맵은 자동으로 더 큰 크기로 재할당되어 요소를 재분배합니다.
        5. 동기화: HashMap은 기본적으로 스레드 간의 안전성을 보장하지 않습니다. 동시에 여러 스레드에서 HashMap에 접근하는 경우에는 외부에서 동기화를 보장해주어야 합니다. 동기화가 필요한 경우에는 ConcurrentHashMap을 고려해볼 수 있습니다.
        
        HashMap은 검색, 삽입, 삭제 작업을 평균적으로 O(1)의 시간 복잡도로 처리할 수 있으며, 큰 데이터셋에서 효과적으로 사용될 수 있습니다.
        
    - 📌 HashSet 구현 원칙은 무엇인가요?
        
        
        HashSet은 자바의 Set 인터페이스를 구현한 자료 구조로, 중복을 허용하지 않는 요소들의 집합을 저장하는데 사용됩니다. HashSet의 구현 원칙은 다음과 같습니다:
        
        1. 해시 함수 사용: HashSet은 해시 함수를 사용하여 요소를 저장합니다. 해시 함수는 요소의 해시 코드를 계산하는 역할을 합니다. HashSet은 각 요소의 해시 코드를 기반으로 내부 배열에서 요소를 저장하고 검색합니다.
        2. 동등성 비교: HashSet은 동일한 해시 코드를 가진 요소를 처리하기 위해 동등성 비교(equality comparison)를 수행합니다. 동등성 비교는 equals() 메소드를 사용하여 요소 간에 동등성을 확인합니다. 동등한 요소는 HashSet 내에서 중복을 허용하지 않고 저장되지 않습니다.
        3. 해시 충돌 해결: 해시 함수는 일반적으로 요소의 공간이 무한하지 않기 때문에 서로 다른 요소가 동일한 해시 코드를 가질 수 있습니다. 이러한 상황을 해시 충돌(hash collision)이라고 합니다. HashSet은 충돌을 해결하기 위해 개방 주소법(open addressing) 또는 연결리스트(chaining)를 사용합니다. 개방 주소법은 동일한 버킷에 새로운 요소를 저장할 다른 위치를 찾는 방법입니다. 연결리스트는 동일한 버킷에 속하는 모든 요소들을 연결 리스트로 관리하여 충돌을 해결합니다.
        4. 순서 보장: HashSet은 요소들의 순서를 보장하지 않습니다. 요소들이 저장된 순서와는 관계없이 내부적으로 해시 함수와 해시 충돌 해결 방법에 의해 요소들이 저장되기 때문에, HashSet의 순서는 예측할 수 없습니다. 만약 순서를 보장해야 하는 경우에는 LinkedHashSet을 사용할 수 있습니다.
        5. 동기화: HashSet은 기본적으로 스레드 간의 안전성을 보장하지 않습니다. 동시에 여러 스레드에서 HashSet에 접근하는 경우에는 외부에서 동기화를 보장해주어야 합니다. 동기화가 필요한 경우에는 ConcurrentHashMap을 고려해볼 수 있습니다.
        
        HashSet은 요소의 삽입, 삭제, 검색 작업을 평균적으로 O(1)의 시간 복잡도로 처리할 수 있습니다. 중복을 허용하지 않는 요소의 집합을 저장하고자 할 때 HashSet은 매우 유용한 자료 구조입니다.
        
    - 📌 ArrayList와 LinkedList의 차이점은 무엇인가요?
        
        
        ArrayList와 LinkedList는 모두 자바에서 제공되는 리스트(List) 인터페이스의 구현체입니다. 그러나 두 자료 구조는 내부적인 구현 방식과 특징에서 차이가 있습니다.
        
        ArrayList:
        
        - 내부적으로 배열(Array)로 구현되어 있습니다.
        - 인덱스를 기반으로 한 빠른 임의 접근(random access)이 가능합니다.
        - 요소의 삽입과 삭제는 배열의 재할당과 복사가 필요할 수 있으므로 비효율적일 수 있습니다.
        - 요소의 추가와 삭제가 리스트의 끝 부분에서 주로 발생하는 경우에는 성능이 좋습니다.
        - 데이터의 크기가 동적으로 변하지 않고, 잦은 검색 및 임의 접근이 필요한 경우에 적합합니다.
        
        LinkedList:
        
        - 내부적으로 노드(Node)의 연결 리스트로 구현되어 있습니다.
        - 인덱스를 기반으로 한 접근은 비효율적이며, 요소를 차례대로 탐색해야 합니다.
        - 요소의 삽입과 삭제가 빠르며, 해당 노드의 연결만 수정하면 되므로 배열 재할당과 복사가 필요하지 않습니다.
        - 요소의 추가와 삭제가 리스트의 중간에서 주로 발생하는 경우에 성능이 좋습니다.
        - 데이터의 크기가 동적으로 변하고, 삽입과 삭제가 빈번하게 발생하는 경우에 적합합니다.
        
        요약하면, ArrayList는 배열 기반으로 빠른 임의 접근이 가능하며, 크기 변화가 적은 경우에 유리합니다. 반면에 LinkedList는 연결 리스트 기반으로 요소의 삽입과 삭제가 빠르며, 크기 변화가 많은 경우에 유리합니다. 선택은 데이터의 특성과 사용 패턴에 따라 달라집니다.
        
    - 📌 Array에서 List로 전환하려면 어떻게 해야하나요?
        
        
        Array를 List로 전환하려면 다음과 같은 방법들을 사용할 수 있습니다:
        
        1. Arrays.asList():
            - Arrays 클래스의 asList() 메서드를 사용하여 Array를 List로 변환할 수 있습니다.
            - 이 방법은 고정 크기의 리스트를 생성하며, 리스트의 크기를 변경할 수 없습니다.
            - 배열의 요소를 직접 수정하면 리스트의 요소도 변경됩니다.
            
            ```java
            String[] array = {"apple", "banana", "orange"};
            List<String> list = Arrays.asList(array);
            
            ```
            
        2. ArrayList의 생성자 또는 addAll():
            - ArrayList 클래스의 생성자 또는 addAll() 메서드를 사용하여 Array를 ArrayList로 변환할 수 있습니다.
            - 이 방법은 가변 크기의 리스트를 생성하며, 리스트의 크기를 동적으로 변경할 수 있습니다.
            
            ```java
            String[] array = {"apple", "banana", "orange"};
            List<String> list = new ArrayList<>(Arrays.asList(array));
            // 또는
            List<String> list = new ArrayList<>();
            Collections.addAll(list, array);
            
            ```
            
        3. Stream의 사용:
            - 자바 8 이상에서는 Stream을 사용하여 Array를 List로 변환할 수 있습니다.
            - 이 방법은 가변 크기의 리스트를 생성하며, 리스트의 크기를 동적으로 변경할 수 있습니다.
            
            ```java
            String[] array = {"apple", "banana", "orange"};
            List<String> list = Arrays.stream(array).collect(Collectors.toList());
            
            ```
            
        
        위의 방법들 중에서 선택하여 Array를 List로 변환할 수 있습니다. 선택한 방법은 개발 환경과 요구 사항에 따라 다를 수 있습니다.
        
        Array를 List로 전환하는 이유는 다음과 같습니다:
        
        1. 유연한 크기 조정: List는 동적으로 크기를 조정할 수 있으므로, 배열의 크기를 동적으로 조정하고자 할 때 유용합니다. 배열은 한 번 생성되면 크기를 변경하기 어렵지만, List는 요소의 추가 또는 제거를 통해 크기를 조정할 수 있습니다.
        2. 다양한 기능과 메서드 활용: List 인터페이스는 배열보다 더 많은 기능과 메서드를 제공합니다. 예를 들어, 요소의 추가, 제거, 검색, 정렬 등을 쉽게 수행할 수 있는 메서드를 제공합니다. 또한, List를 다른 컬렉션과 조합하여 사용할 수 있으며, 다양한 컬렉션 기능을 활용할 수 있습니다.
        3. 다형성과 호환성: List는 인터페이스이므로 구현체에 상관없이 다형성을 활용할 수 있습니다. 따라서, 코드의 유연성과 재사용성을 높일 수 있습니다. 또한, 다른 컬렉션과의 호환성도 증가합니다. 예를 들어, 메서드의 매개변수나 반환값으로 List를 사용하면, 다양한 구현체(ArrayList, LinkedList 등)를 전달하거나 반환할 수 있습니다.
        4. 향상된 컬렉션 기능 사용: List를 사용하면 자바 컬렉션 프레임워크의 다양한 기능을 활용할 수 있습니다. 예를 들어, 검색, 정렬, 필터링, 매핑 등과 같은 스트림 API를 활용하여 데이터를 처리할 수 있습니다.
        5. API 호환성 및 표준화: 대부분의 자바 라이브러리와 프레임워크는 List 인터페이스를 사용하므로, Array를 List로 전환하면 기존의 코드와 라이브러리와의 호환성을 유지하면서 새로운 기능을 활용할 수 있습니다. 또한, List는 자바 컬렉션 프레임워크의 일부이므로 표준화된 인터페이스를 사용하는 것이 좋습니다.
        
    - 📌 ArrayList와 Vector의 차이점을 말해주세요.
        
        
        ArrayList와 Vector는 둘 다 동적 배열(Dynamic Array)을 구현한 자료 구조입니다. 그러나 두 가지 주요한 차이점이 있습니다:
        
        1. 동기화(Synchronization):
            - ArrayList는 비동기적(비스레드 안전)으로 동작하며, 여러 스레드가 동시에 접근할 때 동기화를 보장하지 않습니다.
            - 반면에 Vector는 동기적(스레드 안전)으로 동작하며, 여러 스레드가 동시에 접근할 때 동기화를 보장합니다.
            - Vector는 각 메서드에 대한 동기화를 수행하므로, 멀티스레드 환경에서 안전하게 사용할 수 있습니다. 하지만 단일 스레드 환경에서는 동기화 오버헤드로 인해 성능이 느려질 수 있습니다.
        2. 성능:
            - ArrayList는 동기화를 제공하지 않기 때문에 동기화 오버헤드가 없어 일반적으로 Vector보다 더 빠릅니다.
            - Vector는 각 메서드에 대한 동기화를 수행하기 때문에 동기화 오버헤드로 인해 ArrayList보다 성능이 좀 더 낮을 수 있습니다.
        
        따라서, 단일 스레드 환경에서 ArrayList가 성능면에서 더 좋은 선택일 수 있습니다. 하지만 멀티스레드 환경이거나 동기화가 필요한 경우에는 Vector를 사용하여 스레드 안전성을 보장할 수 있습니다. 그러나 자바 1.5부터는 동기화를 위해 Vector 대신 동기화된 컬렉션인 `Collections.synchronizedList()` 메서드를 사용할 수 있으며, 이는 ArrayList와 유사한 성능을 제공합니다.
        
    - 📌 Array와 ArrayList의 차이점을 말해주세요.
        
        
        Array와 ArrayList는 둘 다 자료를 저장하는 자료 구조이지만, 몇 가지 주요한 차이점이 있습니다:
        
        1. 크기 조정: Array는 한 번 생성되면 크기를 변경할 수 없습니다. 반면, ArrayList는 동적으로 크기를 조정할 수 있습니다. 요소의 추가나 삭제에 따라 자동으로 크기가 조절되므로 편리합니다.
        2. 타입: Array는 동일한 타입의 요소만 저장할 수 있습니다. ArrayList는 제네릭을 사용하여 여러 타입의 요소를 저장할 수 있습니다.
        3. 메모리 할당: Array는 요소를 연속적으로 메모리에 할당합니다. 반면, ArrayList는 내부적으로 배열을 사용하여 요소를 저장하지만, 필요에 따라 크기를 조정하고 새로운 배열에 요소를 복사합니다.
        4. 속도: Array는 크기가 고정되어 있으므로 요소에 직접 접근하기 때문에 일반적으로 빠릅니다. ArrayList는 크기 조정과 요소의 이동이 필요할 수 있으므로 속도가 상대적으로 느릴 수 있습니다.
        5. 기능: Array는 기본적인 배열 기능만을 제공합니다. ArrayList는 Collection 인터페이스를 구현하므로 추가적인 기능과 메서드를 제공합니다. 예를 들어, 요소의 추가, 삭제, 검색, 정렬 등을 수행할 수 있는 다양한 메서드를 사용할 수 있습니다.
        
        따라서, 크기가 고정되어 있고 단순한 요소 저장 구조를 사용해야 한다면 Array를 선택할 수 있습니다. 그러나 동적 크기 조정과 다양한 기능을 활용해야 하거나 제네릭 타입을 사용해야 한다면 ArrayList가 더 적합합니다.
        
    - 📌 Queue에서, poll()과 remove()의 차이는 무엇인가요?
        
        
        Queue에서 `poll()`과 `remove()`는 두 가지 다른 메서드로, 요소를 가져오거나 제거하는 데 사용됩니다. 그러나 두 메서드는 동작 방식과 예외 처리에 차이가 있습니다:
        
        1. `poll()`: `poll()` 메서드는 Queue에서 요소를 가져옵니다. Queue가 비어있는 경우 `null`을 반환합니다. 즉, `poll()`은 요소를 가져오는 작업을 수행하고, Queue가 비어있는 경우 예외를 발생시키지 않습니다.
        2. `remove()`: `remove()` 메서드는 Queue에서 요소를 제거합니다. 제거된 요소를 반환합니다. Queue가 비어있는 경우 `NoSuchElementException` 예외가 발생합니다. `remove()`는 요소를 제거하는 작업을 수행하며, Queue가 비어있는 경우 예외를 발생시킵니다.
        
        즉, `poll()`은 요소가 있을 경우 요소를 반환하고, 비어있는 경우 `null`을 반환합니다. `remove()`는 요소가 있을 경우 요소를 반환하고, 비어있는 경우 예외를 발생시킵니다.
        
        따라서, 요소의 유무를 사전에 확인하고 예외 처리를 직접 처리하려는 경우에는 `remove()`를 사용할 수 있습니다. 반면에, 요소가 없을 때 `null` 값을 반환하고 예외 처리를 자동으로 처리하려는 경우에는 `poll()`을 사용할 수 있습니다.
        
    - 📌 thread-safe한 컬렉션 클래스들은 무엇이 있을까요?
        
        
        자바에서는 다음과 같은 스레드 안전(thread-safe)한 컬렉션 클래스들이 제공됩니다:
        
        1. ConcurrentHashMap: 동시에 여러 스레드에서 안전하게 사용할 수 있는 해시 맵 구현체입니다. 내부적으로 세분화된 락 분할(lock striping)을 사용하여 동시성을 지원합니다.
        2. CopyOnWriteArrayList: 읽기 작업이 많이 발생하고 쓰기 작업이 적은 경우에 유용한 스레드 안전한 동적 배열입니다. 쓰기 작업 시에는 내부 배열을 복사하므로 별도의 동기화가 필요하지 않습니다.
        3. ConcurrentLinkedQueue: 동시에 여러 스레드에서 안전하게 사용할 수 있는 비차단(non-blocking) 큐 구현체입니다. 여러 스레드에서 요소를 추가하거나 제거할 수 있습니다.
        4. ConcurrentSkipListMap 및 ConcurrentSkipListSet: 스레드 안전한 스킵 리스트 구현체입니다. 키-값 쌍을 저장하는 맵과 유니크한 요소를 저장하는 집합으로 사용할 수 있습니다.
        5. BlockingQueue 인터페이스를 구현한 클래스들: 스레드 간의 작업을 동기화하는 데 사용되는 블로킹 큐입니다. 예를 들어, LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue 등이 있습니다.
        
        이 외에도 java.util.concurrent 패키지에는 다양한 스레드 안전한 컬렉션 클래스들이 있습니다. 스레드 안전한 컬렉션 클래스들은 동시에 여러 스레드에서 안전하게 사용할 수 있는 기능을 제공하므로, 동시성 환경에서 안전하게 데이터를 처리할 수 있습니다.
        
    - 📌 iterator란 무엇인가요?
        
        
        Iterator는 자바에서 컬렉션(collection) 객체의 요소를 순회하고, 요소에 접근하기 위한 인터페이스입니다. Iterator는 컬렉션의 내부 구조에 상관없이 요소를 순차적으로 접근할 수 있는 표준화된 방법을 제공합니다.
        
        Iterator 인터페이스는 다음과 같은 주요 메서드를 정의하고 있습니다:
        
        1. `hasNext()`: 다음에 요소가 있는지 여부를 확인하는 메서드입니다. 요소가 있을 경우 `true`를 반환하고, 더 이상 요소가 없을 경우 `false`를 반환합니다.
        2. `next()`: 다음 요소를 반환하는 메서드입니다. `hasNext()` 메서드를 호출하여 다음 요소가 있는지 확인한 후, `next()`를 호출하여 실제 요소를 가져옵니다.
        3. `remove()`: 현재 가리키고 있는 요소를 삭제하는 메서드입니다. 이 메서드는 선택적으로 구현할 수 있습니다.
        
        Iterator를 사용하면 컬렉션 객체의 내부 구조를 알 필요 없이 요소에 접근할 수 있으며, 요소를 순차적으로 처리할 수 있습니다. 예를 들어, ArrayList, LinkedList, HashSet 등의 컬렉션 객체에서 Iterator를 사용하여 요소를 순회하고, 각 요소에 대한 작업을 수행할 수 있습니다. Iterator를 통해 컬렉션의 요소를 안전하게 수정하고 삭제할 수도 있습니다.
        
    - 📌 iterator의 사용 목적은 무엇인가요? 어떤 특징이 있죠?
        
        
        Iterator의 사용 목적은 다음과 같습니다:
        
        1. 요소 순회: Iterator를 사용하여 컬렉션의 요소를 순회하면서 각 요소에 접근할 수 있습니다. Iterator를 통해 컬렉션의 요소를 순차적으로 방문하면서 처리 작업을 수행할 수 있습니다.
        2. 컬렉션의 내부 구조에 독립성: Iterator를 사용하면 컬렉션의 내부 구조에 상관없이 요소에 접근할 수 있습니다. Iterator는 각 컬렉션 타입에 맞게 구현되어 있으므로, ArrayList, LinkedList, HashSet 등 어떤 컬렉션 타입이든 일관된 방식으로 요소에 접근할 수 있습니다.
        3. 안전한 요소 수정 및 삭제: Iterator를 사용하면 컬렉션의 요소를 안전하게 수정하거나 삭제할 수 있습니다. Iterator는 내부적으로 컬렉션의 상태를 추적하고, 컬렉션의 구조적 변경을 허용하지 않으면서 요소를 삭제할 수 있는 메서드(`remove()`)를 제공합니다.
        
        Iterator의 주요 특징은 다음과 같습니다:
        
        1. 단방향 순회: Iterator는 요소를 순차적으로 순회하며, 한 번에 하나의 요소에 접근할 수 있습니다. 순회 방향을 변경하거나 역방향으로 이동할 수는 없습니다.
        2. 요소의 삭제 지원: Iterator를 사용하여 현재 순회 중인 요소를 삭제할 수 있습니다. `remove()` 메서드를 호출하면 컬렉션에서 해당 요소가 제거됩니다.
        3. 예외 처리: Iterator는 예외 처리를 지원합니다. 예를 들어, `hasNext()`를 호출하여 더 이상 요소가 없는지 확인하고, `next()`를 호출하기 전에 `hasNext()`를 호출하는 것이 일반적인 패턴입니다. 또한, 컬렉션에서 요소가 제거되지 않은 상태에서 `remove()`를 호출하면 `IllegalStateException`이 발생합니다.
        
        Iterator는 컬렉션의 요소에 안전하게 접근하고 순회하며, 요소를 수정하거나 삭제하는 기능을 제공합니다. 이를 통해 컬렉션을 효율적으로 처리하고, 코드를 간결하고 가독성 있게 작성할 수 있습니다.
        
    - 📌 iterator와 listIterator의 차이는 무엇인가요?
        
        
        Iterator와 ListIterator는 모두 자바에서 컬렉션의 요소를 순회하고 접근하기 위한 인터페이스입니다. 그러나 두 인터페이스에는 몇 가지 차이점이 있습니다:
        
        1. 방향: Iterator는 단방향 순회를 지원하며, 순차적으로 요소에 접근합니다. ListIterator는 양방향 순회를 지원하며, 순차적으로 앞뒤로 이동하면서 요소에 접근할 수 있습니다.
        2. 요소 수정: Iterator는 요소를 읽는 것만 가능하며, 요소의 수정은 불가능합니다. ListIterator는 요소의 읽기와 수정이 모두 가능합니다. ListIterator의 `set()` 메서드를 사용하여 현재 요소를 수정할 수 있습니다.
        3. 요소 삽입 및 삭제: Iterator는 요소를 순회하면서 삭제할 수 있지만, 요소를 추가하거나 삽입하는 기능은 제공하지 않습니다. ListIterator는 요소의 추가(`add()`)와 삭제(`remove()`, `removeAll()`)를 모두 지원합니다.
        4. 인덱스 접근: Iterator는 인덱스에 직접 접근하는 기능을 제공하지 않습니다. ListIterator는 현재 위치의 인덱스를 확인하고, `nextIndex()`와 `previousIndex()` 메서드를 사용하여 현재 위치의 다음과 이전 인덱스를 확인할 수 있습니다.
        5. 컬렉션 타입: Iterator는 모든 Collection 인터페이스의 하위 인터페이스를 지원합니다. ListIterator는 List 인터페이스의 하위 인터페이스를 지원합니다. 따라서, ListIterator는 List 인터페이스를 구현한 컬렉션 클래스에서만 사용할 수 있습니다.
        
        Iterator와 ListIterator는 각각의 특징에 따라 사용될 수 있습니다. Iterator는 단방향 순회와 읽기 전용 요소에 대한 접근에 적합하며, ListIterator는 양방향 순회와 요소 수정, 추가, 삭제에 더 적합합니다.
        
    
2. Multi-Threading
- 1
- 1
- 1
- 1
- 1
- 1
-