# 트리
- 노드와 엣지로 연결된 그래프의 특수한 형태.

## 트리의 특징
- 순환 구조(cycle)를 지니고 있지 않고, 1개의 루트 노드가 존재.
- 루트 노드를 제외한 노드는 단 1개의 부모 노드를 갖음.
- 트리의 부분 트리 역시 트리의 모든 특징을 따름.

## 트라이(trie)
- 문자열 검색을 빠르게 실행할 수 있도록 설계한 트리 형태의 자료구조.
- N진 트리: 문자 종류의 개수에 따라 N이 결정된다. 알파벳은 26개의 문자로 이뤄져 있으므로 26진 트리로 구성된다.
- 루트 노드는 항상 빈 문자열을 뜻하는 공백 상태를 유지한다.


## 이진 트리(binary tree)
- 각 노드의 자식 노드의 개수가 2이하로 구성돼 있는 트리.
- 트리 영역에서 가장 많이 사용.

### 핵심 이론
- 가장 직관적이면서 편리한 트리 자료구조 형태는 배열.

| 이동 목표 노드 | 인덱스 연산                | 제약 조건(N= 노드 개수)  |
|----------|-----------------------|------------------|
| 루트 노드    | index = 1             |                  |
| 부모 노드    | index = index / 2     | 현재 노드가 루트 노드가 아님 |
| 왼쪽 자식 노드 | index = index * 2     | index * 2 <= n   |
| 오른쪽 자식 노드 | index = index * 2 + 1 | index*2+1 <= n   |

## 세그먼트 트리
- 주어진 데이터들의 구간 합과 데이터 업데이트를 빠르게 수행하기 위해 고안해낸 자료구조.
1. 트리 초기화하기
   - 리프 노드의 개수가 데이터의 개수(N) 이상이 되도록 트리 배열을 만든다.
   - 트리 배열의 크기를 구하는 방법은 2^k >= N을 만족하는 k의 최솟값을 구한 후 2*2^k 를 트리의 배열 크기로 정의한다.
   - 리프 노드에 원본 데이터를 입력한다. 리프 노드의 시작 위치는 2^k
   - 리프 노드를 제외한 나머지 노드의 값을 채운다.(2^k -1 부터 1번 쪽으로)
   - 자식 노드의 인덱스는 이진 트리 형식이기에 2N, 2N+1이 된다. ex) arr[7] = arr[14]+arr[15]
2. 질의값 구하기
   - 주어진 질의 인덱스를 세그먼트 트리의 리프 노드에 해당하는 인덱스로 변경.
   - 세그먼트 트리 index = 주어진 질의 index + 2^k -1
   - 질의값 구하는 과정
     1. start_index % 2 == 1일 때 해당 노드를 선택.
     2. end_index % 2 == 0일 때 해당 노드를 선택.
     3. a~b 에서 노드를 선택하지 않았다면 start_index = (start_index + 1) / 2 연산 실행.
     4. a~b 에서 노드를 선택하지 않았다면 end_index = (end_index - 1) / 2 연산 실행.
     5. a~d를 반복하다가 end_index < start_index 가 되면 종료.
3. 데이터 업데이트하기
   - 부모 노드로 이동하는 방식은 index = index / 2

## 최소 공통 조상(Lowest Common Ancestor)
- 임의의 두 노드를 선택했을 때, 두 노드가 각각 자신을 포함해 거슬러 올라가면서 부모 노드를 탐색할 때
처음 공통으로 만나게 되는 부모 노드를 최소 공통 조상(LCA) 라고 한다.

### 핵심 이론
- 트리의 높이가 크지 않을 때 루트 노드에서 탐색(DFS,BFS)를 시작해 각 노드의 부모 노드와 깊이를 저장.
- 선택된 두 노드의 깊이가 다른 경우, 더 깊은 노드의 노드를 부모 노드로 1개씩 올려 주면서 같은 깊이로 맞춤.
- 깊이가 같은 상태에서 동시에 부모 노드로 올라가면서 두 노드가 같은 노드가 될 때까지 반복.
- 트리의 높이가 커질 경우 시간 제약 문제에 직면할 수 있음.
- 빠르게 구하기의 핵심은 서로의 깊이를 맞춰 주거나 같아지는 노드를 찾을 때 기존에 한 단계씩 올려 주는 방식에서 2^k 씩 올라가 비교.
1. 부모 노드 저장 배열 만들기
   - 부모 노드 배열 P[K][N] = N번 노드의 2^k 번째 부모의 노드 번호
   - P[K][N] = p[K-1][P[k-1][N]]
2. 선택된 두 노드의 깊이 맞추기
   - P 배열을 이용해 기존에 한 단계씩 맞췄던 깊이를 2^k 단위로 넘어가면서 맞춤.
   