# 정렬(Sort)

## 정렬이란?
- 데이터를 정해진 기준에 따라 배치해 의미 있는 구조로 재설정하는 것.

## 정렬 종류

- 버블 정렬
- 선택 정렬
- 삽입 정렬
- 퀵 정렬
- 병합 정렬
- 기수 정렬

## 버블 정렬(bubble sort)
- 두 인접한 데이터의 크기를 비교해 정렬하는 방법.
- 간단하게 구현 가능하지만, 시간 복잡도는 O(n^2)로 다른 정렬 알고리즘보다 느린 편.

    ### 버블 정렬 과정
  1. 비교 연산이 필요한 루프 범위 설정.
  2. 인접한 데이터 값 비교.
  3. swap 조건에 부합하면 swap 연산 수행.
  4. 루프 범위가 끝날 때까지 2~3 반복.
  5. 정렬 영역 설정. 다음 루프 실행 때 이 영역 제외.
  6. 비교 대상이 없을 때 까지 1~5 반복.

## 선택 정렬(selection sort)
- 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법.
- 구현 방법이 복잡하고, 시간 복잡도도 O(n^2)라 비효율적.

  ### 선택 정렬 과정
  1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
  2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap 한다.
  3. 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 축소한다.
  4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.

## 삽입 정렬(insertion sort)
- 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식.
- 구현하기 쉽지만 O(n^2)의 시간복잡도.
- 적절한 삽입 위치를 탐색하는 부분에서 이진 탐색 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도 줄일 수 있음.

## 퀵 정렬(quick sort)
- 기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘.
- 기준값이 어떻게 선정되는지가 시간 복잡도에 많은 영향.
- 평균적인 시간 복잡도는 O(nlogn).

  ### 퀵 정렬 과정
  1. 데이터를 분할하는 pivot을 설정한다.
  2. pivot을 기준으로 다음 과정(a~e)을 거쳐 데이터를 2개의 집합으로 분리한다.
     1. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면, start를 오른쪽으로 1칸 이동한다.
     2. end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동한다.
     3. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면
     start, end가 가리키는 데이터를 swap 하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동한다.
     4. start와 end가 만날 대까지 a~c를 반복한다.
     5. start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 pivot이 가리키는 데이터가 크면
     만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입한다.
  3. 분리 집합에서 각각 다시 pivot을 선정한다.
  4. 분리 집합이 1개 이하가 될 때까지 과정 i~iii 을 반복한다.

## 병합 정렬(merge sort)
- 분할 정복(divide and conquer) 방식을 사용해 데이터를 분할하고, 분할한 집합을 정렬하며 합치는 알고리즘.
- 평균적인 시간 복잡도는 O(nlogn)


## 기수 정렬(radix sort)
- 값을 비교하지 않는 특이한 정렬.
- 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교.
- 시간 복잡도는 O(kn) k는 데이터의 자릿수.
- 시간 복잡도가 가장 짧은 정렬.
