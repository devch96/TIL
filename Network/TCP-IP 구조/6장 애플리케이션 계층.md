# 애플리케이션 계층

- 네트워크상에서 애플리케이션이 동작하도록 다양한 기능을 제공하는 계층
- 물리 계층, 데이터링크 계층, 네트워크 계층을 통해 전송되고 트랜스포트 계층에서 선별된 패킷은 최종적으로 애플리케이션 계층에서
처리됨
- 애플리케이션 계층의 프로토콜은 세션 계층(L5), 프레젠테이션 계층(L6), 애플리케이션 계층(L7)을 모아서 하나의 애플리케이션 프로토콜로 표준화됨

----------

## HTTP

- 애플리케이션 프로토콜 중 가장 깊고도 잘 알려진 것이 HTTP(Hypertext Transfer Protocol)
- 웹브라우저는 최초의 'http' 부분을 보고 'HTTP로 액세스합니다'라고 웹서버에게 선언하면서 요청을 송신함
- HTTP는 원래 텍스트 파일을 다운로드하기 위한 목적의 간소한 프로토콜이였으나 지금은 파일 송수신에서 실시간 메시지 교환, 동영상 송출부터 웹 회의 시스템에 이르기까지
셀 수 없이 많은 용도로 사용함

### HTTP 버전

- HTTP는 네 번의 큰 버전 업그레이드가 있었음
  - HTTP/0.9 -> HTTP/1.0 -> HTTP/2 -> HTTP/3
- 웹브라우저와 웹서버의 설정에 따라 어떤 버전에서 연결하는지 달라짐
- HTTP/0.9
  - 텍스트 파일 다운로드만 함
  - 헤더나 바디 등 메시지 포맷 규정도 존재하지 않음
  - 현재는 사용되지 않음
- HTTP/1.0
  - 메시지 포맷 책정
  - 다양한 파일 전송 가능
  - 다운로드, 업로드 가능
- HTTP/2
  - 바이너리 형식으로 통신
  - 멀티플렉싱/헤더 압축/ 서버 푸시 추가
  - 거대 웹사이트에서의 채용 확대
- HTTP/3
  - UDP/TLS 1.3을 사용해 성능 향상

#### HTTP/0.9

- HTML로 기술된 텍스트 파일을 서버에서 다운로드하기 위한 단순한 것

#### HTTP/1.0

- 텍스트 파일 이외에도 다양한 파일을 다룰 수 있게 되어 다운로드 뿐만 아니라 업로드나 삭제도 가능해짐에 따라 프로토콜로서 그 폭이 크게 넓어짐
- 메시지의 포맷이나 요청과 응답의 기본적인 사용도 확립
- 현재의 HTTP 토대

#### HTTP/1.1

- HTTP/0.9나 1.0 은 리퀘스트마다 TCP 커넥션을 만들고 부수는 순서를 반복함
  - 서버에 막대한 부하가 걸림
  - 웹브라우저는 하나의 서버에 대해 동시에 오픈할 수 있는 TCP 커넥션 수가 결정되어 있음
- 킬업라이브(지속적 연결)
  - 한 번 만들어진 TCP 커넥션을 재사용하는 기능
  - 신규 커넥션 수가 줄어들고 시스템 전체의 처리 부하도 크게 줄어듬
- 파이프라인
  - 요청에 대한 응답을 기다리지 않고 다음 요청을 송신하는 기능
  - 여러 리퀘스트를 계속 송신할 수 있게 되므로 콘텐츠가 표시될 때까지의 시간 단축을 기대할 수 있음

#### HTTP/2.0

- 텍스트 형식의 메시지 단위로 교환하는 애플리케이션 데이터를 프레임(frame)이라 부르는 바이너리 형식 단위로 교환해 오버헤드 감소와 성능 향상을 목표로 함
- 멀티플렉싱
  - 1개의 TCP 커넥션 안에 스트림이라는 가상 채널을 만들고 스트림별로 요청과 응답을 교환하게 함
  - 병렬 처리를 구현할 수 있음
- HPACK
  - 메시지 헤더(HTTP 헤더)를 압축하는 기능
  - 자주 사용하는 HTTP 헤더 이름이나 헤더를 미리 정적으로 결정한 숫자로 치환하거나 한 번 송신한 HTTP 헤더를 동적으로 할당한 숫자로 치환하는 등 헤더의
  전송량을 줄임
- 서버 푸시
  - HTTP/1.1 까지 HTTP는 하나의 요청에 대해 하나의 응답을 반환하는 풀 타입 프로토콜
  - HTTP/2에서는 하나의 요청에 대해 여러 응답을 반환하는 푸시 타입 기능 추가
  - HTTP/2 서버는 클라이언트가 최초로 요청한 콘텐츠를 해석하고 다음에 올 요청에 대한 응답을 요청이 오기 전에 보냄
  - 웹브라우저는 그 응답을 캐시하고 요청에 대한 응답을 캐시 영역에서 호출함
    - index.html이 script.js와 style.css를 로딩하는 HTML일 때, index.html에 대한 요청 뒤에 js 파일과 css 파일에 대한 요청이 올 것을 예상할 수
    있기 때문에 HTTP/2 서버는 그 요청이 오기 전에 script.js와 style.css를 응답하고 웹브라우저는 그 응답을 캐시해 두고 js,css에 대한 요청을
    캐시 영역에서 호출함

#### HTTP/3

- 구글이 개발한 QUIC(Quick UDP Internet Connection)를 기반으로 표준화를 진행중
- 애플리케이션 데이터를 보내지 않는 시간을 극단적으로 줄인 것으로 뛰어난 성능 향상을 목표로 함
- UDP를 이용한 지연 감소
  - TCP가 아니라 UDP를 사용함
  - 3웨이 핸드셰이크에 걸리는 시간을 줄이고 더 많은 HTTP 데이터를 보낼 수 있도록 함
- TLS 1.3을 이용한 지연 감소
  - SSL 핸드셰이크에 걸리는 시간을 줄이고 더 많은 HTTP 데이터를 보낼 수 있게 함

### HTTP/1.1의 메시지 포맷

- HTTP는 버전 업그레이드하면서 다양한 기능이 추가되었지만 메시지를 구성하는 기본 요소나 역할에 관해서는 큰 변화가 없음
- HTTP에서 교환하는 정보를 HTTP 메시지라 부름
  - 웹브라우저 서버에서 처리를 요청하는 리퀘스트 메시지
  - 서버가 웹브라우저에 처리 결과를 반환하는 리스폰스 메시지
- 두 메시지 보두 HTTP 메시지의 종류를 나타내는 스타트 라인, 각종 제어 정보를 여러 행에 걸쳐 저장하는 메시지 헤더, 애플리케이션 데이터의 본문을 저장하는
메시지 바디(HTTP 페이로드) 3가지로 구성됨

#### 리퀘스트(요청) 메시지 포맷

- 1행의 리퀘스트 라인, 여러 HTTP 헤더로 구성된 메시지 헤더, 메시지 바디 3개로 구성됨
- 리퀘스트 라인
  - 클라이언트가 서버에 ~ 해주십시오 라는 처리를 요청하기 위한 행
  - 리퀘스트 종류를 나타내는 메서드, 리소스 식별자를 나타내는 리퀘스트 URI, HTTP 버전 3가지로 구성됨
  - 메소드는 클라이언트가 서버에 대해 요청하는 리퀘스트의 종류
    - OPTIONS: 서버가 지원하는 메서드나 옵션을 확인
    - GET: 서버로부터 데이터를 얻음
    - HEAD: 메시지 헤더만 얻음
    - POST: 서버로 데이터를 전송
    - PUT: 서버로 로컬 데이터를 전송
    - DELETE: 파일을 삭제
    - TRACE: 서버로의 경로를 확인
    - CONNECT: 프로시 서버에 터널링을 요청

#### 리스폰스(응답) 메시지 포맷

- 1행의 스테이터스 라인, 메시지 헤더, 메시지 바디 3가지로 구성
- 스테이터스 라인
  - 웹서버가 웹브라우저에 대해 처리 결과의 개요를 반환하는 행


### 다양한 HTTP 헤더

- 스테이트 라인(리퀘스트 라인 또는 스테이터스 라인) 뒤에는 HTTP 메시지를 제어하는 메시지 헤더가 이어짐
- 메시지 헤더는 리퀘스트 헤더, 리스폰스 헤더, 일반 헤더, 엔티티 헤더, 기타 헤더 5종류의 헤더 조합으로 구성됨

#### 리퀘스트 헤더

- 리퀘스트 메시지를 제어하기 위한 헤더
- Accept 헤더
  - 웹브라우저가 처리할 수 있는 파일의 종류(MIME 타입, 미디어 타입)와 그 상대적인 우선도를 웹서버에 전달하기 위해 사용되는 리퀘스트 헤더
  - ~의 파일이면 처리합니다! 라고 웹서버에 전달
  - 웹서버는 이 정보를 바탕으로 브라우저가 처리할 수 있는 파일을 반환하고, 대응하는 파일이 없는 경우 406 Not Acceptable을 반환함
- Host 헤더
  - HTTP/1.1에서 유일한 필수 항목 헤더
  - 웹브라우저가 리퀘스트하는 웹서버의 도메인 이름과 포트 번호가 설정됨
    - http://www.example.com/html/foobar.txt
    - 라면 Host 헤더에는 'www.example.com:8080' 이 설정됨
- Referer 헤더
  - 직전의 연결 소스의 URI를 나타내는 헤더
- User-Agent 헤더
  - 웹브라우저나 OS 등 사용자의 환경을 나타내는 헤더
  - 통일된 포맷이 없고 웹브라우저에 따라 다름
  - 모든 데이터를 곧이곧대로 믿는 것은 위험함
    - 디버깅 도구나 User-Agent Switcher 등의 웹브라우저 확장 기능으로 간단하게 변조할 수 있기 때문

#### 리스폰스 헤더

- 리스폰스 메시지를 제어하기 위한 헤더
- ETag 헤더
  - 웹서버가 가진 파일 등의 리소스를 유일하게 식별하기 위한 헤더
- Location 헤더
  - 리다이렉트 위치를 알리기 위해 사용하는 헤더
  - 300번대의 스테이터스 코드와 조합해서 사용함
  - 대부분의 웹브라우저는 Location 헤더를 포함하는 리스폰스를 받으면 자동으로 Location 헤더가 가리키는 리다이렉트 대상지로 액세스하도록 되어 있음
- Server 헤더
  - 웹서버의 정보가 설정되어 있는 헤더
    - 웹서버의 OS나 그 버전, 소프트웨어나 그 버전 등이 설정되어 있음
  - 서버 헤더는 서버의 정보를 그대로 전 세계에 알리게 되므로 보안상 문제가 있음
  - 보통은 비활성화함

#### 일반 헤더

- 리퀘스트, 리스폰스 모두에서 범용으로 사용되는 헤더
- Cache-Control 헤더
  - 웹브라우저나 서버의 캐시를 제어하기 위해 사용하는 헤더
  - 프라이빗 캐시
    - 웹브라우저에 저장되는 캐시
    - 최초 리퀘스트에 대한 리스폰스 데이터를 프라입시 캐시로 저장하고 같은 URL에 대해 2번째 이후의 리스폰스로 사용함
  - 공유 캐시
    - 프록시 서버나 CDN의 에지 서버에 저장되는 캐시
    - 첫 번째 사용자의 리스폰스 데이터를 공유 캐시로 저장하고 두 번째 사용자 이후의 모든 사람의 리스폰스로 사용함
- Connection 헤더/Keep-Alive 헤더
  - 킵얼라이브(지속적 연결)를 제어하는 헤더
  - 웹브라우저는 Connection 헤더에 'keep-alive'를 설정하고 전달하면 웹서버도 Connection 헤더에 'keep-alive'를 설정해 리스폰스함
  - Keep-Alive 헤더를 사용해 다음 리퀘스트가 오지 않을 때의 타임아웃 시간이나 그 TCP 커넥션에 대한 잔여 리퀘스트 수 등 킵얼라이브에 관한 정보를 전달함
  - Connection헤더에 'close'가 설정되면 TCP 커넥션을 닫음

#### 엔티티 헤더

- 리퀘스트, 리스폰스 메시지에 포함되는 메시지 바디에 관련한 제어 정보를 포함하는 헤더
- Content-Encoding 헤더 / Accept-Encoding 헤더
  - 웹브라우저가 처리할 수 있는 메시지 바디의 압축 방식을 지정하는 헤더
  - 웹브라우저는 자신이 대응(받아들일 수 있는) 콘텐츠 코딩 형식을 Accept-Encoding 헤더에 설정해 리퀘스트함
  - 웹서버는 Accept-Encoding 헤더 안에서 선택한 콘텐츠 코딩 형식으로 HTTP 메시지를 압축하고 그 방식을 Content-Encoding 헤더에 설정한 뒤 웹브라우저에 리스폰스함
- Content-Length 헤더
  - HTTP/1.1에서는 킵얼라이브에 따라 하나의 커넥션을 재활용하는 경우가 있기 떄문에 TCP 커넥션이 반드시 클로즈된다고 단언할 수 없음
  - 메시지의 경계를 TCP에 전달하고 적절하게 TCP 커넥션이 클로즈되도록 함

#### 기타 헤더

- Set-Cookie / Cookie
  - Cookie란 HTTP 헤더와의 통신에서 특정한 정보를 브라우저에 저장시키는 구조 및 저장한 파일
  - 웹브라우저가 사용자 이름과 비밀번호를 이용해 한 번 로그인에 성공ㅇ하면 서버는 세션 ID를 발생하고 Set-Cookie 헤더에 설정해서 리스폰스함
  - 그 뒤 리퀘스트는 Cookie 헤더에 세션 ID를 설정해서 수행되기 때문에 자동으로 로그인이 실행됨
- X-Forwarded-For
  - 부하 분산 장치에서 송신지 IP 주소가 변환되는 환경에서 변환 전의 송신지 IP 주소를 저장하는 헤더
  - 네트워크의 설정 방법에 따라 송신지 IP 주소를 NAPT하지 않으면 부하 분산 처리를 할 수 없는 경우가 있음
    - AWS의 로드밸런서인 ELB나 ALB도 송신지 IP 주소가 ELB/ALB의 IP 주소로 변환됨
    - 단순히 송신지 IP 주소만 보면 어느 IP 주소로부터 액세스되었는지 알 수 없음
    - X-Forwarded-For의 값을 보면 어느 IP 주소로부터 액세스되었는지 특정할 수 있음
- X-Forwarded-Proto
  - X-Forwarded-For의 프로토콜 버전
  - 부하 분산 장치에서 프로토콜이 변화되는 과정에서 변환 전 프로토콜을 저장함

#### 메시지 바디

- 애플리케이션 데이터 그 자체가 들어 있는 필드
- 옵션 사항

### HTTP/2의 메시지 포맷

- HTTP/1.1은 메시지 헤더와 메시지 바디를 줄 바꿈 코드로 구분한 텍스트 형식의 메시지 단위로 TCP 커넥션으로 보냄
  - 텍스트 형식은 사람이 이해하긴 쉽지만 컴퓨터가 해석하기엔 바이너리 형식으로 변환 처리 해야 함 (오버헤드)
- HTTP/2는 메시지 헤더를 HEADERS 프레임에, 메시지 바디를 DATA 프레임에 각각 분할해서 저장하고 바이너리 형식의 프레임 단위로 스트림에 보냄
  - 프레임에 스트림을 식별하는 스트림 ID를 부여해서 어떤 스트림에 프레임을 보내는지 지정함
  - 변환 처리가 필요 없음

#### 리퀘스트 라인과 스테이터스 라인

- HTTP/2에서는 리퀘스트 라인과 스테이터스 라인의 구성 요소를 헤더로 취급함
- 리퀘스트 라인
  - HTTP/1.1의 리퀘스트 라인은 리퀘스트의 종류를 나타내는 메서드, 리소스의 식별자를 나타내는 리퀘스트 URI, HTTP 버전을 나타내는 HTTP 버전을 1행의 텍스트로 송신
  - HTTP/2는 메서드를 :method 헤더에, 리퀘스트 URI를 :path 헤더에, HTTP 버전을 :version 헤더에 각각 저장한 뒤 HEADERS 프레임으로 송신
- 스테이터스 라인
  - HTTP/1.1의 스테이터스 라인은 HTTP 버전, 처리 결과의 개요를 3자리 문자열로 나타내는 스테이터스 코드, 이유를 나타내는 리즌 프레이즈를 1행의 텍스트로 송신
  - HTTP/2는 HTTP 버전을 :version 헤더에, 스테이터스 코드를 :status 헤더에 각각 저장한 뒤 HEADERS 프레임으로 송신(리즌 프레이즈는 사라짐)

#### 프로토콜 업그레이드

- HTTP/1.x와 HTTP/2는 기본적인 구성 요소나 역할에 큰 차이는 없지만 다른 형식을 이용하기 떄문에 호환성이 없음
- HTTP/2로 연결하기 위해서는 연결 상황에 따라 몇 가지 순서를 거쳐야 함
  - SSL 핸드셰이크 패턴
  - HTTP 헤더 패턴
  - 다이렉트 연결 패턴
- SSL 핸드셰이크 패턴
  - SSL/TLS로 암호화 통신하기 전에 수행하는 사전 준비
  - 보안을 확보하기 위해 암호화 방식이나 인증 방식을 결정하거나 상호 인증을 하거나 암호화에 사용할 공통키를 교환함
  - HTTP/2로 연결할 때는 SSL 핸드셰이크의 ALPN(Application-Layer Protocol Negotiation)이라는 확장 기능을 사용
  - ALPN을 사용해 서로 HTTP/2에 대응하는 것을 전달하고 HTTP/2로 접속함
- HTTP 헤더 패턴
  - SSL/TLS로 암호화 통신을 하지 않을 때는 SSL 핸드셰이크를 사용하지 못하기에 HTTP 헤더를 사용함
  - 웹브라우저는 최초에 HTTP/1.1로 데이터를 얻을 때 여기에 Upgrade 헤더를 붙여 HTTP/2에도 대응한다라고 전달함
  - 서버가 HTTP/2에 대응한다면 마찬가지로 Upgrade 헤더를 붙여 '101 Switching Protocol'의 스테이터스 코드를 반환하고 HTTP/2로 이행함
  - 반대로 서버가 HTTP/2 이행을 제안하는 경우도 있음
- 다이렉트 연결
  - 미리 클라이언트와 서버가 함께 HTTP/2로 연결할 수 있음을 알고 있는 검증 환경 등에서 사용

### 부하 분산 장치의 동작

- 부하 분산 장치는 네트워크 계층이나 트랜스포트 계층, 애플리케이션 계층의 정보를 이용해 여러 서버에 커넥션을 할당하는 기능
- 부하 분산 장치상에 설정한 가상 서버에서 받은 커넥션을 정해진 규칙에 따라 이 통신은 서버 1, 이 통신은 서버 2로 할당함으로써 처리 부하를 여러 서버로 분산함

#### 수신지 NAT

- 서버 부하 분산 기술의 기본
- NAT 하나로 패키지의 수신지 IP 주소를 변환하는 기술
- 부하 분산 장치는 클라이언트로부터 패킷을 받으면 서버의 살아 있는 상태나 커넥션의 상태를 확인하고 최적의 서버 IP 주소로 수신지 IP를 변환함
- 부하 분산 장치의 수신지 NAT는 커넥션 테이블이라 부르는 메모리상의 테이블 정보를 기반으로 수행함
  - 부하 분산 장치는 받은 커넥션의 '송신지 IP 주소:포트 번호', '가상 IP 주소(변환 전 수신지 IP 주소):포트 번호','서버 IP 주소(변환 후 수신지 IP 주소):포트 번호', 프로토콜
  등의 정보를 커넥션 테이블로 관리하고 어느 커넥션을 어느 IP 주소에 수신지 NAT 할 것인지 파악함

#### 헬스 체크

- 부하 분산 대상 서버의 상태를 감시하는 기능
- 중단된 서버에 커넥션을 할당하지 않기 위함
- 부하 분산 장치는 서버에 대해 정기적으로 감시 패킷을 보내서 가동 여부를 감시하고 중단이라고 판단하면 해당 서버를 부하 분산 대상에서 제외함

#### 부하 분산 방식

- 정적 부하 분산
  - 미리 정의된 설정에 따라 분배할 서버를 정하는 방식
    - 순서대로 할당하는 라운드 로빈
    - 미리 정해 둔 비율에 기반해 할당하는 비율
- 동적 부하 분산
  - 서버 상황에 맞춰 할당할 서버를 결정하는 방식
    - 커넥션 수에 맞춰 할당하는 최소 커넥션 수
    - 응답 시간에 맞춰 할당하는 최단 응답 시간

#### 옵션 기능

- 부하 분산 장치는 이전에는 네트워크 계층이나 트랜스포트 계층에서의 동작이 중심이였으나 최근에는 애플리케이션 계층까지 넓혀
애플리케이션 딜리버리 컨트롤이라고도 부르게 됨
- 퍼시스턴스
  - 애플리케이션의 같은 세션을 같은 서버에 계속 할당하는 기능
  - 송신지 IP 주소 퍼시스턴스
    - 클라이언트의 IP 주소를 기반으로 같은 서버에 할당을 계속하는 방식
  - Cookie 퍼시스턴스
    - Cookie 정보를 기반으로 같은 서버에 할당을 계속하는 방식
- 애플리케이션 스위칭
  - 애플리케이션 데이터에 포함된 다양한 정보를 기반으로 더 세세하고 폭넓은 부하 분산을 수행
    - 이미지 파일만을 특정 서버로 분산하거나 스마트폰용 웹서버로 부하를 분산하는 등 다양한 정책 적용 가능
- HTTP/2 오프로드
  - 서버가 수행할 처리를 대신하는 기능
  - HTTP/2 처리를 대신함
  - 웹서버 자체를 HTTP/2에 대응하게 하려면 서버 OS의 업데이트 혹은 웹서버 애플리케이션의 모듈을 추가해야 하는 등의 복잡한 작업을 해야 하지만
  HTTP/2 오프로드를 사용하면 서버는 HTTP/1.1인 상태에서도 시스템을 HTTP/2로 대응할 수 있어 구현하기까지의 시간을 절약할 수 있음

------------------

## SSL/TLS

- Secure Socket Layer / Transport Layer Security 는 애플리케이션을 암호화하는 프로토콜
- 데이터를 암호화하거나 통신 상대를 인증하는 등으로 중요한 데이터를 보호함
- 웹사이트 중 URL이 https:// 로 바뀌고 주소에 자물쇠 마크가 표시된 것은 SSL로 암호화되어 데이터가 보호되고 있음을 나타내는 것
  - HTTPS: HyperText Transport Protocol Secure
    - HTTP를 SSL로 암호화한것
- 점점 모든 트래픽이 SSL로 암호화되는 상시 SSL화 시대가 되어 가고 있음

### SSL에서 이요하는 기술

#### SSL로 방지할 수 있는 위협

- SSL은 암호화, 해시화, 디지털 인증서라는 3가지 기술을 조합해 사용함으로서 다양한 보안 위협에 대항함
- 암호화를 통한 도청 방지
  - 정해진 규칙에 기반해 데이터를 변환하는 기술
  - 도청을 방지함
- 해시화를 통한 변조 방지
  - 애플리케이션 데이터로부터 정해진 계산(해시 함수)에 기반해 고정된 길이의 데이터(해시값)를 추출하는 기술
  - 데이터가 바뀌면 해시값도 바뀜
    - 변조를 감지할 수 있음
- 디지털 인증서를 통한 신분 위조 방지
  - 통신 상대가 진짜인지 아닌지를 확인함으로써 신분 위조를 방지할 수 있음
  - SSL에서는 데이터를 송신하기 전에 당신의 정보를 주십시오라고 질문하고 전송받은 디지털 인증서를 기반으로 올바른 상대인가 확인함

#### SSL에서 이용하는 암호화 방식

- 공통키 암호화 방식
  - 암호화키와 복호화키로 동일한 키(공통키)를 사용하는 암호화 방식
  - 대칭키 암호화 방식이라고도 부름
  - 클라이언트와 서버는 미리 같은 키를 공유하고 암호화키로 암호화한 뒤 암호화키와 완전히 같은 키로 복호화함
  - 스트림 암호
    - 1비트 단위 또는 1바이트 단위로 암호화 처리하는 방식
    - 취약성이 발견되어 현재는 사용하지 않는 경향
  - 블록 암호
    - 데이터를 일정 비트 수 단위(블록)로 구분해 하나하나 암호화 처리 적용
    - 스트림 암호에 비해 처리에 다소 시간이 걸리지만 안전함
  - 구조 자체가 단순 명쾌하기 때문에 암호화 처리는 물론 복호화 처리 속도가 빠르며 큰 처리 부하가 걸리지 않음
  - 키가 유출되면 끝이기 때문에 서로 공유하는 키를 어떻게 상대에게 전송하는가 하는 전송 문제가 있음
- 공개키 암호화 방식
  - 암호화키와 복호화키로 다른 키를 사용하는 암호화 방식
  - 비대칭키 암호화 방식
  - 공개키
    - 누구에게나 공개해도 괜찮은 키
  - 비밀키
    - 모두에게는 비밀로 해야 하는 키
  1. 웹서버는 공개키와 비밀키(키 페어)를 만듬
  2. 웹서버는 공개키를 모두에게 공개/배포 하고 비밀키만 보관함
  3. 웹브라우저는 공개키를 암호화키로 사용해서 데이터를 암호화한 뒤 전송
  4. 웹서버는 비밀키를 복호화키로 사용해서 데이터를 복호화함
  - 키 전송에 신경쓰지 않아도 됨
  - 처리가 복잡하기 때문에 암호화 처리와 복호화 처리에 시간이 소요되며 처리 부하도 걸림
- 하이브리드 암호화 방식
  - SSL은 이 두 암호화 방식을 조합해서 사용함으로써 처리 효율을 높임
  - 공개키 암호화 방식을 사용해서 서로 공유해야만 하는 공통키의 재료를 교환함
  - 각각 공통키의 재료에서 공통키를 만들고 그 키를 사용해서 공통키 암호화 방식을 데이터를 암호화함
  - SSL은 공개키 암호화 방식으로 키 전송 문제를 해결하고 공통키 암호화 방식으로 처리 부하 문제를 해결함
  1. 웹서버는 공개키와 비밀키를 만듬
  2. 웹서버는 공개키를 모두에게 공개/배포하고 비밀키만 보관함
  3. 웹브라우저는 공통키의 재료를 공개키로 암호화해서 보냄
  4. 웹서버는 공통키의 재료를 비밀키로 복호호홤
  5. 웹서버와 브라우저는 공통키의 재료로부터 공개키를 생성함
  6. 웹브라우저는 애플리케이션 데이터를 공통키로 암호화함
  7. 웹서버 애플리케이션 데이터는 공통키로 복호화함

#### SSL에서 이용하는 해시 함수

- 해시화는 애플리케이션 데이터를 해시 포테이토처럼 잘게 쪼개서 같은 크기의 데이터로 모으는 기술
- 해시값을 비교하는 편이 보다 효율적
  - 데이터 그 자체를 도구로 비교하는 것이 가장 간단하지만 데이터 크기가 커지면 시간이 오래 걸리고 처리 부하도 상당함
  - 데이터를 해시화해서 비교하기 쉽게 함
  - 단방향 해시 함수라는 특수한 계산을 이용해서 데이터를 잘게 쪼개고 같은 크기의 해시값으로 모음
  - 데이터가 다르면 해시값도 다르다
    - 데이터가 1비트라도 다르면 해시값은 완전히 다른 것이 됨
    - 데이터 변조를 감지할 수 있음
  - 데이터가 같으면 해시값도 같다
  - 해시값에서 원 데이터를 복원할 수 없다
    - 데이터를 요약한 것에 불과함
    - 해시값을 훔친다고 하더라도 보안상 문제가 되지 않음
  - 데이터 크기가 달라도 해시값 크기는 고정된다
    - 데이터가 1비트든, 1메가 바이트든, 1기가 바이트든 동일함
    - SHA-256으로 산출된 해시값의 길이는 원 데이터 크기에 관계없이 반드시 256비트
- 애플리케이션 데이터 검증
  - 송신자는 애플리케이션 데이터와 해시값을 전송
  - 수신자는 애플리케이션 데이터로부터 해시값을 계산하고 전송된 해시값과 자신이 계산한 해시값 비교
    - 일치하면 변조가 없고 일치하지 않으면 변조되었다고 판단
  - SSL에서는 간단한 단방향 해시 함수가 아닌 메시지 인증 코드라는 기술을 사용함
    - 애플리케이션 데이터와 MAC키(공통키)를 뒤섞어 MAC값(해시값)를 계산한 기술
    - 공통키가 추가되므로 변조 감지 뿐만 아니라 상대를 인증할 수도 있음
- 디지털 인증서 검증
  - 인증서의 검증에도 해시화를 사용함
  - 인증서에 내가 A입니다 라고 적혀있더라도 신뢰성이 없음
    - 실제 A인지 모르기 때문
    - B가 A입니다 라고 보낼수도 있음
  - SSL은 제3자 인증이라는 구조를 채용함
  - 제3자 인증 기관(CA)에 'A가 A인 것'을 디지털 서명이라는 형태로 승인받고 서명에 해시화를 사용함

### SSL 버전

- 치명적인 취약성이 발견될 때마다 버전의 업그레이드가 이루어짐
  - SSL 2.0 -> SSL 3.0 -> TLS 1.0 -> TLS 1.1 -> TLS 1.2 -> TLS 1.3
- 어느 버전으로 연결할 것인가는 웹브라우저와 웹서버 대응 상황과 설정에 따라 다름
- 암호화 통신에 앞서 공개키 방식으로 수행되는 SSL 핸드셰이크에 따라 버전 사용이 결정됨

#### SSL 2.0

- 1.0은 출시되기도 전에 치명적인 취약성이 발견되어 하루도 되지 않아 폐기됨
- 다운그레이드 공격이나 버전 롤백 공격 등의 치명적인 취약성이 발견되어 대응하는 소프트웨어가 없음
  - 다운그레이드 공격: 가장 강도가 약한 암호화 방식을 강제로 사용하도록 함으로써 해독하기 쉬운 암호화 통신을 하게 만드는 공격
  - 버전 롤백 공격: 원래 이용할 수 있는 버전보다도 낮은 버전을 강제로 사용하도록 함으로써 해독하기 쉬운 암호화 통신을 하게 만드는 공격

#### SSL 3.0

- 오랜 시간에 걸쳐 SSL의 대표 주자로 군림했으나 POODLE(Padding Oracle On Downgraded Legacy Encryption) 공격의 발견을 계기고 폐기됨
  - POODLE: 블록 암호인 CBC 모드의 취약성을 이용한 공격으로 패딩을 악용해 암호화 통신을 해독함

#### TLS 1.0

- 기본 기능은 SSL 3.0과 크게 다르지 않지만 POODLE 공격에 대응하고 강력한 암호화 방식에 대응함으로써 안정성 향상을 목표로 함
- 20년 이상 걸쳐 사용되었지만 암호화 방식이나 인증 방식이 노후화된 이유도 있어 2020년에 주요 4대 브라우저(크롬, 파이어폭스, 사파리, 에지)에서 지원을 중단한다고 발표함

#### TLS 1.1

- TLS 1.0에서 취약성을 지적받은 BEAST(Browser Exploit Againt SSL/TLS) 공격에 대응하고 수출용 암호를 폐지함으로써 안정성 향상을 목표로 함
  - BEAST: 블록 암호인 CBC 모드의 취약성을 이용한 공격으로 브라우저 내의 Cookie를 입수함
  - 수출용 암호: 미국의 수출 규제에 대응하기 위해 해독하기 쉽게 설계된 암호화/해시 함수의 조합
- TLS 1.0과 함께 지원 중단

#### TLS 1.2

- SHA-2(SHA-256, SHA-384) 해시 함수에 대응하고 인증 기능을 붙인 암호화 방식에 대응함으로써 안정성을 더 향상하는 것을 목표로 함
- 현재 가장 많이 사용되는 버전
- 소프트웨어 측의 TLS 1.3대응이 안정될 때까지 TLS 1.2만 유지될듯

#### TLS 1.3

- 더욱 강력한 해시 함수, 암호화 방식에 대응함으로써 안정성 향상 목적
- SSL 핸드셰이크 프로세스를 간략화해서 성능 향상을 목표로 함
- HTTP/3와의 호환성이 높음

### SSL 레코드 포맷

- SSL을 통해 전달되는 메시지를 SSL 레코드라 부름
- SSL 헤더, SSL 페이로드로 구성됨
- SSL 헤더는 콘텐츠 타입, 프로토콜 버전, SSL 페이로드 길이라는 3가지 필드로 구성됨

### SSL 접속에서 종료까지의 흐름

- HTTPS 서버를 인터넷에 공개하는 것을 전제

#### 서버 인증서 준비

- HTTPS 서버를 인터넷에 공개하기 위해서는 서버 인증서(서버를 증명하기 윟나 디지털 인증서)를 준비, 인증 기관으로의 신청 등을 사전에 준비해 두어야 함

1. HTTPS 서버에서 비밀키를 만듬. 기밀 정보이므로 주의를 기울여 보관해야 함
2. 1에서 만든 비밀키를 기반으로 CSR(Certificate Signing Request)을 만들어 인증 기관에 보냄. CSR은 간단하게 말하면 서버 인증서를 얻기 위한 신청서와 같은 것.
3. 인증 기관이 신청자의 신원을 조사함. 조사를 통과하면 CSR을 해시화, 인증 기관의 비밀키로 암호화해서 디지털 서명으로 만듬. 인증 기관은 서버 인증서를 발생하고 요청자에게 송신함
4. 인증 기관에서 받은 서버 인증서를 서버에 설치함

#### SSL 핸드셰이크를 통한 사전 준비

- SSL은 갑자기 메시지를 암호화해서 보낼 수 있는 것이 아닌 메시지를 암호화하기 전에 암호화하기 위한 정보나 통신 상대를 확인하는 사전 준비 처리를 하는
SSL 핸드셰이크라는 단계를 갖음
- SSL은 TCP의 3웨이 핸드셰이크로 TCP 커넥션을 연 뒤 핸드셰이크 레코드를 이용해서 SSL 핸드셰이크하고 여기에서 결정된 정보를 기반으로 메시지를 암호화함

1. 대응하는 암호화 방식과 해시 함수 제시
   - 웹브라우저가 사용할 수 있는 암호화 방식이나 단방향 해시 함수를 제시함
   - SSL이나 HTTP의 버전, 공통키 작성에 필요한 client random 등 서버와 맞춰 두어야 하는 확장 기능의 파라미터도 전송함
2. 통신 상대 증명
   - 실제 서버와 통신하고 있는가를 서버 인증서로 확인함
   - Server Hello
     - Client Hello에서 받은 암호 스위트 리스트와 자신이 가진 암호 스위트 리스트를 참조해서 일치한 암호 스위트 안에서 가장 우선도가 높은 암호 스위트 선택
     - SSL이나 HTTP 버전, 공통키 작성에 사용하는 server random 등 클라이언트와 맞춰야만 하는 확장 기능의 파라미터도 포함해 리턴함
   - Certificate
     - 자기 자신의 서버 인증서를 보내고 자신이 제 3자 기관으로부터 인증받은 본인이라는 것을 증명함
   - Server Hello Done
     - 내 정보는 모두 보냈습니다 라고 알림
     - 웹브라우저는 받은 서버 인증서를 검증하고 올바른 서버인지 확인함
   - 공통키 교환
     - 애플리케이션 데이터의 암호화와 해시화에 사용할 공통키의 자료를 교환함
     - 웹브라우저는 통신 상대가 실제 서버인 것을 확인하면 프리 마스터 시크릿이라는 공통키의 재료를 만들어 서버로 보냄
       - 공통키 자체가 아니라 공통키를 만들기 위한 재료
     - 웹브라우저와 HTTPS 서버는 프리 마스터 시크릿과 Client Hello로 얻은 client random, Server Hello에서 얻은 server random을 섞어 마스터 시크릿을 만듬
     - 마스터 시크릿을 이용해 데이터 암호화에 사용하는 공통키 세션키와 해시화에 사용하는 MAC키를 만듬
   - 최종 확인 작업
     - Change Chiper Spec과 Finished를 교환하고 SSL 핸드셰이크를 종료함
     - 종료되면 SSL 세션이 만들어지고 애플리케이션 데이터 암호화 통신을 시작함

#### 암호화 통신

- 애플리케이션 데이터를 MAC키로 해시화한 뒤, 세션키로 암호화해서 애플리케이션 데이터 레코드로 전송함

#### SSL 세션 재이용

- 최초의 SSL 핸드셰이크에서 생성한 세션 정보를 캐시해서 2번째 이후에 재사용하는 SSL 세션 재이용이라는 기능을 제공

#### SSL 세션 종료

- 세션을 닫을 때는 웹브라우저 혹은 서버에 관계없이 종료하고 싶은 측에서 close_notify를 송출함
- 그 뒤 TCP 4웨이 핸드셰이크하고 TCP 커넥션을 종료함

### 클라이언트 인증서를 이용한 클라이언트 인증

- 클라이언트 인증은 미리 웹브라우저에 설치한 클라이언트 인증서를 이용해 인증함

1. 클라이언트 인증서 요청
2. 클라이언트 인증서 전송
3. 이제까지의 해시값을 송부

### SSL 오프로드 기능의 동작

- 서버에서 수행하던 SSL 처리를 부하 분산 장치에서 수행하는 기능

---------------------

## DNS

- Domain Name System은 IP 주소와 도메인 이름을 상호 교환하는 프로토콜
- 인터넷에서는 단말을 식별하기 위해 IP 주소를 사용하지만 IP 주소는 숫자의 나열이므로 그것을 본다하더라도 의미를 알 수 없음
- DNS는 IP 주소에 도메인 이름이라는 이름을 붙여 사람이 이해하기 쉬운 형태로 통신함

### 도메인 이름

- 도메인 이름은 'www.example.com'과 같이 점으로 구분된 문자열로 구성됨
  - 문자열 하나하나를 라벨이라 부름
- 도메인 이름은 루트를 꼭짓점으로 탑 레벨 도메인, 세컨드 레벨 도메인, 서브 레벨 도메인 ... 으로 나누어지는 트리 형태의 계층 구조
- 오른쪽부터 순서대로 라벨을 따라 가면 결국 대상이 되는 서버에까지 도달하도록 되어 있음
- www.example.co.kr
  - www : 호스트 부분
  - example.co.kr : 도메인 부분
  - kr: 탑 레벨 도메인
  - co : 세컨드 레벨 도메인
  - example: 서드 레벨 도메인

### 이름 결정과 존 전송

#### 이름 결정

- IP 주소와 도메인 이름을 서로 교환하는 처리를 이름 결정이라 함
- DNS 클라이언트, 캐시 서버, 권위 서버가 서로 연계함으로써 성립
- DNS 클라이언트[별명: 스텁 리졸버(stub resolver)]
  - DNS 서버에 이름 결정을 요청하는 클라이언트 단말/소프트웨어
    - 웹브라우저, 메일 소프트웨어 등
  - 캐시 서버에 대해 이름 결정 요청을 송신함
  - 캐시 서버로부터 받은 응답의 결과를 일정 시간 캐시해두고 같은 질문이 있을 때 재이용함
- 캐시 서버[별명: 풀 서비스 리졸버(full service resolver), 참조 서버(reference server)]
  - DNS 클라이언트로부터의 재귀 쿼리를 받아 인터넷상에 있는 권위 서버로 이름 결정 요청을 송신하는 서버
  - 권위 서버로부터 받은 응답 결과를 일정 기간 캐시해두고 재이용함
- 권위 서버[별명: 콘텐츠 서버(contents server), 존 서버(zone server)]
  - 자신이 관리하는 도메인에 관해 캐시 서버로부터의 반복 쿼리를 받아들이는 서버
  - 루트 서버라 부르는 부모격의 서버를 꼭짓점으로 한 트리 형태의 계층 구조로 되어 있음

#### DNS 서버 자동화와 존 전송

- DNS 서버는 싱글 구성이 아니라 프라이머리 DNS 서버와 세컨더리 DNS 서버로 다중 구성하는 것이 기본
- 캐시 서버와 권위 서버의 다중화 방식이 다름
- 캐시 서버 다중화
  - 프라이머리 DNS 서버와 세컨더리 DNS 서버와의 사이에서 무언가의 정보를 동기화할 필요가 없음(캐싱만 하기 때문)
  - 서버 기능으로 다중화 불필요
  - 프라이머리 DNS 서버로부터 리플라이가 돌아오지 않으면 세컨더리 DNS 서버에 다시 쿼리할 뿐
- 권위 서버 다중화
  - 프라이머리 서버가 중단되어도 세컨더리 DNS 서버로 같은 정보를 반환할 수 있도록 존 파일을 잃지 않고 동기화해야 함
    - 존 전송

#### 존 파일과 리소스 레코드

- 하나의 존 파일로 관리하는 도메인 이름의 범위를 존이라 부름

### DNS를 이용한 기능

- DNS는 HTTP 패킷이나 HTTPS 패킷, 메일 패킷의 행선지를 결정하는 중요한 역할

#### DNS 라운드 로빈

- DNS를 이용한 부하 분산 기술
- 권위 서버에서 하나의 도메인에 여러 IP 주소를 등록해 두면 DNS 쿼리를 받을 때마다 순서대로 다른 IP주소를 반환함
- 부하 분산 장치를 준비하지 않아도 권위 서버의 존 파일 설정만으로 손쉽게 서버의 부하 분산을 구현할 수 있음
- 서버의 상태나 애플리케이션의 움직임에 관계없이 순서대로 IP 주소를 반환하기 때문에 장애에 대한 내성이나 유연성은 부족함

#### 광역 부하 분산

- 지리적으로 떨어져 있는 장소에 있는 서버에 통신을 할당해 부하를 분산하는 기술
- 온프레미스에서는 부하 분산 장치의 한 기능으로 제공됨.
- 클라우드에서는 DNS 서비스의 한 기능으로 제공됨

#### CDN

- 웹콘텐츠를 대량 송신하기 위해 최적화된 인터넷상 서버 네트워크
- 오리진 서버와 캐시를 가진 에지 서버로 구성됨
- CDN 자체는 DNS에 특화된 기능을 사용하는 것은 아니지만 사용자를 물리적으로 더 가까운 에지 서버로 유도하기 위해 DNS를 사용함
- CDN의 권위 서버는 클라이언트 IP 주소를 보고 가장 가까운 에지 서버의 IP주소를 반환함

---------------

## 메일 계열 프로토콜

- 메일은 송신과 수신에 각각 다른 프로토콜을 사용함

### 메일 송신 프로토콜

- SMTP(Simple Mail Transfer Protocol)을 사용
- 클라이언트의 리퀘스트에 대해 서버가 리플라이를 반환하는 전형적인 클라이언트 서버 타입 프로토콜
- 보안 문제가 있기에 그 상태 그대로 사용하진 않음

#### STMP

- 메일 소프트웨어(SMTP 클라이언트)는 메일 서버(SMTP 서버)에 대해 메일을 보낼 때 SMTP를 사용함
- 메일 서버가 상대 메일 서버에 메일을 전송할 때도 SMTP 사용
- 인증 기능
  - SMTP 인증
    - TCP 587 사용
    - 메일 서버는 메일을 송신하기 전에 사용자 이름과 비밀번호로 사용자를 체크함
  - POP before SMTP
    - POP를 이용한 사용자 인증 기능
    - POP는 메일을 수신할 때 사용하는 프로토콜
    - 수신하기 전에 사용자 인증을 하는데 그 인증 기능을 응용함
- 암호화 기능
  - SMTPS
  - HTTPS는 서버에 SSL 핸드셰이크를 걸어 암호화처리하지만 SMTPS는 최초에 서로가 SMTPS에 대응하고 있는 것을 STARTTLS라는 SMTP의
  확장 기능을 사용해 확인함

### 메일 수신 프로토콜

#### POP3

- TCP 110번을 사용해 통신
- 메일 소프트웨어(POP3 클라이언트)는 메일 서버(POP3 서버)로부터 메일을 추출할 때 POP3를 사용
- SMTP는 데이터를 송신하고자 할 때 보내는 '푸시 타입'의 프로토콜
  - 서버의 전원이 계속 켜져있음
- 메일 소프트웨어를 움직이는 PC는 전원이 반드시 켜져있다고 단정할 수 없음
  - '풀 타입' 프로토콜인 POP3 사용
- 메일 소프트웨어는 수동 또는 정기적으로 메일 서버에 내 메일을 주십시오라고 리퀘스트

#### IMAP4

- TCP 143번을 사용해 통신
- POP3는 메일을 메일 서버로부터 다운로드하고, 메일 소프트웨어에 저장/관리함
  - 메일 서버의 메일은 삭제됨
- IMAP4는 메일을 메일 서버에 남긴 채 메일 소프트웨어에서 열람함
  - 단말에 메일을 저장할 필요가 없으므로 단말 저장 공간 절약 가능
  - 메일 서버에서 메일을 일괄 관리할 수 있으므로 PC나 태블릿, 스마트폰 등 여러 단말에서 동일하게 메일 관리 가능

#### 웹메일

- 웹브라우저를 사용해서 메일을 송수신하거나 편집할 수 있는 서비스
- 웹브라우저가 메일 클라이언트가 되고, 메일 서버와의 교환은 HTTPS로 수행함

1. 웹브라우저를 사용해 웹메일 서버에 HTTPS로 액세스하고 ID, PASSWORD로 인증 후 메일 송신. HTTPS로 POST
2. 웹메일 서버는 DNS로 상대편 웹메일 서버의 IP 주소를 찾고, 그 IP 주소에 대해 SMTP로 메일을 전송
3. 상대 웹메일 서버는 받은 메일을 사용자별로 제공하는 메일 박스에 저장
4. 수신지 메일 주소의 사용자는 웹메일 서버에 액세스하고 HTTPS 로 GET

----------------

## 관리 액세스 프로토콜

- 원격에서 네트워크 기기의 정보를 확인하거나 설정할 때 사용하는 프로토콜

### Telnet

- Telnet 클라이언트(터미널 소프트)는 Telnet 서버(관리 대상의 네트워크 기기)에 액세스하면 3웨이 핸드셰이크로 TCP 커넥션을 염
- 기본적으로 TCP 23번 포트를 사용하지만 포트 번호 변경 가능
- 비밀번호를 포함한 모든 데이터가 암호화되지 않은 평문으로 교환되기 때문에 도중에 도청될 수 있는 보안 문제가 있음
- 최근에는 관리 액세스보다는 트랜스포트 계층 레벨의 트러블슈팅에서 더 많이 사용함

### Telnet을 이용한 트러블슈팅

- pinrg으로 시작해 트랜스포트 계층 레벨의 소통 확인을 진행

### SSH

- Secure Shell
- 기본으로 TCP 22번 사용
- Telnet에 암호화와 공개키 인증, 메시지 인증 등의 기능을 추가해 업그레이드한 것
- 3웨이 핸드셰이크로 TCP 커넥션을 연 후 4단계로 처리함
1. 파라미터 교환
2. 키 공유
3. 사용자 인증
4. 로그인

### 파일 전송

- SSH를 이용한 파일 전송 기능은 SCP와 SFTP의 2가지 종류가 있음
- SSH로 만든 암호화 통신로를 사용해 파일을 전송하는 점

### 포트 포워딩

- 특정한 포트 번호에 대한 통신을 SSH로 만든 암호화 통신로를 사용해서 다른 단말에 전송하는 기능

-------------

## 운용 관리 프로토콜

- 네트워크나 서버를 더욱 원만하게 운용/관리하기 위한 프로토콜

### NTP

- Network Time Protocol은 네트워크 기기나 서버의 시각을 맞추기 위해 사용하는 프로토콜
- 여러 네트워크 기기가 조합되어 나타나는 문제의 원인을 파악해 해결하기 위해서는 시계열로 정리하는 것이 가장 중요함
- NTP 클라이언트가 UDP 123번으로 질문하면 NTP 서버가 시각을 응답함

### SNMP

- Simple Network Management Protocol은 네트워크 기기나 서버의 성능 감시, 장애 감시에 사용하는 프로토콜
- CPU 사용률이나 메모리 사용률, 트래픽양, 패킷양 등 다양한 관리 대상 기기 정보를 정기적으로 수집하고 지속적으로 감시해 장해 징후를 빠르게 감지함

### Syslog

- 네트워크 기기나 서버의 로그를 전송하기 위해 사용되는 프로토콜

-----------